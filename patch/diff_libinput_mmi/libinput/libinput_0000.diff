Copyright (C) 2021-2024 Huawei Device Co., Ltd.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at\n

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

diff -Naur old/export_include/libinput.h new/export_include/libinput.h
--- old/export_include/libinput.h	2025-03-26 11:12:53.941121821 +0800
+++ new/export_include/libinput.h	2025-03-26 11:16:26.426458791 +0800
@@ -196,6 +196,23 @@
 	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
 	LIBINPUT_DEVICE_CAP_GESTURE = 5,
 	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+	LIBINPUT_DEVICE_CAP_JOYSTICK = 7,
+};
+
+enum evdev_device_udev_tags {
+    EVDEV_UDEV_TAG_INPUT = 1 << 0,
+    EVDEV_UDEV_TAG_KEYBOARD = 1 << 1,
+    EVDEV_UDEV_TAG_MOUSE = 1 << 2,
+    EVDEV_UDEV_TAG_TOUCHPAD = 1 << 3,
+    EVDEV_UDEV_TAG_TOUCHSCREEN = 1 << 4,
+    EVDEV_UDEV_TAG_TABLET = 1 << 5,
+    EVDEV_UDEV_TAG_JOYSTICK = 1 << 6,
+    EVDEV_UDEV_TAG_ACCELEROMETER = 1 << 7,
+    EVDEV_UDEV_TAG_TABLET_PAD = 1 << 8,
+    EVDEV_UDEV_TAG_POINTINGSTICK = 1 << 9,
+    EVDEV_UDEV_TAG_TRACKBALL = 1 << 10,
+    EVDEV_UDEV_TAG_SWITCH = 1 << 11,
+	EVDEV_UDEV_TAG_MSDP = 1 << 12,
 };
 
 /**
@@ -321,6 +338,49 @@
 };
 
 /**
+ * @ingroup event_joystick
+ *
+ * The source for a @ref LIBINPUT_EVENT_POINTER_AXIS event. See
+ * libinput_event_get_joystick_axis_event() for details.
+ *
+ * @since 1.16.4
+ */
+enum libinput_joystick_axis_source {
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_UNKNOWN = 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X = 1 << 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y = 1 << 1,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z = 1 << 2,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX = 1 << 3,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY = 1 << 4,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ = 1 << 5,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE = 1 << 6,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RUDDER = 1 << 7,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_WHEEL = 1 << 8,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS = 1 << 9,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE = 1 << 10,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X = 1 << 11,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y = 1 << 12,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1X = 1 << 13,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1Y = 1 << 14,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2X = 1 << 15,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2Y = 1 << 16,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3X = 1 << 17,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3Y = 1 << 18,
+};
+
+#define MAX_SOLTED_COORDS_NUM 10
+struct sloted_coords {
+	int32_t is_active;
+	float x;
+	float y;
+};
+
+struct sloted_coords_info {
+	struct sloted_coords coords[MAX_SOLTED_COORDS_NUM];
+	unsigned int active_count;
+};
+
+/**
  * @ingroup device
  *
  * Available tool types for a device with the @ref
@@ -393,6 +453,17 @@
 	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
 };
 
+struct libinput_event_joystick_axis_abs_info {
+	int32_t code;
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+	float	standardValue;
+};
+
 /**
  * @defgroup tablet_pad_modes Tablet pad modes
  *
@@ -702,6 +773,7 @@
 	 * in tablet mode.
 	 */
 	LIBINPUT_SWITCH_TABLET_MODE,
+	LIBINPUT_SWITCH_PRIVACY,
 };
 
 /**
@@ -822,6 +894,16 @@
 	 */
 	LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
 
+	LIBINPUT_EVENT_POINTER_TAP,
+	LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD,
+	LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD,
+
+	LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN,
+	LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END,
+
+	LIBINPUT_EVENT_JOYSTICK_BUTTON = 450,
+	LIBINPUT_EVENT_JOYSTICK_AXIS,
+
 	LIBINPUT_EVENT_TOUCH_DOWN = 500,
 	LIBINPUT_EVENT_TOUCH_UP,
 	LIBINPUT_EVENT_TOUCH_MOTION,
@@ -832,6 +914,10 @@
 	 */
 	LIBINPUT_EVENT_TOUCH_FRAME,
 
+	LIBINPUT_EVENT_TOUCHPAD_DOWN = 550,
+	LIBINPUT_EVENT_TOUCHPAD_UP,
+	LIBINPUT_EVENT_TOUCHPAD_MOTION,
+
 	/**
 	 * One or more axes have changed state on a device with the @ref
 	 * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. This event is only sent
@@ -984,6 +1070,8 @@
 	 * @since 1.7
 	 */
 	LIBINPUT_EVENT_SWITCH_TOGGLE = 900,
+
+	LIBINPUT_EVENT_MSDP = 1000,
 };
 
 /**
@@ -1084,6 +1172,19 @@
 /**
  * @ingroup event
  *
+ * Return the touchpad event that is this input event. If the event type does
+ * not match the touchpad event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_touchpad_get_base_event().
+ *
+ * @return A touch event, or NULL for other events
+ */
+struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
  * Return the gesture event that is this input event. If the event type does
  * not match the gesture event types, this function returns NULL.
  *
@@ -1466,6 +1567,10 @@
 enum libinput_button_state
 libinput_event_pointer_get_button_state(struct libinput_event_pointer *event);
 
+uint32_t
+libinput_event_pointer_get_button_area(
+	struct libinput_event_pointer *event);
+
 /**
  * @ingroup event_pointer
  *
@@ -1486,6 +1591,21 @@
 /**
  * @ingroup event_pointer
  *
+ * For the button of a @ref LIBINPUT_EVENT_POINTER_BUTTON event, return the
+ * total number of fingers on touchpad.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_BUTTON. For other events, this function
+ * returns 0.
+ *
+ * @return The finger counts for touchpad button event
+ */
+uint32_t
+libinput_event_pointer_get_finger_count(
+	struct libinput_event_pointer *event);
+/**
+ * @ingroup event_pointer
+ *
  * Check if the event has a valid value for the given axis.
  *
  * If this function returns non-zero for an axis and
@@ -1787,6 +1907,9 @@
 int32_t
 libinput_event_touch_get_seat_slot(struct libinput_event_touch *event);
 
+int32_t
+libinput_event_touch_get_orientation(struct libinput_event_touch *event);
+
 /**
  * @ingroup event_touch
  *
@@ -1870,6 +1993,120 @@
 				       uint32_t height);
 
 /**
+ * @brief 获取触摸屏的工具类型区域属性
+ */
+int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_x_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return The current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_y_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return The current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area. To get the corresponding output
+ * screen width, use
+ * libinput_event_touch_get_tool_width_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current width
+ */
+double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area, converted to screen width.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return Convert current width to screen width
+ */
+double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area. To get the corresponding output
+ * screen height, use
+ * libinput_event_touch_get_tool_height_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current height
+ */
+double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area, converted to screen height.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return Convert current height to screen height
+ */
+double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
  * @ingroup event_touch
  *
  * @return The generic libinput_event of this event
@@ -1878,6 +2115,228 @@
 libinput_event_touch_get_base_event(struct libinput_event_touch *event);
 
 /**
+ * @defgroup event_touch Touchpad events
+ *
+ * Events from absolute touchpad devices.
+ */
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the slot of this touchpad event. See the kernel's multitouch
+ * protocol B documentation for more information.
+ *
+ * If the touchpad event has no assigned slot, for example if it is from a
+ * single touchpad device, this function returns -1.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The slot of this touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the seat slot of the touchpad event. A seat slot is a non-negative seat
+ * wide unique identifier of an active touchpad point.
+ *
+ * Events from single touchpad devices will be represented as one individual
+ * touchpad point per device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The seat slot of the touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute x coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute y coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the pressure of the touch pad
+ *
+ * @param event The libinput touch event
+ * @return Touchpad pressure value
+ *
+ */
+double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The long axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The short axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板的工具类型区域属性
+ */
+int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板工具类型按钮是否按下
+ */
+int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
+ * @ingroup event_touch
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the X coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The X coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the Y coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The Y coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the width of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The width of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the height of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The height of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event);
+
+/**
  * @defgroup event_gesture Gesture events
  *
  * Gesture events are generated when a gesture is recognized on a touchpad.
@@ -2090,6 +2549,49 @@
 libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);
 
 /**
+ * 获取gesture中手指的坐标信息, idx表示手指的索引
+ */
+int
+libinput_event_gesture_get_device_coords_x(struct libinput_event_gesture *event, uint32_t idx);
+int
+libinput_event_gesture_get_device_coords_y(struct libinput_event_gesture *event, uint32_t idx);
+/**
+ * 获取带slot的touches信息, 仅支持LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE
+ */
+struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(struct libinput_event_gesture *event);
+
+/**
+ * @brief Obtain the device values the EV_LED event type
+ *
+ * @param device  A current input device
+ * @return int Obtained is Supported
+ */
+int libinput_has_event_led_type(struct libinput_device *device);
+
+/**
+ * @brief Obtain the function key enablement status of a keyboard device
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @return int Obtained state
+ */
+int libinput_get_funckey_state(struct libinput_device *device, unsigned int code);
+
+/**
+ * @brief Turn an LED on or off. Convenience function, if you need to modify multiple
+ * LEDs simultaneously, use libinput_set_led_state() instead.
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @param state value Specifies whether to turn the LED on or off
+ * @return int 0 on success, or a negative errno on failure
+ */
+int libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state);
+
+/**
  * @defgroup event_tablet Tablet events
  *
  * Events that come from tools on tablet devices. For events from the pad,
@@ -2590,6 +3092,18 @@
 libinput_event_tablet_tool_get_size_minor(struct libinput_event_tablet_tool *event);
 
 /**
+ * @ingroup config
+ *
+ * Get the current side rotation angle of the stylus.
+ *
+ * @param tool The libinput tool
+ * @return angle value of the stylus
+ *
+ */
+int32_t
+libinput_event_tablet_tool_get_angle(struct libinput_event_tablet_tool *event);
+
+/**
  * @ingroup event_tablet
  *
  * Return the delta for the wheel in degrees.
@@ -2817,6 +3331,19 @@
 /**
  * @ingroup event_tablet
  *
+ * Get the stylus event type reported from evdev_tablet
+ *
+ * @param event The libinput tablet tool event
+ * @return Tool type for stylus events
+ *
+ * @since 1.2
+ */
+int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
  * Return the high-level tool type for a tool object.
  *
  * The high level tool describes general interaction expected with the tool.
@@ -3663,6 +4190,56 @@
 int
 libinput_dispatch(struct libinput *libinput);
 
+/****************************************************************************
+* @brief : brief
+* @author : fms
+* @date : 2021/3/8 20:55
+* @version : ver 1.0
+* @inparam :libinput  event
+* @outparam :
+*****************************************************************************/
+void
+libinput_post_handle_event(struct libinput* libinput,
+	struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick button event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_button_event(struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick axis event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_axis*
+    libinput_event_get_joystick_axis_event(struct libinput_event* event);
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event);
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
 /**
  * @ingroup base
  *
@@ -3866,6 +4443,30 @@
 			 libinput_log_handler log_handler);
 
 /**
+ * @ingroup base
+ *
+ * Toggle the status of virtual keyboard caps key.
+ */
+void
+libinput_toggle_caps_key();
+
+void
+libinput_set_touch_event_type(struct libinput_event_touch* event_touch, enum libinput_event_type eventType);
+
+/**
+ * @ingroup base
+ *
+ * Create a keyboard event and store the function key status in user data.
+ * The new created event refers to the touch screen device.
+ * @param event_touch The touch event
+ * @param key key code
+ * @param state key state, pressed or released
+ * @return The keyboard event
+ */
+struct libinput_event_keyboard*
+libinput_create_keyboard_event(struct libinput_event_touch* event_touch, int32_t key, enum libinput_key_state state);
+
+/**
  * @defgroup seat Initialization and manipulation of seats
  *
  * A seat has two identifiers, the physical name and the logical name. A
@@ -4133,6 +4734,42 @@
 const char *
 libinput_device_get_name(struct libinput_device *device);
 
+/**  @brief   获取设备类型*/
+enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device);
+
+/**  @brief   设备按键能力查询*/
+int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode);
+
+/**  @brief   获取设备特定轴的最小值*/
+int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的最大值*/
+int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的fuzz值*/
+int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的flat值*/
+int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的resolution值*/
+int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备的bustype值*/
+unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device);
+
+/**  @brief   获取设备的version值*/
+unsigned int
+libinput_device_get_id_version(struct libinput_device* device);
+
 /**
  * @ingroup device
  *
@@ -4343,6 +4980,12 @@
 libinput_device_touch_get_touch_count(struct libinput_device *device);
 
 /**
+ * @brief 获取触摸屏工具类型按钮是否按下
+ */
+int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
  * @ingroup device
  *
  * Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
@@ -5722,6 +6365,9 @@
 enum libinput_config_click_method
 libinput_device_config_click_get_default_method(struct libinput_device *device);
 
+uint64_t
+libinput_event_get_sensortime(struct libinput_event *event);
+
 /**
  * @ingroup config
  */
@@ -6398,7 +7044,168 @@
 unsigned int
 libinput_device_config_rotation_get_default_angle(struct libinput_device *device);
 
+/**
+ * @ingroup event
+ *
+ * Get the struct libinput_event_joystick_button from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput_event_joystick_button for this event.
+ */
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the time from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The time for this event.
+ */
+uint64_t libinput_event_joystick_button_time(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the key value from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The key value for this event.
+ */
+uint32_t libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the seat key count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The seat key count for this event.
+ */
+uint32_t libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the value count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The value for this event.
+ */
+int libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the pressure of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Pressure value of touch screen
+ *
+ * @since 1.4
+ */
+double
+libinput_event_touch_get_pressure(struct libinput_event_touch* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the move_flag of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Move_flag value of touch screen
+ *
+ * @since 1.4
+ */
+int32_t
+libinput_event_touch_get_move_flag(struct libinput_event_touch* event);
+
+int32_t
+libinput_event_get_hand_feature(struct libinput_event *event);
+
+/**
+ * @ingroup config
+ *
+ * Get the blob_id of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Blob_id value of touch screen
+ *
+ * @since 1.4
+ */
+int32_t
+libinput_event_touch_get_blob_id(struct libinput_event_touch* event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Long axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Short axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+const char*
+libinput_device_get_phys(struct libinput_device* device);
+
+const char*
+libinput_device_get_uniq(struct libinput_device* device);
+
+enum libinput_button_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Enable to config the right button area on the click-touchpad without
+ * physic buttons. Once the configuration is changed, the right button
+ * area will take effect at next sync report. See the libinput documentation
+ * for details.
+ *
+ * @note Configuration changes may not take effect immediately. The
+ * configuration fails to take effect if touchpad is not click-touchpad,
+ * with physical button or middle button. Other scenarios, such as touchpad
+ * with Apple quirks, also cause the configuration fails to take effect.
+ *
+ * @param libinput A libinput context initialized with
+ * libinput_udev_create_context()
+ * @param height_percent The height percent to config.
+ * @param width_percent The width percent to config.
+ *
+ * @return A config status code. If the param is valid the feature always
+ * succeeds.
+ */
+enum libinput_config_status
+libinput_config_rightbutton_area(struct libinput *libinput,
+                const int32_t height_percent, const int32_t width_percent);
+
+void
+libinput_touchpad_event_clear(struct libinput_device *device);
+
+int32_t
+libinput_touchpad_device_get_frequency(struct libinput_device *device);
+
+double
+libinput_touchpad_device_get_ppi(struct libinput_device *device);
+
+double
+libinput_touchpad_device_get_hypot_size(struct libinput_device *device);
 #ifdef __cplusplus
 }
 #endif
 #endif /* LIBINPUT_H */
+
diff -Naur old/hm_src/hm_missing.c new/hm_src/hm_missing.c
--- old/hm_src/hm_missing.c	1970-01-01 08:00:00.000000000 +0800
+++ new/hm_src/hm_missing.c	2025-03-26 11:16:26.426458791 +0800
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hm_missing.h"
+
+extern char *__progname;
+char *ohos_program_invocation_short_name()
+{
+    return __progname;
+}
\ No newline at end of file
diff -Naur old/hm_src/hm_missing.h new/hm_src/hm_missing.h
--- old/hm_src/hm_missing.h	1970-01-01 08:00:00.000000000 +0800
+++ new/hm_src/hm_missing.h	2025-03-26 11:16:26.426458791 +0800
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_LIBINPUT_HM_MISSING_H
+#define OHOS_LIBINPUT_HM_MISSING_H
+
+/* The full and simple forms of the name with which the program was
+   invoked.  These variables are set up automatically at startup based on
+   the value of argv[0].  */
+extern char *ohos_program_invocation_short_name();
+#define program_invocation_short_name ohos_program_invocation_short_name()
+
+#endif
diff -Naur old/include/config.h new/include/config.h
--- old/include/config.h	2025-03-26 11:12:53.941121821 +0800
+++ new/include/config.h	2025-03-26 11:16:26.426458791 +0800
@@ -35,11 +35,11 @@
 
 #define HTTP_DOC_LINK "https://wayland.freedesktop.org/libinput/doc/1.25.0"
 
-#define LIBINPUT_QUIRKS_DIR "/etc/libinput/quirks"
+#define LIBINPUT_QUIRKS_DIR "/sys_prod/etc/libinput/quirks"
 
-#define LIBINPUT_QUIRKS_OVERRIDE_FILE "/etc/libinput/quirks/local-overrides.quirks"
+#define LIBINPUT_QUIRKS_OVERRIDE_FILE "/sys_prod/etc/libinput/quirks/local-overrides.quirks"
 
-#define LIBINPUT_QUIRKS_SRCDIR "/etc/libinput/quirks"
+#define LIBINPUT_QUIRKS_SRCDIR "/sys_prod/etc/libinput/quirks"
 
 #define LIBINPUT_TOOL_PATH "/data/libinput"
 
diff -Naur old/include/linux/freebsd/input-event-codes.h new/include/linux/freebsd/input-event-codes.h
--- old/include/linux/freebsd/input-event-codes.h	2025-03-26 11:12:53.941121821 +0800
+++ new/include/linux/freebsd/input-event-codes.h	2025-03-26 11:16:26.426458791 +0800
@@ -335,7 +335,7 @@
 #define KEY_WIMAX		KEY_WWAN
 #define KEY_RFKILL		247	/* Key that controls all radios */
 
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
+#define KEY_MICMUTE		251	/* Mute / unmute the microphone */
 
 /* Code 255 is reserved for special needs of AT keyboard driver */
 
@@ -834,8 +834,10 @@
 #define ABS_TOOL_WIDTH		0x1c
 
 #define ABS_VOLUME		0x20
-
+#define ABS_HAND_FEATURE 0x21
 #define ABS_MISC		0x28
+#define ABS_MT_MOVEFLAG	0x29
+#define ABS_MT_ANGLE	0x2c
 
 /*
  * 0x2e is reserved and should not be used in input drivers.
@@ -889,7 +891,8 @@
 #define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
 #define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
 #define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_MAX			0x10
+#define SW_SUPER_PRIVACY	0x11  /* set = super privacy open */
+#define SW_MAX			    0x11
 #define SW_CNT			(SW_MAX+1)
 
 /*
diff -Naur old/include/linux/linux/input-event-codes.h new/include/linux/linux/input-event-codes.h
--- old/include/linux/linux/input-event-codes.h	2025-03-26 11:12:53.941121821 +0800
+++ new/include/linux/linux/input-event-codes.h	2025-03-26 11:16:26.426458791 +0800
@@ -335,7 +335,7 @@
 #define KEY_WIMAX		KEY_WWAN
 #define KEY_RFKILL		247	/* Key that controls all radios */
 
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
+#define KEY_MICMUTE		251	/* Mute / unmute the microphone */
 
 /* Code 255 is reserved for special needs of AT keyboard driver */
 
@@ -834,8 +834,10 @@
 #define ABS_TOOL_WIDTH		0x1c
 
 #define ABS_VOLUME		0x20
-
+#define ABS_HAND_FEATURE 0x21
 #define ABS_MISC		0x28
+#define ABS_MT_MOVEFLAG	0x29
+#define ABS_MT_ANGLE	0x2c
 
 /*
  * 0x2e is reserved and should not be used in input drivers.
@@ -889,7 +891,8 @@
 #define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
 #define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
 #define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_MAX			0x10
+#define SW_SUPER_PRIVACY	0x11  /* set = super privacy open */
+#define SW_MAX			    0x11
 #define SW_CNT			(SW_MAX+1)
 
 /*
diff -Naur old/patch/diff_libinput_mmi/libinput/libinput_0000.diff new/patch/diff_libinput_mmi/libinput/libinput_0000.diff
--- old/patch/diff_libinput_mmi/libinput/libinput_0000.diff	2025-03-26 11:12:53.945121848 +0800
+++ new/patch/diff_libinput_mmi/libinput/libinput_0000.diff	2025-03-26 11:17:18.170762760 +0800
@@ -1450,6 +1450,11 @@
 +	const uint16_t DAGGER_CLICK = 0x2f9;
 +	const uint16_t DAGGER_LONG_PRESS = 0x2fa;
 +	const uint16_t AOD_SLIDE = 0x2fb;
+	const uint16_t KEY_PEN_AIR_MOUSE = 0x2f0;
+	const uint16_t KEY_PEN_LIGHT_PINCH = 0x2f1;
+	const uint16_t KEY_PEN_AI = 0x2f2;
+	const uint16_t KEY_PEN_END_CLICK = 0x2f3;
+	const uint16_t KEY_PEN_END_DOUBLE_CLICK = 0x2f4;
  	switch (code) {
  	case BTN_TOOL_PEN:
  	case BTN_TOOL_RUBBER:
@@ -1459,7 +1464,9 @@
  		return KEY_TYPE_BUTTON;
 +	if (code == KEY_ENDCALL || code == KEY_FUNCTION)
 +		return KEY_TYPE_KEY;
-+	if (code == DAGGER_PRESS || code == DAGGER_CLICK || code == DAGGER_LONG_PRESS)
++	if (code == DAGGER_PRESS || code == DAGGER_CLICK || code == DAGGER_LONG_PRESS
+	|| code == KEY_PEN_AIR_MOUSE || code == KEY_PEN_LIGHT_PINCH || code == KEY_PEN_AI 
+	|| code == KEY_PEN_END_CLICK || code == KEY_PEN_END_DOUBLE_CLICK)
 +		return KEY_TYPE_KEY;
 +	if (code == AOD_SLIDE)
 +		return KEY_TYPE_KEY;
diff -Naur old/src/evdev-fallback.c new/src/evdev-fallback.c
--- old/src/evdev-fallback.c	2025-03-26 11:12:53.945121848 +0800
+++ new/src/evdev-fallback.c	2025-03-26 11:16:26.426458791 +0800
@@ -229,8 +229,11 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	struct device_coords point;
+	struct device_coord_rect rect;
 	struct mt_slot *slot;
 	int seat_slot;
+	struct touch_axis axis;
+	int tool_type;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -253,8 +256,12 @@
 	slot->hysteresis_center = point;
 	evdev_transform_absolute(device, &point);
 
-	touch_notify_touch_down(base, time, slot_idx, seat_slot,
-				&point);
+	tool_type = slot->tool_type;
+	axis = slot->axis;
+	rect = slot->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touch_notify_touch_down(base, time, slot_idx, seat_slot, slot->pressure, &slot->extraData,
+				&axis, &point, tool_type, &rect);
 
 	return true;
 }
@@ -267,8 +274,11 @@
 {
 	struct libinput_device *base = &device->base;
 	struct device_coords point;
+	struct device_coord_rect rect;
 	struct mt_slot *slot;
 	int seat_slot;
+	struct touch_axis axis;
+	int tool_type;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -276,6 +286,7 @@
 	slot = &dispatch->mt.slots[slot_idx];
 	seat_slot = slot->seat_slot;
 	point = slot->point;
+    axis = slot->axis;
 
 	if (seat_slot == -1)
 		return false;
@@ -284,8 +295,12 @@
 		return false;
 
 	evdev_transform_absolute(device, &point);
-	touch_notify_touch_motion(base, time, slot_idx, seat_slot,
-				  &point);
+
+	tool_type = slot->tool_type;
+	rect = slot->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touch_notify_touch_motion(base, time, slot_idx, seat_slot, slot->pressure, &slot->extraData,
+				  &axis, &point, tool_type, &rect);
 
 	return true;
 }
@@ -300,6 +315,7 @@
 	struct libinput_seat *seat = base->seat;
 	struct mt_slot *slot;
 	int seat_slot;
+	int tool_type;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -313,7 +329,9 @@
 
 	seat->slot_map &= ~bit(seat_slot);
 
-	touch_notify_touch_up(base, time, slot_idx, seat_slot);
+	tool_type = slot->tool_type;
+
+	touch_notify_touch_up(base, time, slot_idx, seat_slot, tool_type);
 
 	return true;
 }
@@ -354,7 +372,12 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	struct device_coords point;
+	const struct device_coord_rect rect = { 0 };
+	const struct touch_axis axis = { 0 };
+	const struct extra_data data = { 0, -1 };
 	int seat_slot;
+	int tool_type;
+	int32_t pressure = dispatch->abs.pressure;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -376,7 +399,9 @@
 	point = dispatch->abs.point;
 	evdev_transform_absolute(device, &point);
 
-	touch_notify_touch_down(base, time, -1, seat_slot, &point);
+	tool_type = -1;
+
+	touch_notify_touch_down(base, time, -1, seat_slot, pressure, &data, &axis, &point, tool_type, &rect);
 
 	return true;
 }
@@ -388,7 +413,12 @@
 {
 	struct libinput_device *base = &device->base;
 	struct device_coords point;
+	const struct device_coord_rect rect = {0};
+	const struct touch_axis axis = { 0 };
+	const struct extra_data data = { 0, -1 };
 	int seat_slot;
+	int tool_type;
+	int32_t pressure = dispatch->abs.pressure;
 
 	point = dispatch->abs.point;
 	evdev_transform_absolute(device, &point);
@@ -398,11 +428,22 @@
 	if (seat_slot == -1)
 		return false;
 
-	touch_notify_touch_motion(base, time, -1, seat_slot, &point);
+	tool_type = -1;
+
+	touch_notify_touch_motion(base, time, -1, seat_slot, pressure, &data, &axis, &point, tool_type, &rect);
 
 	return true;
 }
 
+static void
+fallback_flush_msdp_motion(struct fallback_dispatch *dispatch,
+			 struct evdev_device *device,
+			 uint64_t time)
+{
+	struct libinput_device *base = &device->base;
+	touch_notify_msdp(base, time);
+}
+
 static bool
 fallback_flush_st_up(struct fallback_dispatch *dispatch,
 		     struct evdev_device *device,
@@ -411,6 +452,7 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	int seat_slot;
+	int tool_type;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -423,7 +465,9 @@
 
 	seat->slot_map &= ~bit(seat_slot);
 
-	touch_notify_touch_up(base, time, -1, seat_slot);
+	tool_type = -1;
+
+	touch_notify_touch_up(base, time, -1, seat_slot, tool_type);
 
 	return true;
 }
@@ -469,6 +513,9 @@
 		     struct input_event *e, uint64_t time)
 {
 	enum key_type type;
+  if (e->code == KEY_POWER) {
+     evdev_log_libinput_info(dispatch->device, "Power has been reported:%d", e->value);
+  }
 
 	/* ignore kernel key repeat */
 	if (e->value == 2)
@@ -528,6 +575,14 @@
 {
 	struct mt_slot *slot = &dispatch->mt.slots[dispatch->mt.slot];
 
+	if (e->code == 0x2a) {
+		dispatch->device->sensor_timestamp.seconds = e->value;
+		return;
+	}
+	if (e->code == 0x2b) {
+		dispatch->device->sensor_timestamp.microseconds = e->value;
+		return;
+	}
 	if (e->code == ABS_MT_SLOT) {
 		if ((size_t)e->value >= dispatch->mt.slots_len) {
 			evdev_log_bug_libinput(device,
@@ -541,6 +596,16 @@
 	}
 
 	switch (e->code) {
+	case ABS_MT_BLOB_ID:
+		slot->extraData.blob_id = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_MOVEFLAG:
+        slot->extraData.move_flag = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
 	case ABS_MT_TRACKING_ID:
 		if (e->value >= 0) {
 			dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
@@ -598,8 +663,49 @@
 			break;
 		}
 		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->tool_type = e->value;
 		slot->dirty = true;
 		break;
+	case ABS_MT_PRESSURE:
+        slot->pressure = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOUCH_MAJOR:
+        slot->axis.major = e->value;
+        dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+        slot->dirty = true;
+		break;
+    case ABS_MT_TOUCH_MINOR:
+        slot->axis.minor = e->value;
+        dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+        slot->dirty = true;
+        break;
+	case ABS_MT_WIDTH_MAJOR:
+		slot->tool_rect.w = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_WIDTH_MINOR:
+		slot->tool_rect.h = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOOL_X:
+		slot->tool_rect.x = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOOL_Y:
+		slot->tool_rect.y = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+  case ABS_MT_ORIENTATION:
+    slot->extraData.orientation = e->value;
+    dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+    slot->dirty = true;
+    break;
 	}
 }
 
@@ -608,6 +714,11 @@
 				 struct evdev_device *device,
 				 struct input_event *e)
 {
+	if (e->code == 0x21) {
+		dispatch->device->hand_status.hand_feature = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MOTION;
+		return;
+	}
 	switch (e->code) {
 	case ABS_X:
 		evdev_device_check_abs_axis_range(device, e->code, e->value);
@@ -619,6 +730,10 @@
 		dispatch->abs.point.y = e->value;
 		dispatch->pending_event |= EVDEV_ABSOLUTE_MOTION;
 		break;
+	case ABS_PRESSURE:
+		dispatch->abs.pressure = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MOTION;
+		break;
 	}
 }
 
@@ -920,6 +1035,10 @@
 			fallback_flush_absolute_motion(dispatch,
 						       device,
 						       time);
+		} else if (device->seat_caps & EVDEV_DEVICE_MSDP) {
+			fallback_flush_msdp_motion(dispatch,
+						       device,
+						       time);
 		}
 	}
 
@@ -1556,6 +1675,8 @@
 
 	for (slot = 0; slot < num_slots; ++slot) {
 		slots[slot].seat_slot = -1;
+		slots[slot].tool_type = -1;
+		slots[slot].extraData.move_flag = -1;
 
 		if (evdev_need_mtdev(device))
 			continue;
@@ -1718,3 +1839,11 @@
 
 	return &dispatch->base;
 }
+
+bool
+evdev_device_touch_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType)
+{
+	struct fallback_dispatch *dispatch = fallback_dispatch(device->dispatch);
+
+	return hw_is_key_down(dispatch, btnToolType);
+}
diff -Naur old/src/evdev-fallback.h new/src/evdev-fallback.h
--- old/src/evdev-fallback.h	2025-03-26 11:12:53.945121848 +0800
+++ new/src/evdev-fallback.h	2025-03-26 11:16:26.426458791 +0800
@@ -75,11 +75,16 @@
 
 struct mt_slot {
 	bool dirty;
+	struct extra_data extraData;
 	enum mt_slot_state state;
 	int32_t seat_slot;
 	struct device_coords point;
 	struct device_coords hysteresis_center;
 	enum palm_state palm_state;
+	struct device_coord_rect tool_rect;
+	int32_t pressure;
+	struct touch_axis axis;
+	int32_t tool_type;
 };
 
 struct fallback_dispatch {
@@ -97,6 +102,7 @@
 	struct {
 		struct device_coords point;
 		int32_t seat_slot;
+		int32_t pressure;
 	} abs;
 
 	struct {
@@ -191,6 +197,12 @@
 static inline enum key_type
 get_key_type(uint16_t code)
 {
+	const uint16_t KEY_ENDCALL = 0x2e8;
+	const uint16_t KEY_FUNCTION = 0x2fe;
+	const uint16_t DAGGER_PRESS = 0x2f8;
+	const uint16_t DAGGER_CLICK = 0x2f9;
+	const uint16_t DAGGER_LONG_PRESS = 0x2fa;
+	const uint16_t AOD_SLIDE = 0x2fb;
 	switch (code) {
 	case BTN_TOOL_PEN:
 	case BTN_TOOL_RUBBER:
@@ -220,6 +232,12 @@
 		return KEY_TYPE_KEY;
 	if (code >= BTN_TRIGGER_HAPPY && code <= BTN_TRIGGER_HAPPY40)
 		return KEY_TYPE_BUTTON;
+	if (code == KEY_ENDCALL || code == KEY_FUNCTION)
+		return KEY_TYPE_KEY;
+	if (code == DAGGER_PRESS || code == DAGGER_CLICK || code == DAGGER_LONG_PRESS)
+		return KEY_TYPE_KEY;
+	if (code == AOD_SLIDE)
+		return KEY_TYPE_KEY;
 	return KEY_TYPE_NONE;
 }
 
diff -Naur old/src/evdev-joystick.c new/src/evdev-joystick.c
--- old/src/evdev-joystick.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-joystick.c	2025-03-26 11:16:26.426458791 +0800
@@ -0,0 +1,590 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <string.h>
+
+#include "config.h"
+#include "libinput-version.h"
+#include "evdev-joystick.h"
+#include "libinput.h"
+#include "libinput-util.h"
+
+static inline struct
+joystick_dispatch* get_joystick_dispatch(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return NULL;
+    }
+    evdev_verify_dispatch_type(dispatch, DISPATCH_JOYSTICK);
+
+    struct joystick_dispatch* joystick_dispatch = NULL;
+    joystick_dispatch = container_of(dispatch, struct joystick_dispatch, base);
+
+    return joystick_dispatch;
+}
+
+static int
+update_seat_joystick_button_count(struct libinput_seat* seat, int32_t key, uint32_t *seat_count, enum libinput_button_state state)
+{
+    if (seat == NULL || seat_count == NULL || key < SYN_REPORT || key > KEY_MAX) {
+        return false;
+    }
+
+    switch (state) {
+        case LIBINPUT_BUTTON_STATE_PRESSED:
+        {
+            *(seat_count) = ++seat->button_count[key];
+            break;
+        }
+        case LIBINPUT_BUTTON_STATE_RELEASED:
+        {
+            if (seat->button_count[key] == 0)
+            {
+                *(seat_count) = seat->button_count[key];
+            }
+            else
+            {
+                *(seat_count) = --seat->button_count[key];
+            }
+            break;
+        }
+        default:
+        {
+            *(seat_count) = 0;
+            break;
+        }
+    }
+    return true;
+}
+
+static void
+joystick_notify_axis(struct evdev_device* device, uint64_t time)
+{
+    if (device == NULL) {
+        return;
+    }
+
+	struct joystick_dispatch *joystick_dispatch = get_joystick_dispatch(device->dispatch);
+	if (joystick_dispatch == NULL) {
+        libinput_log_printf("joystick_dispatch is NULL.\n");
+		return;
+	}
+
+    struct libinput_event_joystick_axis* joystick_axis_event = zalloc(sizeof * joystick_axis_event);
+    if (joystick_axis_event == NULL) {
+        libinput_log_printf("pJoystickEvent is NULL.\n");
+        return;
+    }
+
+    *joystick_axis_event = (struct libinput_event_joystick_axis) {
+	    .base.type = LIBINPUT_EVENT_POINTER_AXIS,
+	    .base.device = &device->base,
+        .type = EV_ABS,
+        .time = time,
+        .axis_value_mask = joystick_dispatch->axis_value_mask,
+	    .abs_throttle = joystick_dispatch->axis_abs_infos.abs_throttle,
+	    .abs_hat0x = joystick_dispatch->axis_abs_infos.abs_hat0x,
+	    .abs_hat0y = joystick_dispatch->axis_abs_infos.abs_hat0y,
+	    .abs_x = joystick_dispatch->axis_abs_infos.abs_x,
+		.abs_y = joystick_dispatch->axis_abs_infos.abs_y,
+		.abs_z = joystick_dispatch->axis_abs_infos.abs_z,
+		.abs_rx = joystick_dispatch->axis_abs_infos.abs_rx,
+		.abs_ry = joystick_dispatch->axis_abs_infos.abs_ry,
+		.abs_rz = joystick_dispatch->axis_abs_infos.abs_rz,
+    };
+
+    struct libinput_event_listener* listener = NULL;
+    list_for_each_safe(listener, &device->base.event_listeners, link) {
+        listener->notify_func(time, &joystick_axis_event->base, listener->notify_func_data);
+    }
+
+    libinput_post_handle_event(device->base.seat->libinput, &joystick_axis_event->base);
+}
+
+static void
+joystick_notify_key_event(struct evdev_device* device, struct input_event* event, uint64_t time)
+{
+    if (device == NULL || event == NULL) {
+        return;
+    }
+
+    struct libinput_event_joystick_button* button_event = {0};
+    uint32_t seat_count = 0;
+
+    int ret = update_seat_joystick_button_count(device->base.seat, event->code, &seat_count, event->value);
+    if (ret == 0) {
+        return;
+    }
+
+    button_event = zalloc(sizeof * button_event);
+    if (button_event == NULL) {
+        return;
+    }
+
+	*button_event = (struct libinput_event_joystick_button) {
+			.base.type = LIBINPUT_EVENT_JOYSTICK_BUTTON,
+			.base.device = &device->base,
+            .time = time,
+            .type = event->type,
+            .key = event->code,
+            .value = event->value,
+            .seat_key_count = seat_count,
+            .state = event->value,
+    };
+
+    struct libinput_event_listener* listener = NULL;
+    list_for_each_safe(listener, &device->base.event_listeners, link)
+    {
+        listener->notify_func(time, &button_event->base, listener->notify_func_data);
+    }
+
+    libinput_post_handle_event(device->base.seat->libinput, &button_event->base);
+}
+
+static float
+abs_value_standardize(int32_t value, int32_t minimum, int32_t maximum, float standard_min, float standard_max)
+{
+    return standard_min + ((float)value - (float)minimum) * ((float)(standard_max - standard_min)) / ((float)(maximum - minimum));
+}
+
+static float
+get_joystick_abs_standard_value(struct libinput_event_joystick_axis_abs_info *absinfo)
+{
+    const int32_t value = absinfo->value;
+    const int32_t minimum = absinfo->minimum;
+    const int32_t maximum = absinfo->maximum;
+    if (minimum >= maximum) {
+		libinput_log_printf("joystick abs: minimum(%u) >= maximum(%u).\n", minimum, maximum);
+        return 0.f;
+    } else if (value < minimum || value > maximum) {
+		libinput_log_printf("joystick abs: value(%d) not between minimum(%u) and maximum(%u).\n", value, minimum, maximum);
+		return 0.f;
+    }
+
+    const int32_t code = absinfo->code;
+    switch (code) {
+	case ABS_THROTTLE:
+	{
+		return abs_value_standardize(value, minimum, maximum, 0, 1.0);
+	}
+	case ABS_X:
+	case ABS_Y:
+	case ABS_Z:
+	case ABS_RX:
+	case ABS_RY:
+	case ABS_RZ:
+    {
+        return abs_value_standardize(value, minimum, maximum, -1.0, 1.0);
+	}
+    case ABS_HAT0X:
+    case ABS_HAT0Y:
+    {
+        return (float)value;
+    }
+    default:
+    return (float)value;
+    }
+}
+
+static void joystick_set_axis_value_mask(struct joystick_dispatch *joystick_dispatch, enum libinput_joystick_axis_source axis)
+{
+    joystick_dispatch->axis_value_mask |= (uint32_t)axis;
+}
+
+static void joystick_reset_axis_value_mask(struct joystick_dispatch *joystick_dispatch)
+{
+	joystick_dispatch->axis_value_mask = 0;
+}
+
+static bool joystick_is_axis_value_mask(struct joystick_dispatch *joystick_dispatch)
+{
+	return (joystick_dispatch->axis_value_mask != 0);
+}
+
+static void joystick_get_one_abs_info(struct joystick_dispatch *joystick_dispatch, struct evdev_device *device, struct input_event *event,
+    const uint32_t code)
+{
+    struct libinput_event_joystick_axis_abs_info *absinfo = NULL;
+    switch (code) {
+    case ABS_THROTTLE:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_throttle;
+    break;
+    case ABS_HAT0X:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_hat0x;
+    break;
+    case ABS_HAT0Y:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_hat0y;
+    break;
+    case ABS_X:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_x;
+    break;
+    case ABS_Y:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_y;
+    break;
+	case ABS_Z:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z);
+	absinfo = &joystick_dispatch->axis_abs_infos.abs_z;
+    break;
+	case ABS_RX:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX);
+	absinfo = &joystick_dispatch->axis_abs_infos.abs_rx;
+	break;
+	case ABS_RY:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY);
+	absinfo = &joystick_dispatch->axis_abs_infos.abs_ry;
+	break;
+    case ABS_RZ:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_rz;
+    break;
+    case ABS_GAS:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_gas;
+    break;
+    case ABS_BRAKE:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_brake;
+    break;
+    default:
+    break;
+    }
+
+    if (absinfo == NULL) {
+        libinput_log_printf("unsupported joystick abs event: device_name:%s code:%d value:%d.\n",
+            device->devname, code, event->value);
+        return;
+    }
+
+    struct libevdev *evdev = device->evdev;
+    evdev_device_check_abs_axis_range(device, event->code, event->value);
+    const struct input_absinfo *absinfo_raw = libevdev_get_abs_info(evdev, event->code);
+    absinfo->code = event->code;
+    absinfo->value = event->value;
+    absinfo->minimum = absinfo_raw->minimum;
+    absinfo->maximum = absinfo_raw->maximum;
+    absinfo->fuzz = absinfo_raw->fuzz;
+    absinfo->flat = absinfo_raw->flat;
+    absinfo->resolution = absinfo_raw->resolution;
+    absinfo->standardValue = get_joystick_abs_standard_value(absinfo);
+}
+
+static void
+joystick_notify_absolute_event(struct joystick_dispatch* pJoystick,
+    struct evdev_device* device, struct input_event* event, uint64_t time)
+{
+    if (pJoystick == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    joystick_get_one_abs_info(pJoystick, device, event, event->code);
+}
+
+static void
+joystick_flush(struct joystick_dispatch* joystick_dispatch, struct evdev_device* device, uint64_t time)
+{
+    if (joystick_dispatch == NULL || device == NULL) {
+        return;
+    }
+
+    if (joystick_dispatch->axis_value_mask != 0) {
+        joysticks_notify_axis(&device->base, time, joystick_dispatch->axis_value_mask, 
+            &joystick_dispatch->axis_abs_infos);
+        joystick_reset_axis_value_mask(joystick_dispatch);
+    }
+}
+
+static void
+joystick_process(struct evdev_dispatch* dispatch, struct evdev_device* device,
+    struct input_event* event, uint64_t time)
+{
+    if (dispatch == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    switch (event->type) {
+    case EV_ABS: {
+        joystick_notify_absolute_event(joystick_dispatch, device, event, time);
+    }
+    break;
+    case EV_KEY: {
+        joystick_notify_key_event(device, event, time);
+    }
+    break;
+    case EV_SYN: {
+        joystick_flush(joystick_dispatch, device, time);
+    }
+    break;
+    case EV_MSC:
+    /* ignore do not process */
+    break;
+    case EV_REL:
+    case EV_SW:
+    case EV_LED:
+    case EV_SND:
+    case EV_REP:
+    case EV_FF:
+    case EV_PWR:
+    case EV_FF_STATUS:
+    case EV_MAX:
+    case EV_CNT:
+    default:
+        libinput_log_printf("unsupported joystick event type: %d, devname: %s.\n", event->type, device->devname);
+    break;
+    }
+}
+
+static void joystick_suspend(struct evdev_dispatch* dispatch, struct evdev_device* device)
+{
+    if (dispatch == NULL || device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+   joystick_flush(joystick_dispatch, device, 0);
+}
+
+static void
+joystick_destroy(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (dispatch == NULL) {
+        return;
+    }
+
+    free(joystick_dispatch);
+}
+
+static void
+joystick_device_added(struct evdev_device* device,
+    struct evdev_device* added_device)
+{
+    if (device == NULL || added_device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(device->dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    bool is_joystick = false;
+    if (libinput_device_get_device_group(&device->base) !=
+        libinput_device_get_device_group(&added_device->base)) {
+        return;
+    }
+    is_joystick = evdev_device_has_capability(added_device,
+        LIBINPUT_DEVICE_CAP_JOYSTICK);
+
+    if (is_joystick) {
+        evdev_log_debug(device,
+            "joystick: activated for %s<->%s\n",
+            device->devname,
+            added_device->devname);
+        joystick_dispatch->device = added_device;
+    }
+}
+
+static void
+joystick_device_removed(struct evdev_device* device,
+    struct evdev_device* removed_device)
+{
+    if (device == NULL || removed_device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(device->dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    if (joystick_dispatch->device == removed_device) {
+        joystick_dispatch->device = NULL;
+    }
+}
+
+static struct evdev_dispatch_interface joystick_interface = {
+    .process = joystick_process,
+    .suspend = joystick_suspend,
+    .remove = NULL,
+    .destroy = joystick_destroy,
+    .device_added = joystick_device_added,
+    .device_removed = joystick_device_removed,
+    .device_suspended = NULL,
+    .device_resumed = NULL,
+    .post_added = NULL,
+    .touch_arbitration_toggle = NULL,
+    .touch_arbitration_update_rect = NULL,
+    .get_switch_state = NULL,
+};
+
+static enum libinput_config_status
+joystick_sendevents_set_mode(struct libinput_device* device,
+    enum libinput_config_send_events_mode mode)
+{
+    if (device == NULL)     {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct joystick_dispatch* joystick_dispatch = (struct joystick_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || joystick_dispatch == NULL) {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    if (mode == joystick_dispatch->sendevents.current_mode) {
+        return LIBINPUT_CONFIG_STATUS_SUCCESS;
+    }
+
+    switch (mode) {
+    case LIBINPUT_CONFIG_SEND_EVENTS_ENABLED:
+        break;
+    case LIBINPUT_CONFIG_SEND_EVENTS_DISABLED:
+        joystick_suspend(ev_device->dispatch, ev_device);
+        break;
+    default:
+        return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+    }
+
+    joystick_dispatch->sendevents.current_mode = mode;
+
+    return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+static uint32_t
+joystick_sendevents_get_modes(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+}
+
+static enum libinput_config_send_events_mode
+joystick_sendevents_get_mode(struct libinput_device* device)
+{
+    if (device == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct joystick_dispatch* pDispatch = (struct joystick_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || pDispatch == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    return pDispatch->sendevents.current_mode;
+}
+
+static enum libinput_config_send_events_mode
+joystick_sendevents_get_default_mode(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+}
+
+#ifdef _DEBUG
+void printf_joystick_absinfo(const char *abs_name, struct libinput_event_joystick_axis_abs_info *absinfo)
+{
+    printf("%s: code: %d, value: %d, minimum: %d, maximum: %d, fuzz: %d, flat: %d, resolution: %d, standardValue: %f\n",
+        abs_name,
+        absinfo->code,
+        absinfo->value,
+        absinfo->minimum,
+        absinfo->maximum,
+        absinfo->fuzz,
+        absinfo->flat,
+        absinfo->resolution,
+        absinfo->standardValue
+        );
+}
+
+void print_libinput_event_joystick_axis(struct libinput_event_joystick_axis *p)
+{
+    printf("JOYSTICK:\n"
+        "type: %d, device: %p, type: %d, time: 0x%x\n",
+        p->base.type,
+        p->base.device,
+        p->type,
+        p->time);
+    printf_joystick_absinfo("abs_throttle", &p->abs_throttle);
+    printf_joystick_absinfo("abs_hat0x", &p->abs_hat0x);
+    printf_joystick_absinfo("abs_hat0y", &p->abs_hat0y);
+    printf_joystick_absinfo("abs_x", &p->abs_x);
+	printf_joystick_absinfo("abs_y", &p->abs_y);
+	printf_joystick_absinfo("abs_z", &p->abs_z);
+	printf_joystick_absinfo("abs_rx", &p->abs_rx);
+	printf_joystick_absinfo("abs_ry", &p->abs_ry);
+    printf_joystick_absinfo("abs_rz", &p->abs_rz);
+}
+#endif // _DEBUG
+
+/**
+ * @brief 初始化joystick_dispatch
+ * @param joystick
+ * @param device
+ * @return bool true - 成功, false - 失败
+*/
+bool
+joystick_init(struct joystick_dispatch* pJoystick, struct evdev_device* device)
+{
+    if (pJoystick == NULL || device == NULL) {
+        return false;
+    }
+
+    pJoystick->base.dispatch_type = DISPATCH_JOYSTICK;
+    pJoystick->base.interface = &joystick_interface;
+    pJoystick->device = device;
+
+    return true;
+}
+
+struct evdev_dispatch*
+evdev_joystick_create(struct evdev_device* device)
+{
+    if (device == NULL) {
+        return NULL;
+    }
+
+    struct joystick_dispatch* joystick = {0};
+    joystick = zalloc(sizeof * joystick);
+
+    if (joystick_init(joystick, device) != true) {
+        joystick_destroy(&joystick->base);
+        joystick = NULL;
+        return NULL;
+    }
+
+    device->base.config.sendevents = &joystick->sendevents.config;
+    joystick->sendevents.current_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+    joystick->sendevents.config.get_modes = joystick_sendevents_get_modes;
+    joystick->sendevents.config.set_mode = joystick_sendevents_set_mode;
+    joystick->sendevents.config.get_mode = joystick_sendevents_get_mode;
+    joystick->sendevents.config.get_default_mode = joystick_sendevents_get_default_mode;
+
+    return &joystick->base;
+}
+
diff -Naur old/src/evdev-joystick.h new/src/evdev-joystick.h
--- old/src/evdev-joystick.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-joystick.h	2025-03-26 11:16:26.426458791 +0800
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef LIBINPUT_EVDEV_JOYSTICK_H
+#define LIBINPUT_EVDEV_JOYSTICK_H
+
+#include "evdev.h"
+#include "libinput-private.h"
+
+struct joystick_dispatch {
+	struct evdev_dispatch base;
+	struct evdev_device* device;
+	uint32_t axis_value_mask;
+	struct joystick_axis_abs_infos axis_abs_infos;
+	struct {
+		struct libinput_device_config_send_events config;
+		enum libinput_config_send_events_mode current_mode;
+	} sendevents;
+};
+
+struct libinput_event_joystick_button {
+	struct libinput_event base;
+	uint32_t type;
+	uint64_t time;
+	uint32_t key;
+	uint32_t seat_key_count;
+	enum libinput_button_state state;
+	int value;
+};
+
+struct libinput_event_joystick_axis {
+	struct libinput_event base;
+    uint32_t type;
+	uint64_t time;
+	uint32_t axis_value_mask;
+	struct libinput_event_joystick_axis_abs_info abs_throttle;
+	struct libinput_event_joystick_axis_abs_info abs_hat0x;
+	struct libinput_event_joystick_axis_abs_info abs_hat0y;
+	struct libinput_event_joystick_axis_abs_info abs_x;
+	struct libinput_event_joystick_axis_abs_info abs_y;
+	struct libinput_event_joystick_axis_abs_info abs_z;
+	struct libinput_event_joystick_axis_abs_info abs_rx;
+	struct libinput_event_joystick_axis_abs_info abs_ry;
+	struct libinput_event_joystick_axis_abs_info abs_rz;
+	struct libinput_event_joystick_axis_abs_info abs_gas;
+	struct libinput_event_joystick_axis_abs_info abs_brake;
+};
+
+#ifdef _DEBUG
+void print_libinput_event_joystick_axis(struct libinput_event_joystick_axis* p);
+#endif // _DEBUG
+
+/**
+ * @brief 创建evdev_dispatch结构体
+ * @param device
+ * @return struct evdev_dispatch*
+*/
+struct evdev_dispatch* evdev_joystick_create(struct evdev_device* device);
+
+#endif
diff -Naur old/src/evdev-mt-touchpad-buttons.c new/src/evdev-mt-touchpad-buttons.c
--- old/src/evdev-mt-touchpad-buttons.c	2025-03-26 11:12:53.945121848 +0800
+++ new/src/evdev-mt-touchpad-buttons.c	2025-03-26 11:16:26.426458791 +0800
@@ -25,6 +25,7 @@
 
 #include <limits.h>
 #include <math.h>
+#include <pthread.h>
 #include <string.h>
 #include "linux/input.h"
 
@@ -43,6 +44,73 @@
  * The state machine only affects the soft button area code.
  */
 
+struct evdev_rightbutton_area {
+    int32_t scale_x; /* width percent */
+    int32_t scale_y; /* height percent */
+};
+
+struct evdev_rightbutton_config {
+    bool enabled;
+    struct evdev_rightbutton_area effect;
+    struct evdev_rightbutton_area want_effect;
+    pthread_mutex_t mutex;
+};
+
+static inline struct evdev_rightbutton_config *
+evdev_get_rightbutton_config(void)
+{
+    static struct evdev_rightbutton_config rightbutton_config = {
+        .enabled = false,
+        .effect = { 0 },
+        .want_effect = { 0 },
+        .mutex = PTHREAD_MUTEX_INITIALIZER
+    };
+    return &rightbutton_config;
+}
+
+static inline struct evdev_rightbutton_area *
+evdev_get_rightbutton_area(void)
+{
+    return &(evdev_get_rightbutton_config()->effect);
+}
+
+static inline bool
+is_rightbutton_area_config_change(void)
+{
+    struct evdev_rightbutton_config *rightbutton_config =
+                                     evdev_get_rightbutton_config();
+    return (rightbutton_config->effect.scale_x !=
+            rightbutton_config->want_effect.scale_x) ||
+           (rightbutton_config->effect.scale_y !=
+            rightbutton_config->want_effect.scale_y);
+}
+
+static bool
+evdev_clickpad_rightbutton_apply_config(void)
+{
+    if (!is_rightbutton_area_config_change()) {
+        return false;
+    }
+
+    struct evdev_rightbutton_config *rightbutton_config =
+                                     evdev_get_rightbutton_config();
+    if (pthread_mutex_trylock(&rightbutton_config->mutex) != 0) {
+        return false;
+    }
+
+    memcpy(&rightbutton_config->effect,
+           &rightbutton_config->want_effect,
+           sizeof(rightbutton_config->effect));
+
+    pthread_mutex_unlock(&rightbutton_config->mutex);
+}
+
+static inline bool
+is_rightbutton_area_enable(void)
+{
+    return evdev_get_rightbutton_config()->enabled;
+}
+
 static inline const char*
 button_state_to_str(enum button_state state)
 {
@@ -520,7 +588,7 @@
 	mm = evdev_device_unit_delta_to_mm(tp->device, &delta);
 	vector_length = hypot(mm.x, mm.y);
 
-	if (vector_length > 5.0 /* mm */) {
+	if (vector_length > 1.0 /* mm */) {
 		t->button.has_moved = true;
 
 		tp_button_release_other_bottom_touches(tp,
@@ -605,9 +673,11 @@
 	if (e->value) {
 		tp->buttons.state |= mask;
 		tp->queued |= TOUCHPAD_EVENT_BUTTON_PRESS;
+		evdev_log_libinput_info(tp->device, "into TOUCHPAD_EVENT_BUTTON_PRESS");
 	} else {
 		tp->buttons.state &= ~mask;
 		tp->queued |= TOUCHPAD_EVENT_BUTTON_RELEASE;
+		evdev_log_libinput_info(tp->device, "into TOUCHPAD_EVENT_BUTTON_RELEASE");
 	}
 }
 
@@ -622,6 +692,62 @@
 }
 
 static void
+tp_init_rightbutton_area(struct tp_dispatch *tp,
+            struct evdev_device *device)
+{
+    const int32_t percent = 100;
+    const int32_t button_size_y = 10;
+    const double top_size_mult = 1.0;
+    const double top_size_mult_enlarge = 3.0;
+    double width = 0.0;
+    double height = 0.0;
+    double topbutton_height = 0.0;
+    struct device_coords edges = { 0, 0 };
+    struct phys_coords mm = { 0.0, 0.0 };
+    struct evdev_rightbutton_area *rightbutton_area = NULL;
+
+    /* Function returns a pointer to a static variable without checking
+     * whether the pointer is NULL, scale_x or scale_x must be greater
+     * than 0 and less than or equal to 100
+     */
+    rightbutton_area = evdev_get_rightbutton_area();
+    evdev_device_get_size(device, &width, &height);
+    mm.x = width * (percent - rightbutton_area->scale_x) / percent;
+    mm.y = height * (percent - rightbutton_area->scale_y) / percent;
+
+    /* T440s has the top button line, If the height of right button
+     * conflicts with top button line, reserve the height of the top button
+     * line, please pay attention to the call of tp_init_top_softbuttons
+     */
+    if (tp->buttons.has_topbuttons) {
+        if (tp->suspend_reason == 0) {
+            topbutton_height = button_size_y * top_size_mult;
+        } else {
+            topbutton_height = button_size_y * top_size_mult_enlarge;
+        }
+        if (topbutton_height > mm.y) {
+            evdev_log_info(device, "The height of right button area is "
+                                   "conflicts with top button line. top "
+                                   "button height:%lf, right button area "
+                                   "height:%lf\n", topbutton_height, mm.y);
+            mm.y = topbutton_height;
+        }
+    }
+
+    edges = evdev_device_mm_to_units(device, &mm);
+    tp->buttons.bottom_area.rightbutton_left_edge = edges.x;
+    tp->buttons.bottom_area.top_edge = edges.y;
+    tp->buttons.bottom_area.middlebutton_left_edge = INT_MAX;
+    /* If right button area config, don't init middlebutton software area
+     * regardless of wether middlebutton emulation enabled or disabled
+     */
+    if (!device->middlebutton.want_enabled) {
+        evdev_log_info(device, "If right button area is configed, don't "
+                               "init middlebutton software area.\n");
+    }
+}
+
+static void
 tp_init_softbuttons(struct tp_dispatch *tp,
 		    struct evdev_device *device)
 {
@@ -630,14 +756,18 @@
 	int mb_le, mb_re; /* middle button left/right edge */
 	struct phys_coords mm = { 0.0, 0.0 };
 
+    if (is_rightbutton_area_enable()) {
+        return tp_init_rightbutton_area(tp, device);
+    }
+
 	evdev_device_get_size(device, &width, &height);
 
 	/* button height: 10mm or 15% or the touchpad height,
 	   whichever is smaller */
-	if (height * 0.15 > 10)
-		mm.y = height - 10;
+	if (height * 0.37 > 25)
+		mm.y = height - 25;
 	else
-		mm.y = height * 0.85;
+		mm.y = height * 0.63;
 
 	mm.x = width * 0.5;
 	edges = evdev_device_mm_to_units(device, &mm);
@@ -748,6 +878,7 @@
 
 	switch (tp->buttons.click_method) {
 	case LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS:
+        (void)evdev_clickpad_rightbutton_apply_config();
 		tp_init_softbuttons(tp, tp->device);
 		break;
 	case LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER:
@@ -1055,6 +1186,31 @@
 	return 0;
 }
 
+#define BUTTON_TIMEOUT ms2us(50)
+static inline bool
+tp_clickfinger_within_time(struct tp_dispatch *tp,
+			       struct tp_touch *t1,
+			       struct tp_touch *t2)
+{
+	uint64_t time = 0;
+	if (!t1 || !t2)
+		return 0;
+
+	if (tp_thumb_ignored(tp, t1) || tp_thumb_ignored(tp, t2))
+		return 0;
+
+	if (t1->initial_time <= t2->initial_time) {
+		time = t2->initial_time - t1->initial_time;
+	} else {
+		time = t1->initial_time - t2->initial_time;
+	}
+
+	if (time < BUTTON_TIMEOUT) {
+		return true;
+	}
+	return false;
+}
+
 static inline bool
 tp_clickfinger_within_distance(struct tp_dispatch *tp,
 			       struct tp_touch *t1,
@@ -1110,6 +1266,89 @@
 	return within_distance;
 }
 
+static inline bool
+tp_clickfinger_within_distance_value(struct tp_dispatch *tp,
+			       struct tp_touch *t1,
+			       struct tp_touch *t2)
+{
+	double x, y;
+	int xres, yres;
+
+	if (!t1 || !t2)
+		return 0;
+
+	x = abs(t1->point.x - t2->point.x);
+	y = abs(t1->point.y - t2->point.y);
+
+	xres = tp->device->abs.absinfo_x->resolution;
+	yres = tp->device->abs.absinfo_y->resolution;
+	x /= xres;
+	y /= yres;
+
+	/* maximum horiz spread is 40mm horiz, 30mm vert, anything wider
+	 * than that is probably a gesture. */
+	if (x > 40 || y > 30) {
+		evdev_log_libinput_info(tp->device, "tp_clickfinger distance x:%f,y:%f", x, y);
+		return false;
+	}
+		
+	return true;
+}
+
+static uint32_t
+tp_clickfinger_set_button_value(struct tp_dispatch *tp)
+{
+	uint32_t button;
+	unsigned int nfingers = 0;
+	struct tp_touch *t;
+	struct tp_touch *first = NULL,
+			*second = NULL;
+
+	tp_for_each_touch(tp, t) {
+		if (t->state != TOUCH_BEGIN && t->state != TOUCH_UPDATE)
+			continue;
+
+		if (t->palm.state != PALM_NONE)
+			continue;
+
+		nfingers++;
+
+		if (!first)
+			first = t;
+		else if (!second)
+			second = t;
+	}
+
+	/* Only check for finger distance when there are 2 fingers on the
+	 * touchpad */
+	if (nfingers != 2)
+		return tp->buttons.active;
+
+	if (tp_clickfinger_within_distance_value(tp, first, second))
+		nfingers = 2;
+	else
+		nfingers = 1;
+
+	if (nfingers == 2 && tp_clickfinger_within_time(tp, first, second)) {
+		nfingers = 2;
+	} else {
+		nfingers = 1;
+	}
+
+	switch (nfingers) {
+	case 0:
+	case 1: button = BTN_LEFT; break;
+	case 2: button = BTN_RIGHT; break;
+	case 3: button = BTN_MIDDLE; break;
+	default:
+		button = 0;
+		break;
+	}
+
+	return button;
+}
+
+
 static uint32_t
 tp_clickfinger_set_button(struct tp_dispatch *tp)
 {
@@ -1161,6 +1400,18 @@
 	return button;
 }
 
+void
+tp_button_suspend(struct tp_dispatch *tp, uint64_t time)
+{
+	tp->buttons.suspended = true;
+}
+
+void
+tp_button_resume(struct tp_dispatch *tp, uint64_t time)
+{
+	tp->buttons.suspended = false;
+}
+
 static int
 tp_notify_clickpadbutton(struct tp_dispatch *tp,
 			 uint64_t time,
@@ -1197,6 +1448,14 @@
 	 * don't end up sending a button event. */
 	tp_edge_scroll_stop_events(tp, time);
 
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD) &&
+		state == LIBINPUT_BUTTON_STATE_PRESSED) {
+		button = tp_clickfinger_set_button_value(tp);
+		tp->buttons.active = button;
+
+		if (!button)
+			return 0;
+	}
 	/*
 	 * If the user has requested clickfinger replace the button chosen
 	 * by the softbutton code with one based on the number of fingers.
@@ -1210,10 +1469,17 @@
 			return 0;
 	}
 
-	evdev_pointer_notify_button(tp->device, time, button, state);
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD) &&
+	    tp->buttons.suspended) {
+		return 0;
+	}
+
+	evdev_log_libinput_info(tp->device, "notify button:%d, state:%d,area:%d", button, state, tp->buttons.area);
+	evdev_pointer_notify_button_touchpad(tp->device, time, button, state);
 	return 1;
 }
 
+#define BTN_RIGHT_MENUE 0x118
 static int
 tp_post_clickpadbutton_buttons(struct tp_dispatch *tp, uint64_t time)
 {
@@ -1288,7 +1554,7 @@
 		} else if (area & RIGHT) {
 			button = BTN_RIGHT;
 		} else if (area & LEFT) {
-			button = BTN_LEFT;
+			button = BTN_RIGHT_MENUE;
 		} else { /* main or no area (for clickfinger) is always BTN_LEFT */
 			button = BTN_LEFT;
 			want_left_handed = false;
@@ -1299,10 +1565,27 @@
 
 		if (want_left_handed)
 			button = evdev_to_left_handed(tp->device, button);
-
+		
+		uint64_t initial_time = 0;
+		enum button_event current = 0;
+		tp_for_each_touch(tp, t) {
+			if (t->initial_time == 0) {
+				continue;
+			}
+			if (initial_time < t->initial_time) {
+				initial_time = t->initial_time;
+				current = t->button.current;
+			}
+		}
 		tp->buttons.active = button;
 		tp->buttons.active_is_topbutton = is_top;
 		state = LIBINPUT_BUTTON_STATE_PRESSED;
+		tp->buttons.area = button;
+		if (current == BUTTON_EVENT_IN_BOTTOM_L) {
+			tp->buttons.area = BTN_RIGHT_MENUE;
+		} else if (current != BUTTON_EVENT_IN_BOTTOM_R) {
+			tp->buttons.area = BTN_LEFT;
+		}
 	} else {
 		button = tp->buttons.active;
 		is_top = tp->buttons.active_is_topbutton;
@@ -1310,7 +1593,6 @@
 		tp->buttons.active_is_topbutton = 0;
 		state = LIBINPUT_BUTTON_STATE_RELEASED;
 	}
-
 	tp->buttons.click_pending = false;
 
 	if (button)
@@ -1335,7 +1617,7 @@
 tp_button_touch_active(const struct tp_dispatch *tp,
 		       const struct tp_touch *t)
 {
-	return t->button.state == BUTTON_STATE_AREA || t->button.has_moved;
+	return t->button.state == BUTTON_STATE_AREA || t->button.state == BUTTON_STATE_BOTTOM || t->button.has_moved;
 }
 
 bool
@@ -1345,3 +1627,35 @@
 	return is_inside_top_button_area(tp, t) ||
 	       is_inside_bottom_button_area(tp, t);
 }
+
+void
+evdev_set_rightbutton_area(const int32_t width_percent,
+                           const int32_t height_percent)
+{
+    struct evdev_rightbutton_config *rightbutton_config = NULL;
+    struct evdev_rightbutton_area *rightbutton_area = NULL;
+
+    rightbutton_config = evdev_get_rightbutton_config();
+    rightbutton_area = &rightbutton_config->want_effect;
+    pthread_mutex_lock(&rightbutton_config->mutex);
+    rightbutton_area->scale_x = width_percent;
+    rightbutton_area->scale_y = height_percent;
+    rightbutton_config->enabled = true;
+    pthread_mutex_unlock(&rightbutton_config->mutex);
+}
+
+void
+tp_clickpad_rightbutton_apply_config(struct evdev_device *device)
+{
+    struct tp_dispatch *tp = (struct tp_dispatch*)device->dispatch;
+
+    if ((tp->buttons.click_method !=
+        LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS) ||
+        (tp->buttons.state != 0)) {
+        return;
+    }
+
+    if (evdev_clickpad_rightbutton_apply_config()) {
+        tp_init_softbuttons(tp, device);
+    }
+}
diff -Naur old/src/evdev-mt-touchpad-gestures.c new/src/evdev-mt-touchpad-gestures.c
--- old/src/evdev-mt-touchpad-gestures.c	2025-03-26 11:12:53.945121848 +0800
+++ new/src/evdev-mt-touchpad-gestures.c	2025-03-26 11:16:26.426458791 +0800
@@ -33,9 +33,19 @@
 #define DEFAULT_GESTURE_SWITCH_TIMEOUT ms2us(100)
 #define DEFAULT_GESTURE_SWIPE_TIMEOUT ms2us(150)
 #define DEFAULT_GESTURE_PINCH_TIMEOUT ms2us(300)
+#define DEFAULT_GESTURE_MULTIFINGER_TIMETHRESSHOLD ms2us(100)
 
+#define MULTIFINGER_DISTANCE_SCALE 0.6
 #define HOLD_AND_MOTION_THRESHOLD 0.5 /* mm */
 #define PINCH_DISAMBIGUATION_MOVE_THRESHOLD 1.5 /* mm */
+#define ROTATE_DELTA_ANGLE_THRESHOLD 10.0 /* ° */
+#define ROTATE_DELTA_DISTANCE_THRESHOLD 100.0 /* ppi */
+#define TIME_GESTURE_WAIT_ALL_FINGER_DOWN 100000
+
+#define PRESS_AND_DRAG_LEFT_EDGE_BIT  0x01
+#define PRESS_AND_DRAG_RIGHT_EDGE_BIT 0x02
+#define PRESS_AND_DRAG_UPPER_EDGE_BIT 0x04
+#define PRESS_AND_DRAG_LOWER_EDGE_BIT 0x08
 
 enum gesture_event {
 	GESTURE_EVENT_RESET,
@@ -90,7 +100,7 @@
 }
 
 static struct device_float_coords
-tp_get_touches_delta(struct tp_dispatch *tp, bool average)
+tp_get_touches_delta(struct tp_dispatch *tp, bool average, uint64_t time)
 {
 	struct tp_touch *t;
 	unsigned int i, nactive = 0;
@@ -99,9 +109,12 @@
 	for (i = 0; i < tp->num_slots; i++) {
 		t = &tp->touches[i];
 
-		if (!tp_touch_active_for_gesture(tp, t))
+		if (!tp_touch_active_for_gesture(tp, t, time))
 			continue;
 
+		if (tp_touch_unintended_touch_for_typing(tp, t, time))
+		    continue;
+
 		nactive++;
 
 		if (t->dirty) {
@@ -124,6 +137,37 @@
 }
 
 static void
+tp_get_raw_touches(struct tp_dispatch *tp, struct sloted_coords_info *raw_touches, uint64_t time)
+{
+	struct tp_touch *t;
+	unsigned int i;
+	raw_touches->active_count = 0;
+
+	if (tp->num_slots > MAX_SOLTED_COORDS_NUM) {
+		evdev_log_bug_libinput(tp->device,
+				       "in %s, num_slots: %d, more than %d\n",
+				       __func__, tp->num_slots, MAX_SOLTED_COORDS_NUM);
+	}
+	const unsigned int num_slots = (tp->num_slots > MAX_SOLTED_COORDS_NUM) ? MAX_SOLTED_COORDS_NUM : tp->num_slots;
+
+	for (i = 0; i < num_slots; i++) {
+		t = &tp->touches[i];
+
+		if (!tp_touch_active_for_gesture(tp, t, time))
+			continue;
+
+		if (t->dirty) {
+			struct device_coords d;
+			d = tp_get_delta(t);
+			raw_touches->coords[i].x = d.x;
+			raw_touches->coords[i].y = d.y;
+		}
+		raw_touches->coords[i].is_active = true;
+		raw_touches->active_count++;
+	}
+}
+
+static void
 tp_gesture_init_scroll(struct tp_dispatch *tp)
 {
 	struct phys_coords zero = {0.0, 0.0};
@@ -133,18 +177,21 @@
 	tp->scroll.duration.v = 0;
 	tp->scroll.vector = zero;
 	tp->scroll.time_prev = 0;
+	tp->scroll.scroll_delta.x = 0.0;
+	tp->scroll.scroll_delta.y = 0.0;
+	tp->scroll.correct_pinch_flag = false;
 }
 
 static inline struct device_float_coords
-tp_get_combined_touches_delta(struct tp_dispatch *tp)
+tp_get_combined_touches_delta(struct tp_dispatch *tp, uint64_t time)
 {
-	return tp_get_touches_delta(tp, false);
+	return tp_get_touches_delta(tp, false, time);
 }
 
 static inline struct device_float_coords
-tp_get_average_touches_delta(struct tp_dispatch *tp)
+tp_get_average_touches_delta(struct tp_dispatch *tp, uint64_t time)
 {
-	return tp_get_touches_delta(tp, true);
+	return tp_get_touches_delta(tp, true, time);
 }
 
 static void
@@ -169,18 +216,29 @@
 		break;
 	case GESTURE_STATE_SCROLL:
 		tp_gesture_init_scroll(tp);
+		gesture_notify_axis_finger(&tp->device->base, time,
+					LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN,
+					0, &zero);
+		evdev_log_libinput_info(tp->device, "Two-finger sliding begins");
 		break;
-	case GESTURE_STATE_PINCH:
+	case GESTURE_STATE_PINCH: {
+		double angle = tp->gesture.is_rotate ? tp->gesture.angle_delta : 0.0;
 		gesture_notify_pinch(&tp->device->base, time,
-				    LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
-				    tp->gesture.finger_count,
-				    &zero, &zero, 1.0, 0.0);
+					LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+					tp->gesture.finger_count,
+					&zero, &zero, 1.0, angle);
+        if (tp->gesture.is_rotate) {
+			evdev_log_libinput_info(tp->device, "rotate begin");
+		} else {
+			evdev_log_libinput_info(tp->device, "pinch begin");
+		}
 		break;
+	}
 	case GESTURE_STATE_SWIPE:
 		gesture_notify_swipe(&tp->device->base, time,
 				     LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 				     tp->gesture.finger_count,
-				     &zero, &zero);
+				     &zero, &zero, NULL);
 		break;
 	case GESTURE_STATE_POINTER_MOTION:
 		break;
@@ -190,15 +248,15 @@
 }
 
 static struct device_float_coords
-tp_get_raw_pointer_motion(struct tp_dispatch *tp)
+tp_get_raw_pointer_motion(struct tp_dispatch *tp, uint64_t time)
 {
 	struct device_float_coords raw;
 
 	/* When a clickpad is clicked, combine motion of all active touches */
-	if (tp->buttons.is_clickpad && tp->buttons.state)
-		raw = tp_get_combined_touches_delta(tp);
+	if ((tp->buttons.is_clickpad && tp->buttons.state) || (tp->gesture.finger_count <= 2))
+		raw = tp_get_combined_touches_delta(tp, time);
 	else
-		raw = tp_get_average_touches_delta(tp);
+		raw = tp_get_average_touches_delta(tp, time);
 
 	return raw;
 }
@@ -216,24 +274,222 @@
 	 * it twice (here and in tp_gesture_post_pointer_motion) with the same
 	 * event.
 	 */
-	raw = tp_get_raw_pointer_motion(tp);
+	raw = tp_get_raw_pointer_motion(tp, time);
 	return !device_float_is_zero(raw);
 }
 
+/*
+ * Return a bitmask indicating press-and-drag edge areas entered by active touches.
+ */
+static uint32_t
+tp_move_drag_is_at_edge(struct tp_dispatch *tp, uint64_t time)
+{
+	struct tp_touch *t;
+	unsigned int i;
+
+	uint32_t edgeMask = 0;
+
+	for (i = 0; i < tp->num_slots; i++) {
+		t = &tp->touches[i];
+
+		if (!tp_touch_active_for_gesture(tp, t, time))
+			continue;
+		
+		if (t->point.x < tp->press_and_drag.left_edge) {
+			edgeMask |= PRESS_AND_DRAG_LEFT_EDGE_BIT;
+		}
+		if (t->point.x > tp->press_and_drag.right_edge) {
+			edgeMask |= PRESS_AND_DRAG_RIGHT_EDGE_BIT;
+		}
+		if (t->point.y < tp->press_and_drag.upper_edge) {
+			edgeMask |= PRESS_AND_DRAG_UPPER_EDGE_BIT;
+		}
+		if (t->point.y > tp->press_and_drag.lower_edge) {
+			edgeMask |= PRESS_AND_DRAG_LOWER_EDGE_BIT;
+		}
+	}
+
+	return edgeMask;
+}
+
+static double
+evdev_device_unit_float_delta_to_distance_mm(struct tp_dispatch *tp, struct device_float_coords raw)
+{
+	struct device_coords delta = {(int)raw.x, (int)raw.y};
+	struct phys_coords delta_mm = evdev_device_unit_delta_to_mm(tp->device, &delta);
+	return hypot(delta_mm.x, delta_mm.y);
+}
+
+static struct device_float_coords
+tp_lock_for_pointer_motion(struct tp_dispatch *tp, uint64_t time, struct device_float_coords raw)
+{
+	struct device_float_coords zero_raw = {0.0, 0.0};
+	/*1.0 px movement start to judge*/
+	if (tp->pointer_motion_lock.state == POINTER_MOTION_LOCK_STATE_UNLOCKED) {
+		if (fabs(raw.x) + fabs(raw.y) <= 1.0) {
+			tp->pointer_motion_lock.state = POINTER_MOTION_LOCK_STATE_JUDGING;
+			tp->pointer_motion_lock.judge_moved = zero_raw;
+			tp->pointer_motion_lock.judge_start_time = time;
+		} else {
+			return raw;
+		}
+	}
+
+	if (tp->pointer_motion_lock.state == POINTER_MOTION_LOCK_STATE_JUDGING) {
+		/*2.0 px movement continue to judge*/
+		if (fabs(raw.x) + fabs(raw.y) <= 2.0) {
+			tp->pointer_motion_lock.judge_moved.x += raw.x;
+			tp->pointer_motion_lock.judge_moved.y += raw.y;
+		} else {
+			tp->pointer_motion_lock.state = POINTER_MOTION_LOCK_STATE_UNLOCKED;
+			return raw;
+		}
+	}
+
+	double judge_moved_mm = evdev_device_unit_float_delta_to_distance_mm(tp, tp->pointer_motion_lock.judge_moved);
+	/*0.15 mm is max movement for lock judge, 100ms is min time interval*/
+	if ((judge_moved_mm <= 0.15) && ((time - tp->pointer_motion_lock.judge_start_time) > ms2us(100))) {
+		tp->pointer_motion_lock.state = POINTER_MOTION_LOCK_STATE_LOCKED;
+	} else if (judge_moved_mm > 0.15) {
+		tp->pointer_motion_lock.state = POINTER_MOTION_LOCK_STATE_UNLOCKED;
+		return raw;
+	}
+
+	if (tp->pointer_motion_lock.state == POINTER_MOTION_LOCK_STATE_LOCKED) {
+		tp->pointer_motion_lock.lock_moved.x += raw.x;
+		tp->pointer_motion_lock.lock_moved.y += raw.y;
+		/*1.0 mm is max lock movement*/
+		if (evdev_device_unit_float_delta_to_distance_mm(tp, tp->pointer_motion_lock.lock_moved) <= 1.0) {
+			return zero_raw;
+		} else {
+			tp->pointer_motion_lock.lock_moved = zero_raw;
+			tp->pointer_motion_lock.state = POINTER_MOTION_LOCK_STATE_UNLOCKED;
+		}
+	}
+	return raw;
+}
+
+static struct device_float_coords
+tp_mean_filter_for_pointer_motion(struct tp_dispatch *tp, uint64_t time, struct device_float_coords raw)
+{
+	struct device_float_coords filter_raw = raw;
+	struct device_float_coords last_moved = tp->pointer_motion_lock.last_moved;
+	if ((fabs(raw.x) + fabs(raw.y) > 5) && (fabs(last_moved.x) + fabs(last_moved.y) > 5)) {
+		filter_raw.x = 0.5 * raw.x + 0.5 * last_moved.x;
+		filter_raw.y = 0.5 * raw.y + 0.5 * last_moved.y;
+	}
+	tp->pointer_motion_lock.last_moved = raw;
+	return filter_raw;
+}
+
+static struct device_float_coords
+tp_edge_aft_for_pointer_motion(struct tp_dispatch *tp, uint64_t time, struct device_float_coords raw)
+{
+    struct device_float_coords zero_raw = {0.0, 0.0};
+    double width, height;
+    evdev_device_get_size(tp->device, &width, &height);
+    struct phys_coords mm = {10.0, 10.0};
+    struct device_coords first = tp->gesture.touches[0]->point;
+    struct device_coords second = tp->gesture.touches[1]->point;
+
+    struct phys_coords first_mm = evdev_device_units_to_mm(tp->device, &first);
+    struct phys_coords second_mm = evdev_device_units_to_mm(tp->device, &second);
+
+    if ((first_mm.x < mm.x || first_mm.x > width - mm.x) && (second_mm.x < mm.x || second_mm.x > width - mm.x)) {
+        return zero_raw;
+    }
+    return raw;
+}
+
+static void
+tp_unpin_edge_keep_dragging(const struct tp_dispatch *tp, struct tp_touch *t)
+{
+	struct phys_coords mm;
+	struct device_coords delta;
+
+	if (!t->pinned.is_pinned_edge_dragging)
+		return;
+
+	delta.x = abs(t->point.x - t->pinned.center.x);
+	delta.y = abs(t->point.y - t->pinned.center.y);
+
+	mm = evdev_device_unit_delta_to_mm(tp->device, &delta);
+
+	/* 9mm movement -> unpin */
+	if (hypot(mm.x, mm.y) >= 9) {
+		evdev_log_libinput_info(tp->device, "edge keep dragging movement -> unpin");
+		t->pinned.is_pinned_edge_dragging = false;
+		return;
+	}
+}
+
+#define TIME_THRESHOLD 8400
 static void
 tp_gesture_post_pointer_motion(struct tp_dispatch *tp, uint64_t time)
 {
 	struct device_float_coords raw;
 	struct normalized_coords delta;
 
-	raw = tp_get_raw_pointer_motion(tp);
+	/* reset press-and-drag records */
+	if (tp->buttons.is_clickpad && !tp->buttons.state && (!tp_tap_dragging(tp))) {
+		tp->press_and_drag.dir.x = 0.0;
+		tp->press_and_drag.dir.y = 0.0;
+		tp->press_and_drag.prev_time = 0;
+	}
+
+	raw = tp_get_raw_pointer_motion(tp, time);
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD)) {		
+		raw = tp_lock_for_pointer_motion(tp, time, raw);
+		raw = tp_mean_filter_for_pointer_motion(tp, time, raw);
+		if (!(tp->buttons.is_clickpad && tp->buttons.state) && tp->nactive_slots == 2) {
+			raw = tp_edge_aft_for_pointer_motion(tp, time, raw);
+		}
+	}
+	uint32_t edgeMask = tp_move_drag_is_at_edge(tp, time);
+	struct tp_touch *t = &tp->touches[0];
+	if (tp->nactive_slots == 1 ) { 
+		tp_unpin_edge_keep_dragging(tp, t);
+	}
+	if (tp->nactive_slots == 1 && !t->pinned.is_pinned_edge_dragging && edgeMask &&
+		((tp->buttons.is_clickpad && tp->buttons.state) || tp_tap_dragging(tp))) {
+		if (tp->press_and_drag.prev_time != 0 && time > tp->press_and_drag.prev_time) {
+			/* reset raw delta according to entered edge areas */
+			if ((edgeMask & PRESS_AND_DRAG_LEFT_EDGE_BIT) || (edgeMask & PRESS_AND_DRAG_RIGHT_EDGE_BIT)) {
+				raw.x = 0.0;
+			}
+			if ((edgeMask & PRESS_AND_DRAG_UPPER_EDGE_BIT) || (edgeMask & PRESS_AND_DRAG_LOWER_EDGE_BIT)) {
+				raw.y = 0.0;
+			}
+			/* set raw delta according to entered edge areas */
+			uint64_t delta_time = time - tp->press_and_drag.prev_time;
+			if (delta_time > TIME_THRESHOLD) {
+				delta_time = TIME_THRESHOLD;
+			}
+			if (edgeMask & PRESS_AND_DRAG_LEFT_EDGE_BIT) {
+				raw.x -= tp->press_and_drag.speed * delta_time;
+			}
+			if (edgeMask & PRESS_AND_DRAG_RIGHT_EDGE_BIT) {
+				raw.x += tp->press_and_drag.speed * delta_time;
+			}
+			if (edgeMask & PRESS_AND_DRAG_UPPER_EDGE_BIT) {
+				raw.y -= tp->press_and_drag.speed * delta_time;
+			}
+			if (edgeMask & PRESS_AND_DRAG_LOWER_EDGE_BIT) {
+				raw.y += tp->press_and_drag.speed * delta_time;
+			}
+		}
+		tp->press_and_drag.prev_time = time;
+	} else {
+		tp->press_and_drag.prev_time = 0;
+	}
+
 	delta = tp_filter_motion(tp, &raw, time);
 
 	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
 		struct device_float_coords unaccel;
 
 		unaccel = tp_scale_to_xaxis(tp, raw);
-		pointer_notify_motion(&tp->device->base,
+		touchpad_pointer_notify_motion(&tp->device->base,
 				      time,
 				      &delta,
 				      &unaccel);
@@ -243,7 +499,7 @@
 static unsigned int
 tp_gesture_get_active_touches(const struct tp_dispatch *tp,
 			      struct tp_touch **touches,
-			      unsigned int count)
+			      unsigned int count, uint64_t time)
 {
 	unsigned int n = 0;
 	struct tp_touch *t;
@@ -251,7 +507,7 @@
 	memset(touches, 0, count * sizeof(struct tp_touch *));
 
 	tp_for_each_touch(tp, t) {
-		if (tp_touch_active_for_gesture(tp, t)) {
+		if (tp_touch_active_for_gesture(tp, t, time)) {
 			touches[n++] = t;
 			if (n == count)
 				return count;
@@ -873,7 +1129,11 @@
 	double thumb_mm, finger_mm;
 	double min_move = 1.5; /* min movement threshold in mm - count this touch */
 	double max_move = 4.0; /* max movement threshold in mm - ignore other touch */
+	double move_threshold = 9.0;
 	bool is_hold_and_motion;
+	struct quirks_context *quirks;
+	struct quirks *q;
+	double hold_and_motion_threshold;
 
 	first_moved = tp_gesture_mm_moved(tp, first);
 	first_mm = hypot(first_moved.x, first_moved.y);
@@ -882,7 +1142,15 @@
 		if (!tp_has_pending_pointer_motion(tp, time))
 			return;
 
+		hold_and_motion_threshold = HOLD_AND_MOTION_THRESHOLD;
+		quirks = evdev_libinput_context(tp->device)->quirks;
+		q = quirks_fetch_for_device(quirks, tp->device->udev_device);
+		if (!q || !quirks_get_double(q, QUIRK_ATTR_TOUCHPAD_HOLD_AND_MOTION_THRESHOLD, &hold_and_motion_threshold))
+			hold_and_motion_threshold = HOLD_AND_MOTION_THRESHOLD;
+		quirks_unref(q);
 		is_hold_and_motion = (first_mm < HOLD_AND_MOTION_THRESHOLD);
+		if (is_hold_and_motion == 1)
+			return;
 
 		if (tp->gesture.state == GESTURE_STATE_HOLD &&
 		    is_hold_and_motion) {
@@ -941,12 +1209,10 @@
 	if ((!tp->gesture.enabled ||
 	     (distance_mm.x < 40.0 && distance_mm.y < 7.0)) &&
 	    time > (tp->gesture.initial_time + DEFAULT_GESTURE_SWIPE_TIMEOUT)) {
-		if (tp->gesture.finger_count == 2)
-			tp_gesture_handle_event(tp, GESTURE_EVENT_SCROLL, time);
-		else
+		if (tp->gesture.finger_count != 2) {
 			tp_gesture_handle_event(tp, GESTURE_EVENT_SWIPE, time);
-
-		return;
+			return;
+		}
 	}
 
 	/* If one touch exceeds the max_move threshold while the other has not
@@ -955,27 +1221,34 @@
 	 * place while the other moves.
 	 */
 	if (first_mm >= max_move || second_mm >= max_move) {
-		/* If thumb detection is enabled, and thumb is still while
-		 * finger moves, cancel gestures and mark lower as thumb.
-		 * This applies to all gestures (2, 3, 4+ fingers), but allows
-		 * more thumb motion on >2 finger gestures during detection.
+		/* One finger doesn't move, one finger slides.
+		 * If the sliding finger does not exceed 0.5mm without moving,
+		 * and if the sliding finger exceeds 9mm, a move event will be reported.
 		 */
-		if (tp->thumb.detect_thumbs && thumb_mm < min_move) {
-			tp_thumb_suppress(tp, thumb);
-			tp_gesture_cancel(tp, time);
+		if (tp->thumb.detect_thumbs && thumb_mm < 0.5 &&
+			tp->gesture.finger_count == 2 && finger_mm > move_threshold) {
+			tp_gesture_handle_event(tp, GESTURE_EVENT_POINTER_MOTION, time);
 			return;
 		}
-
-		/* If gestures detection is disabled, or if finger is still
-		 * while thumb moves, assume this is "one-finger scrolling."
-		 * This applies only to 2-finger gestures.
-		 */
-		if ((!tp->gesture.enabled || finger_mm < min_move) &&
-		    tp->gesture.finger_count == 2) {
-			tp_gesture_handle_event(tp, GESTURE_EVENT_SCROLL, time);
+		if ((!tp->gesture.enabled || finger_mm < 0.5) &&
+		    tp->gesture.finger_count == 2 && thumb_mm > move_threshold) {
+			tp_gesture_handle_event(tp, GESTURE_EVENT_POINTER_MOTION, time);
 			return;
 		}
 
+		/* If we can't accurately detect pinches, or if the touches are moving
+		 * the same way, this is a scroll or swipe.
+		 */
+		if (tp->gesture.enabled &&
+		    (tp->gesture.finger_count > tp->num_slots ||
+		    tp->gesture.finger_count > 2)) {
+		    dir1 = tp_gesture_get_direction(tp, first);
+		    dir2 = tp_gesture_get_direction(tp, second);
+		    if (tp_gesture_same_directions(dir1, dir2)) {
+			    tp_gesture_handle_event(tp, GESTURE_EVENT_SWIPE, time);
+			    return;
+		    }
+		}
 		/* If more than 2 fingers are involved, and the thumb moves
 		 * while the fingers stay still, assume a pinch if eligible.
 		 */
@@ -991,8 +1264,19 @@
 	/* If either touch is still below the min_move threshold, we can't
 	 * tell what kind of gesture this is.
 	 */
-	if ((first_mm < min_move) || (second_mm < min_move))
-		return;
+	if ((first_mm < min_move) || (second_mm < min_move)) {
+		if (tp->gesture.finger_count > 2 &&
+			(first_mm > min_move * MULTIFINGER_DISTANCE_SCALE &&
+			second_mm > min_move * MULTIFINGER_DISTANCE_SCALE) &&
+			time - tp->gesture.initial_time < DEFAULT_GESTURE_MULTIFINGER_TIMETHRESSHOLD) {
+			evdev_log_libinput_info(tp->device,
+				"distance < min_move, first:%f, second:%f, but conduct multifinger distance threshold, time delta:%llu",
+				first_mm, second_mm, time - tp->gesture.initial_time);
+
+		} else {
+			return;
+		}
+	}
 
 	/* Both touches have exceeded the min_move threshold, so we have a
 	 * valid gesture. Update gesture initial time and get directions so
@@ -1016,7 +1300,27 @@
 			return;
 		}
 	}
-
+	if (tp->gesture.enabled && tp->gesture.finger_count == 2) {
+		struct device_float_coords delta_coords = device_delta(first->point, second->point);
+		struct normalized_coords normalized = tp_normalize_delta(tp, delta_coords);
+		double distance = normalized_length(normalized);
+		double angle = atan2(normalized.y, normalized.x) * 180.0 / M_PI;
+		double angle_delta = angle - tp->gesture.angle;
+		double distance_delta = distance - tp->gesture.initial_distance;
+		if (angle_delta > 180.0)
+			angle_delta -= 360.0;
+		else if (angle_delta < -180.0)
+			angle_delta += 360.0;
+
+		if ((fabs(angle_delta) >= ROTATE_DELTA_ANGLE_THRESHOLD) &&
+			(fabs(distance_delta) <= ROTATE_DELTA_DISTANCE_THRESHOLD)) {
+			tp->gesture.angle_delta = angle_delta > 0 ?
+				angle_delta - ROTATE_DELTA_ANGLE_THRESHOLD : angle_delta + ROTATE_DELTA_ANGLE_THRESHOLD;
+			tp->gesture.is_rotate = true;
+			tp_gesture_handle_event(tp, GESTURE_EVENT_PINCH, time);
+			return;
+		}
+	}
 	/* If the touches are moving away from each other, this is a pinch */
 	tp_gesture_handle_event(tp, GESTURE_EVENT_PINCH, time);
 }
@@ -1056,7 +1360,7 @@
 	unsigned int ntouches;
 	unsigned int i;
 
-	ntouches = tp_gesture_get_active_touches(tp, touches, 4);
+	ntouches = tp_gesture_get_active_touches(tp, touches, 4, time);
 
 	first = touches[0];
 	second = touches[1];
@@ -1119,6 +1423,10 @@
 	tp->gesture.touches[0] = first;
 	tp->gesture.touches[1] = second;
 
+	struct device_float_coords center;
+	tp_gesture_get_pinch_info(tp, &tp->gesture.initial_distance, &tp->gesture.angle, &center);
+	tp->gesture.angle_delta = 0.0;
+	tp->gesture.is_rotate = false;
 	tp_gesture_handle_event(tp, GESTURE_EVENT_FINGER_DETECTED, time);
 }
 
@@ -1143,6 +1451,9 @@
 static void
 tp_gesture_handle_state_hold_and_pointer_motion(struct tp_dispatch *tp, uint64_t time)
 {
+	if (tp->gesture.finger_count > 1)
+		tp_gesture_cancel(tp, time);
+
 	if (tp->queued & TOUCHPAD_EVENT_MOTION)
 		tp_gesture_post_pointer_motion(tp, time);
 
@@ -1152,10 +1463,191 @@
 static void
 tp_gesture_handle_state_pointer_motion(struct tp_dispatch *tp, uint64_t time)
 {
-	if (tp->queued & TOUCHPAD_EVENT_MOTION)
+	if (tp->queued & TOUCHPAD_EVENT_MOTION ||
+		(((tp->buttons.is_clickpad && tp->buttons.state) || tp_tap_dragging(tp)) && tp_move_drag_is_at_edge(tp, time)))
 		tp_gesture_post_pointer_motion(tp, time);
 }
 
+static double
+evdev_device_axis_delta_to_mm(const struct evdev_device* device,
+			      const double axis_delta, bool is_x)
+{
+	double mm = 0;
+	const struct input_absinfo *absx, *absy;
+
+	if (device->abs.absinfo_x == NULL ||
+	    device->abs.absinfo_y == NULL) {
+		log_bug_libinput(evdev_libinput_context(device),
+				 "%s: is not an abs device\n",
+				 device->devname);
+		return mm;
+	}
+
+	absx = device->abs.absinfo_x;
+	absy = device->abs.absinfo_y;
+
+	if (is_x) {
+		mm = 1.0 * axis_delta/absx->resolution;
+	} else {
+		mm = 1.0 * axis_delta/absy->resolution;
+	}
+	return mm;
+}
+
+static double
+tp_idle_lock_for_scroll_unit(struct tp_dispatch *tp, uint64_t time, double delta, bool is_x)
+{
+	struct scroll_idle_lock *lock = is_x ? &tp->scroll_idle_lock[0] : &tp->scroll_idle_lock[1];
+	double zero_delta = 0.0;
+	if (delta == 0.0) {
+		delta = zero_delta;
+	} 
+	if (lock->state == SCROLL_LOCK_STATE_UNLOCKED) {
+		if (fabs(delta) <= zero_delta) {
+			lock->state = SCROLL_LOCK_STATE_JUDGING;
+			lock->judge_moved = delta;
+			lock->judge_start_time = time;
+		} 
+		return delta;
+	}
+
+	if (lock->state == SCROLL_LOCK_STATE_JUDGING) {
+		/*0.5 px movement continue to judge*/
+		if (fabs(delta) <= 0.5) {
+			lock->judge_moved += delta;
+		} else {
+			lock->state = SCROLL_LOCK_STATE_UNLOCKED;
+			return delta;
+		}
+	}
+
+	double judge_moved_mm = fabs(evdev_device_axis_delta_to_mm(tp->device, lock->judge_moved, is_x));
+	/*0.15 mm is max movement for lock judge, 100ms is min time interval*/
+	if ((judge_moved_mm <= 0.15) && ((time - lock->judge_start_time) > ms2us(70))) {
+		lock->state = SCROLL_LOCK_STATE_LOCKED;
+	} else if (judge_moved_mm > 0.15) {
+		lock->state = SCROLL_LOCK_STATE_UNLOCKED;
+		return delta;
+	}
+
+	if (lock->state == SCROLL_LOCK_STATE_LOCKED) {
+		lock->lock_moved += delta;
+		/*0.5 mm is max lock movement*/
+		if (fabs(evdev_device_axis_delta_to_mm(tp->device, lock->lock_moved, is_x)) <= 0.5) {
+			return zero_delta;
+		} else {
+			lock->lock_moved = zero_delta;
+			lock->state = SCROLL_LOCK_STATE_UNLOCKED;
+		}
+	}
+	return delta;
+}
+
+static double
+tp_direction_lock_for_scroll_unit(struct tp_dispatch *tp, uint64_t time, double delta, bool is_x)
+{
+	struct scroll_direction_lock *lock = is_x ? &tp->scroll_direction_lock[0] : &tp->scroll_direction_lock[1];
+	double zero_delta = 0.0;
+
+	if (lock->state == SCROLL_LOCK_STATE_UNLOCKED) {
+		if (fabs(delta) >= 1.0) {
+			lock->state = SCROLL_LOCK_STATE_JUDGING;
+			lock->judge_moved = delta;
+			lock->direction = (delta > 0 ? 1 : -1);
+		} 
+		return delta;
+	}
+
+	if (lock->state == SCROLL_LOCK_STATE_JUDGING) {
+		if (lock->direction * delta > 0) {
+			lock->judge_moved += delta;
+		} else if (fabs(evdev_device_axis_delta_to_mm(tp->device, lock->judge_moved, is_x)) >= 5.0) {
+			lock->state = SCROLL_LOCK_STATE_LOCKED;
+			lock->lock_moved = 0;
+		} else {
+			lock->state = SCROLL_LOCK_STATE_UNLOCKED;
+			return delta;
+		}
+	}
+
+	if (lock->state == SCROLL_LOCK_STATE_LOCKED) {
+		lock->lock_moved += delta;
+		/*1.0 mm is max lock movement*/
+		if (fabs(evdev_device_axis_delta_to_mm(tp->device, lock->lock_moved, is_x)) <= 1.0) {
+			return lock->direction * zero_delta;
+		} else {
+			lock->lock_moved = 0;
+			lock->state = SCROLL_LOCK_STATE_UNLOCKED;
+		}
+	}
+	return delta;
+}
+
+static struct device_float_coords
+tp_lock_for_scroll(struct tp_dispatch *tp, uint64_t time, struct device_float_coords raw)
+{
+	evdev_log_bug_libinput(tp->device, "scroll lock in dx: %f, dy: %f\n", raw.x, raw.y);
+	struct device_float_coords aft_raw, idle_lock_raw, direction_lock_raw;
+	idle_lock_raw.x = tp_idle_lock_for_scroll_unit(tp, time, raw.x, true);
+	idle_lock_raw.y = tp_idle_lock_for_scroll_unit(tp, time, raw.y, false);
+
+	direction_lock_raw.x = tp_direction_lock_for_scroll_unit(tp, time, raw.x, true);
+	direction_lock_raw.y = tp_direction_lock_for_scroll_unit(tp, time, raw.y, false);
+
+	aft_raw.x = fabs(idle_lock_raw.x) < fabs(direction_lock_raw.x) ? idle_lock_raw.x : direction_lock_raw.x;
+	aft_raw.y = fabs(idle_lock_raw.y) < fabs(direction_lock_raw.y) ? idle_lock_raw.y : direction_lock_raw.y;
+	evdev_log_bug_libinput(tp->device, "scroll lock out dx: %f, dy: %f\n", aft_raw.x, aft_raw.y);
+
+	return aft_raw;
+}
+
+static struct device_float_coords
+tp_mean_filter_for_scroll(struct tp_dispatch *tp, uint64_t time, struct device_float_coords raw)
+{
+	evdev_log_bug_libinput(tp->device, "scroll mean filter in dx: %f, dy: %f\n", raw.x, raw.y);
+	struct device_float_coords filter_raw = raw;
+    struct device_float_coords last_moved = {
+        tp->scroll_direction_lock[0].last_moved, tp->scroll_direction_lock[1].last_moved};
+
+    if ((fabs(raw.x) > 5) && (fabs(last_moved.x) > 5)) {
+		filter_raw.x = 0.5 * raw.x + 0.5 * last_moved.x;
+	}
+	tp->scroll_direction_lock[0].last_moved = raw.x;
+
+	if ((fabs(raw.y) > 5) && (fabs(last_moved.y) > 5)) {
+		filter_raw.y = 0.5 * raw.y + 0.5 * last_moved.y;
+	}
+	tp->scroll_direction_lock[1].last_moved = raw.y;
+	evdev_log_bug_libinput(tp->device, "scroll mean filter out dx: %f, dy: %f\n", filter_raw.x, filter_raw.y);
+
+	return filter_raw;
+}
+
+static struct device_float_coords
+tp_edge_aft_for_scroll(struct tp_dispatch *tp, uint64_t time, struct device_float_coords raw)
+{
+    struct device_float_coords zero_raw = {0.0, 0.0};
+    double width, height;
+    evdev_device_get_size(tp->device, &width, &height);
+    struct phys_coords mm = { 20.0, 20.0 };
+    struct device_coords first = tp->gesture.touches[0]->point;
+    struct device_coords second = tp->gesture.touches[1]->point;
+
+    struct phys_coords first_mm = evdev_device_units_to_mm(tp->device, &first);
+    struct phys_coords second_mm = evdev_device_units_to_mm(tp->device, &second);
+
+    if (first_mm.x < mm.x || first_mm.x > width - mm.x || second_mm.x < mm.x || second_mm.x > width - mm.x) {
+        struct phys_coords delta_mm;
+        delta_mm.x = fabs(first_mm.x - second_mm.x);
+        delta_mm.y = fabs(first_mm.y - second_mm.y);
+        double distance_mm = hypot(delta_mm.x, delta_mm.y);
+        if (distance_mm > 40.0) {
+            return zero_raw;
+        }
+    }
+    return raw;
+}
+
 static void
 tp_gesture_handle_state_scroll(struct tp_dispatch *tp, uint64_t time)
 {
@@ -1165,17 +1657,19 @@
 	if (tp->scroll.method != LIBINPUT_CONFIG_SCROLL_2FG)
 		return;
 
-	/* We may confuse a pinch for a scroll initially,
-	 * allow ourselves to correct our guess.
-	 */
-	if (time < (tp->gesture.initial_time + DEFAULT_GESTURE_PINCH_TIMEOUT) &&
-	    tp_gesture_is_pinch(tp)) {
-		tp_gesture_handle_event(tp, GESTURE_EVENT_PINCH, time);
-		return;
+	raw = tp_get_average_touches_delta(tp, time);
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD)) {
+		raw = tp_lock_for_scroll(tp, time, raw);
+		raw = tp_mean_filter_for_scroll(tp, time, raw);
+		if (tp->nactive_slots == 2) {
+			raw = tp_edge_aft_for_scroll(tp, time, raw);
+		}
+		if (tp->axis_speed_gain.use_gain) {
+			raw.x = tp->axis_speed_gain.gain * raw.x;
+			raw.y = tp->axis_speed_gain.gain * raw.y;
+		}
 	}
 
-	raw = tp_get_average_touches_delta(tp);
-
 	/* scroll is not accelerated by default */
 	delta = tp_filter_scroll(tp, &raw, time);
 
@@ -1184,20 +1678,180 @@
 
 	tp_gesture_start(tp, time);
 	tp_gesture_apply_scroll_constraints(tp, &raw, &delta, time);
+
+	/* We may confuse a pinch for a scroll initially,
+	 * allow ourselves to correct our guess.
+	 */
+	if (time < (tp->gesture.initial_time + DEFAULT_GESTURE_PINCH_TIMEOUT)) {
+		if (normalized_is_zero(tp->scroll.scroll_delta)) {
+			tp->scroll.scroll_delta.x = delta.x;
+			tp->scroll.scroll_delta.y = delta.y;
+		}
+		/* When the two fingers slide rapidly and repeatedly, 
+		 * it is easy to recognize as pinching. This scene is blocked here*/
+		if ((tp->scroll.scroll_delta.x > 0 && delta.x < 0) ||
+			(tp->scroll.scroll_delta.x < 0 && delta.x > 0) ||
+			(tp->scroll.scroll_delta.y > 0 && delta.y < 0) ||
+			(tp->scroll.scroll_delta.y < 0 && delta.y > 0)) {
+			tp->scroll.correct_pinch_flag = true;
+		}
+	    if (tp_gesture_is_pinch(tp) && !(tp->scroll.correct_pinch_flag)) {
+			evdev_log_libinput_info(tp->device, "correct scroll to pinch");
+			tp_gesture_handle_event(tp, GESTURE_EVENT_PINCH, time);
+			return;
+		}
+	}
+
 	evdev_post_scroll(tp->device,
 			  time,
 			  LIBINPUT_POINTER_AXIS_SOURCE_FINGER,
 			  &delta);
 }
 
+static double
+calculate_cosine_similarity(struct tp_dispatch *tp, struct device_coords *delta1, struct device_coords *delta2)
+{
+
+	double dx1 = delta1->x;
+	double dy1 = delta1->y;
+	double dx2 = delta2->x;
+	double dy2 = delta2->y;
+
+	double dist1 = sqrt(dx1 * dx1 + dy1 * dy1);
+	double dist2 = sqrt(dx2 * dx2 + dy2 * dy2);
+
+	if (dist1 < 1 && dist2 < 1) {
+		return 0.0;
+	}
+	double ret = (dx1 * dx2 + dy1 * dy2) / (dist1 * dist2);
+
+	return ret;
+}
+
+static double
+calculate_finger_speed(struct tp_dispatch *tp, struct device_coords *curr_coord, struct device_coords *pre_coord)
+{
+	int delta_x = curr_coord->x - pre_coord->x;
+	int delta_y = curr_coord->y - pre_coord->y;
+
+	return sqrt(delta_x * delta_x + delta_y * delta_y);
+}
+
+struct gesture_device_coords {
+	struct device_coords coords[5];
+	int coords_len;
+};
+
+#define FINGER_COUNT_MAX 5
+static struct gesture_device_coords *
+get_gesture_device_coords(void)
+{
+	static struct gesture_device_coords gesture_coords = {
+		{{0, 0},
+		{0, 0},
+		{0, 0},
+		{0, 0},
+		{0, 0},},
+		FINGER_COUNT_MAX
+	};
+
+	return &gesture_coords;
+}
+
+static void 
+updata_gesture_device_coords(struct device_coords *coords, int coords_len)
+{
+	struct gesture_device_coords * gesture_coords = get_gesture_device_coords();
+	memcpy(gesture_coords->coords, coords, coords_len * sizeof(struct device_coords));
+	gesture_coords->coords_len = coords_len;
+}
+
+static void 
+reset_gesture_device_coords(void)
+{
+	struct gesture_device_coords * gesture_coords = get_gesture_device_coords();
+	memset(gesture_coords->coords, 0, FINGER_COUNT_MAX * sizeof(struct device_coords));
+	gesture_coords->coords_len = FINGER_COUNT_MAX;
+}
+
+#define FOUR_FINGER_SIMILAR_CNT 6
+#define THREE_FINGER_SIMILAR_CNT 3
+static bool
+calculate_swipe_cosine_similarity(struct tp_dispatch *tp, struct device_coords *coords, int coordsLen)
+{
+	// 3 or 4 finger
+	double similaritys[FOUR_FINGER_SIMILAR_CNT] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
+	if (coordsLen == 3 || coordsLen == 4) {
+		uint idx = 0;
+		for (int i = 0; i < coordsLen; i++) {
+			for (int j = i + 1; j < coordsLen; j++) {
+				similaritys[idx] = calculate_cosine_similarity(tp, &coords[i], &coords[j]);
+				idx++;
+			}
+		}
+	} else {
+		return 0.0;
+	}
+
+	int similarity_count = 0;
+	double sum = 0.0;
+	double ave = 0.0;
+	double variance = 0.0;
+
+	similarity_count = (coordsLen == 4) ? FOUR_FINGER_SIMILAR_CNT : THREE_FINGER_SIMILAR_CNT;
+	for (int i = 0; i < similarity_count; i++) {
+		sum += similaritys[i];
+	}
+	ave = sum / similarity_count;
+
+	// Calculate  variance
+	for (int i = 0; i < similarity_count; i++) {
+		variance += pow(similaritys[i] - ave, 2) / similarity_count;
+	}
+
+	// variance <= 0.001 are the same direction
+	return variance < 0.001 ? true : false;
+}
+
+static void
+tp_gesture_handle_state_swipe_private(struct tp_dispatch *tp, uint64_t time)
+{
+	struct device_float_coords raw;
+	struct normalized_coords delta, unaccel;
+
+	raw = tp_get_average_touches_delta(tp, time);
+	delta = tp_filter_motion(tp, &raw, time);
+
+	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
+		unaccel = tp_normalize_delta(tp, raw);
+		tp_gesture_start(tp, time);
+
+		struct device_coords coords[5];
+		for (uint32_t i = 0; i < tp->nfingers_down; i++) {
+			coords[i] = tp->touches[i].point;
+		}
+
+		if (calculate_swipe_cosine_similarity(tp, coords, tp->nfingers_down) == false) {
+			evdev_log_error(tp->device, "libinput gesture is unknown.");
+		}
+
+		gesture_notify_swipe_private(&tp->device->base, time,
+				     LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+				     tp->gesture.finger_count,
+				     &delta, &unaccel, coords, tp->nfingers_down);
+	}
+}
+
 static void
 tp_gesture_handle_state_swipe(struct tp_dispatch *tp, uint64_t time)
 {
 	struct device_float_coords raw;
+	struct sloted_coords_info raw_touches = {};
 	struct normalized_coords delta, unaccel;
 
-	raw = tp_get_average_touches_delta(tp);
+	raw = tp_get_average_touches_delta(tp, time);
 	delta = tp_filter_motion(tp, &raw, time);
+	tp_get_raw_touches(tp, &raw_touches, time);
 
 	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
 		unaccel = tp_filter_motion_unaccelerated(tp, &raw, time);
@@ -1205,7 +1859,31 @@
 		gesture_notify_swipe(&tp->device->base, time,
 				     LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
 				     tp->gesture.finger_count,
-				     &delta, &unaccel);
+				     &delta, &unaccel, &raw_touches);
+	}
+}
+
+static void
+tp_edge_aft_for_pinch(struct tp_dispatch *tp, uint64_t time, double *scale, double *angle_delta)
+{
+    double width, height;
+    evdev_device_get_size(tp->device, &width, &height);
+    struct phys_coords mm = { 20.0, 20.0 };
+
+	if (tp->gesture.touches[0] == NULL || tp->gesture.touches[1] == NULL) {
+		return;
+	}
+    struct device_coords first = tp->gesture.touches[0]->point;
+    struct device_coords second = tp->gesture.touches[1]->point;
+
+    struct phys_coords first_mm = evdev_device_units_to_mm(tp->device, &first);
+    struct phys_coords second_mm = evdev_device_units_to_mm(tp->device, &second);
+
+	if ((first_mm.x < mm.x && second_mm.x > width - mm.x) ||
+		(first_mm.x > width - mm.x && second_mm.x < mm.x)) {
+		evdev_log_libinput_info(tp->device, "Fingers on the edge to inhibit finger pinching");
+		*scale = 0.0;
+		*angle_delta = 0.0;
 	}
 }
 
@@ -1227,6 +1905,11 @@
 	else if (angle_delta < -180.0)
 		angle_delta += 360.0;
 
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD) &&
+		tp->gesture.finger_count == 2) {
+		tp_edge_aft_for_pinch(tp, time, &scale, &angle_delta);
+	}
+
 	fdelta = device_float_delta(center, tp->gesture.center);
 	tp->gesture.center = center;
 
@@ -1269,14 +1952,14 @@
 		tp_gesture_handle_state_scroll(tp, time);
 
 	if (tp->gesture.state == GESTURE_STATE_SWIPE)
-		tp_gesture_handle_state_swipe(tp, time);
+		tp_gesture_handle_state_swipe_private(tp, time);
 
 	if (tp->gesture.state == GESTURE_STATE_PINCH)
 		tp_gesture_handle_state_pinch(tp, time);
 }
 
 static bool
-tp_gesture_thumb_moved(struct tp_dispatch *tp)
+tp_gesture_thumb_moved(struct tp_dispatch *tp, uint64_t time)
 {
 	struct tp_touch *thumb;
 	struct phys_coords thumb_moved;
@@ -1286,7 +1969,7 @@
 	if (!thumb)
 		return false;
 
-	if (!tp_touch_active_for_gesture(tp, thumb))
+	if (!tp_touch_active_for_gesture(tp, thumb, time))
 		return false;
 
 	thumb_moved = tp_gesture_mm_moved(tp, thumb);
@@ -1305,9 +1988,10 @@
 	 * physical button is down, don't allow gestures unless the button
 	 * is held down by a *thumb*, specifically.
 	 */
-	if (tp_tap_dragging(tp) ||
+	if (tp_tap_dragging(tp) || (tp->gesture.moved_count == 1 && tp->nfingers_down > 2) ||
 	    (tp->buttons.is_clickpad && tp->buttons.state &&
-	     tp->thumb.state == THUMB_STATE_FINGER)) {
+	    ((tp->thumb.state == THUMB_STATE_FINGER && tp->nfingers_down == 1) ||
+		 (tp->nfingers_down == 2)))) {
 		if (tp->gesture.state != GESTURE_STATE_POINTER_MOTION) {
 			tp_gesture_cancel(tp, time);
 			tp_gesture_handle_event(tp,
@@ -1326,9 +2010,13 @@
 	 * so we may suppress it too early. Give it some time to move.
 	 */
 	if (time < (tp->gesture.initial_time + DEFAULT_GESTURE_PINCH_TIMEOUT) &&
-	    tp_gesture_thumb_moved(tp))
+	    tp_gesture_thumb_moved(tp, time))
 		tp_thumb_reset(tp);
 
+	if (tp->buttons.is_clickpad && tp->buttons.state &&
+             tp->thumb.state == THUMB_STATE_FINGER && tp->nfingers_down > 2)
+		return;
+
 	if (tp->gesture.finger_count <= 4)
 		tp_gesture_post_gesture(tp, time, ignore_motion);
 }
@@ -1345,10 +2033,51 @@
 }
 
 static void
+tp_init_scroll_lock(struct tp_dispatch *tp)
+{
+	tp->scroll_idle_lock[0].state = SCROLL_LOCK_STATE_UNLOCKED;
+	tp->scroll_idle_lock[0].judge_start_time = 0;
+	tp->scroll_idle_lock[0].judge_moved = 0.0;
+	tp->scroll_idle_lock[0].lock_moved = 0.0;
+
+	tp->scroll_idle_lock[1].state = SCROLL_LOCK_STATE_UNLOCKED;
+	tp->scroll_idle_lock[1].judge_start_time = 0;
+	tp->scroll_idle_lock[1].judge_moved = 0.0;
+	tp->scroll_idle_lock[1].lock_moved = 0.0;
+
+	tp->scroll_direction_lock[0].state = SCROLL_LOCK_STATE_UNLOCKED;
+	tp->scroll_direction_lock[0].direction = 0;
+	tp->scroll_direction_lock[0].judge_moved = 0.0;
+	tp->scroll_direction_lock[0].lock_moved = 0.0;
+	tp->scroll_direction_lock[0].last_moved = 0.0;
+
+	tp->scroll_direction_lock[1].state = SCROLL_LOCK_STATE_UNLOCKED;
+	tp->scroll_direction_lock[1].direction = 0;
+	tp->scroll_direction_lock[1].judge_moved = 0.0;
+	tp->scroll_direction_lock[1].lock_moved = 0.0;
+	tp->scroll_direction_lock[1].last_moved = 0.0;
+}
+
+static void
+tp_init_pointer_motion_lock(struct tp_dispatch *tp)
+{
+	tp->pointer_motion_lock.state = POINTER_MOTION_LOCK_STATE_UNLOCKED;
+	tp->pointer_motion_lock.judge_start_time = 0;
+	tp->pointer_motion_lock.judge_moved.x = 0.0;
+	tp->pointer_motion_lock.judge_moved.y = 0.0;
+	tp->pointer_motion_lock.lock_moved.x = 0.0;
+	tp->pointer_motion_lock.lock_moved.y = 0.0;
+	tp->pointer_motion_lock.last_moved.x = 0.0;
+	tp->pointer_motion_lock.last_moved.y = 0.0;
+}
+
+static void
 tp_gesture_end(struct tp_dispatch *tp, uint64_t time, bool cancelled)
 {
 	enum tp_gesture_state state = tp->gesture.state;
-
+	if (state == GESTURE_STATE_POINTER_MOTION) {
+		tp_init_pointer_motion_lock(tp);
+	}
 	if (!tp->gesture.started) {
 		tp_gesture_handle_event(tp, GESTURE_EVENT_RESET, time);
 		return;
@@ -1368,6 +2097,7 @@
 		break;
 	case GESTURE_STATE_SCROLL:
 		tp_gesture_stop_twofinger_scroll(tp, time);
+		tp_init_scroll_lock(tp);
 		break;
 	case GESTURE_STATE_PINCH:
 		gesture_notify_pinch_end(&tp->device->base, time,
@@ -1425,11 +2155,37 @@
 tp_gesture_handle_state(struct tp_dispatch *tp, uint64_t time)
 {
 	unsigned int active_touches = 0;
+	unsigned int moved_touches = 0;
 	struct tp_touch *t;
+	struct device_coords delta;
+	double delta_mm;
 
 	tp_for_each_touch(tp, t) {
-		if (tp_touch_active_for_gesture(tp, t))
+		if (tp_touch_active_for_gesture(tp, t, time)) {
 			active_touches++;
+			delta = tp_get_delta(t);
+			delta_mm = hypot(delta.x, delta.y);
+			if (delta_mm > 1.5)
+				moved_touches ++;
+		}			
+	}
+
+	if (moved_touches != tp->gesture.moved_count) {
+		if (tp->gesture.started && tp->gesture.finger_count > 2 && 
+			(tp->gesture.state == GESTURE_STATE_SWIPE || tp->gesture.state == GESTURE_STATE_PINCH)) {
+			tp->gesture.moved_count = tp->gesture.finger_count;
+		} else if (tp->gesture.started && tp->gesture.finger_count == 2 && 
+			(tp->gesture.state == GESTURE_STATE_SCROLL || tp->gesture.state == GESTURE_STATE_PINCH)) {
+			tp->gesture.moved_count = tp->gesture.finger_count;
+		} else {
+			tp->gesture.moved_count = moved_touches;
+		}
+	}
+
+	static uint64_t time_start = (uint64_t)(-1);
+	time_start = time_start < time ? time_start : time;
+	if (tp->gesture.finger_count == 0 && active_touches > 0) {
+		time_start = time;
 	}
 
 	if (active_touches != tp->gesture.finger_count) {
@@ -1438,6 +2194,14 @@
 			tp_gesture_stop(tp, time);
 			tp->gesture.finger_count = 0;
 			tp->gesture.finger_count_pending = 0;
+		} else if (tp->gesture.finger_count < active_touches &&
+			time - time_start < TIME_GESTURE_WAIT_ALL_FINGER_DOWN) {
+			tp_gesture_cancel(tp, time);
+			tp->gesture.finger_count = active_touches;
+		/* Do not change touchpad multi-finger gesture when finger count change(>1) util finger count <=1  */
+		} else if (tp->gesture.started && tp->gesture.finger_count > 2 && active_touches >1 &&
+			(tp->gesture.state == GESTURE_STATE_SWIPE || tp->gesture.state == GESTURE_STATE_PINCH)) {
+			return;
 		/* Immediately switch to new mode to avoid initial latency */
 		} else if (!tp->gesture.started) {
 			tp->gesture.finger_count = active_touches;
@@ -1446,13 +2210,17 @@
 			 * NONE to re-evaluate leftmost and rightmost touches
 			 */
 			if (tp->gesture.state == GESTURE_STATE_UNKNOWN ||
-			    tp->gesture.state == GESTURE_STATE_POINTER_MOTION) {
+			    tp->gesture.state == GESTURE_STATE_POINTER_MOTION ||
+			    tp->gesture.state == GESTURE_STATE_SCROLL) {
 				tp_gesture_handle_event(tp,
 							GESTURE_EVENT_RESET,
 							time);
 			}
 		/* Else debounce finger changes */
 		} else if (active_touches != tp->gesture.finger_count_pending) {
+			if (tp->gesture.started && tp->gesture.finger_count == 2 && active_touches > 2) {
+				return;
+			}
 			tp->gesture.finger_count_pending = active_touches;
 			libinput_timer_set(&tp->gesture.finger_count_switch_timer,
 				time + DEFAULT_GESTURE_SWITCH_TIMEOUT);
@@ -1504,6 +2272,41 @@
 	       LIBINPUT_CONFIG_HOLD_DISABLED;
 }
 
+static void
+tp_init_press_and_drag(struct tp_dispatch *tp)
+{
+	double width, height;
+	struct phys_coords mm = { 0.0, 0.0 };
+	struct device_coords device_unit;
+
+	evdev_device_get_size(tp->device, &width, &height);
+
+	/* press-and-drag left edge is 5% of the width */
+	mm.x = width * 0.05;
+	device_unit = evdev_device_mm_to_units(tp->device, &mm);
+	tp->press_and_drag.left_edge = device_unit.x;
+
+	/* press-and-drag right edge is 5% of the width */
+	mm.x = width - width * 0.05;
+	device_unit = evdev_device_mm_to_units(tp->device, &mm);
+	tp->press_and_drag.right_edge = device_unit.x;
+
+	/* press-and-drag upper edge is 8% of the height */
+	mm.y = height * 0.08;
+	device_unit = evdev_device_mm_to_units(tp->device, &mm);
+	tp->press_and_drag.upper_edge = device_unit.y;
+
+	/* press-and-drag lower edge is 5% of the height */
+	mm.y = height - height * 0.05;
+	device_unit = evdev_device_mm_to_units(tp->device, &mm);
+	tp->press_and_drag.lower_edge = device_unit.y;
+
+	/* press-and-drag speed is 20% of the diagonal per second */
+	mm.x = hypot(width, height) * 0.2;
+	device_unit = evdev_device_mm_to_units(tp->device, &mm);
+	tp->press_and_drag.speed = (double)device_unit.x / s2us(1);
+}
+
 void
 tp_init_gesture(struct tp_dispatch *tp)
 {
@@ -1539,6 +2342,10 @@
 			    tp_libinput_context(tp),
 			    timer_name,
 			    tp_gesture_hold_timeout, tp);
+
+	tp_init_press_and_drag(tp);
+	tp_init_pointer_motion_lock(tp);
+	tp_init_scroll_lock(tp);
 }
 
 void
diff -Naur old/src/evdev-mt-touchpad-tap.c new/src/evdev-mt-touchpad-tap.c
--- old/src/evdev-mt-touchpad-tap.c	2025-03-26 11:12:53.945121848 +0800
+++ new/src/evdev-mt-touchpad-tap.c	2025-03-26 11:16:26.426458791 +0800
@@ -30,6 +30,7 @@
 #include "evdev-mt-touchpad.h"
 
 #define DEFAULT_TAP_TIMEOUT_PERIOD ms2us(180)
+#define DEFAULT_DOUBLE_TAP_TIMEOUT_PERIOD ms2us(61)
 #define DEFAULT_DRAG_TIMEOUT_PERIOD_BASE ms2us(160)
 #define DEFAULT_DRAG_TIMEOUT_PERIOD_PERFINGER ms2us(20)
 #define DEFAULT_DRAGLOCK_TIMEOUT_PERIOD ms2us(300)
@@ -88,6 +89,8 @@
 	CASE_RETURN_STRING(TAP_STATE_2FGTAP_DRAGGING_2);
 	CASE_RETURN_STRING(TAP_STATE_3FGTAP_DRAGGING_2);
 	CASE_RETURN_STRING(TAP_STATE_DEAD);
+	CASE_RETURN_STRING(TAP_STATE_HOLDING);
+	CASE_RETURN_STRING(TAP_STATE_DOUBLE_TAP);
 	}
 	return NULL;
 }
@@ -125,6 +128,10 @@
 	      int nfingers,
 	      enum libinput_button_state state)
 {
+	if (tp->tap.state == TAP_STATE_IDLE) {
+		return;
+	}
+
 	int32_t button;
 	int32_t button_map[2][3] = {
 		{ BTN_LEFT, BTN_RIGHT, BTN_MIDDLE },
@@ -136,14 +143,23 @@
 	if (nfingers < 1 || nfingers > 3)
 		return;
 
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD) &&
+	    tp_touch_tool_palm_num(tp) >= 2) {
+			return;
+		}
+
 	button = button_map[tp->tap.map][nfingers - 1];
 
+	if (tp->device->key_count[button] == 0 &&
+		state == LIBINPUT_BUTTON_STATE_RELEASED)
+		return;
+
 	if (state == LIBINPUT_BUTTON_STATE_PRESSED)
 		tp->tap.buttons_pressed |= bit(nfingers);
 	else
 		tp->tap.buttons_pressed &= ~bit(nfingers);
 
-	evdev_pointer_notify_button(tp->device,
+	evdev_pointer_notify_tap(tp->device,
 				    time,
 				    button,
 				    state);
@@ -156,6 +172,12 @@
 }
 
 static void
+tp_double_tap_set_timer(struct tp_dispatch *tp, uint64_t time)
+{
+	libinput_timer_set(&tp->tap.timer, time + DEFAULT_DOUBLE_TAP_TIMEOUT_PERIOD);
+}
+
+static void
 tp_tap_set_drag_timer(struct tp_dispatch *tp, uint64_t time,
 		      int nfingers_tapped)
 {
@@ -231,6 +253,10 @@
 		tp_tap_set_timer(tp, time);
 		break;
 	case TAP_EVENT_RELEASE:
+		if (tp->buttons.is_clickpad && (tp->buttons.state || (tp->queued & TOUCHPAD_EVENT_BUTTON_RELEASE))) {
+			tp->tap.state = TAP_STATE_IDLE;
+			break;
+		}
 		tp_tap_notify(tp,
 			      tp->tap.saved_press_time,
 			      1,
@@ -264,6 +290,10 @@
 		tp->tap.nfingers_down--;
 		t->tap.state = TAP_TOUCH_STATE_DEAD;
 		tp_tap_clear_timer(tp);
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_PRESSED);
 		break;
 	case TAP_EVENT_PALM:
 		tp->tap.state = TAP_STATE_IDLE;
@@ -290,8 +320,48 @@
 		tp->tap.state = TAP_STATE_IDLE;
 		break;
 	case TAP_EVENT_MOTION:
+		tp->tap.state = TAP_STATE_HOLDING;
+		break;
+	case TAP_EVENT_TIMEOUT:
+		break;
+	case TAP_EVENT_BUTTON:
+		tp->tap.state = TAP_STATE_DEAD;
+		break;
+	case TAP_EVENT_THUMB:
+		tp->tap.state = TAP_STATE_IDLE;
+		t->tap.is_thumb = true;
+		tp->tap.nfingers_down--;
+		t->tap.state = TAP_TOUCH_STATE_DEAD;
+		break;
+	case TAP_EVENT_PALM:
+		tp->tap.state = TAP_STATE_IDLE;
+		break;
+	case TAP_EVENT_PALM_UP:
+		break;
+	}
+	if ((tp->tap.state != TAP_STATE_HOLDING) && (tp->tap.state != TAP_STATE_HOLD)) {
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_RELEASED);
+	}
+}
+
+static void
+tp_tap_holding_handle_event(struct tp_dispatch *tp,
+			    struct tp_touch *t,
+			    enum tap_event event, uint64_t time)
+{
+
+	switch (event) {
+	case TAP_EVENT_TOUCH:
 		tp_tap_move_to_dead(tp, t);
 		break;
+	case TAP_EVENT_RELEASE:
+		tp->tap.state = TAP_STATE_IDLE;
+		break;
+	case TAP_EVENT_MOTION:
+		break;
 	case TAP_EVENT_TIMEOUT:
 		break;
 	case TAP_EVENT_BUTTON:
@@ -309,6 +379,40 @@
 	case TAP_EVENT_PALM_UP:
 		break;
 	}
+	if (tp->tap.state != TAP_STATE_HOLDING) {
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_RELEASED);
+    }
+}
+
+static void
+tp_tap_double_tapped_handle_event(struct tp_dispatch *tp,
+			   struct tp_touch *t,
+			   enum tap_event event, uint64_t time)
+{
+	switch (event) {
+	case TAP_EVENT_MOTION:
+	case TAP_EVENT_RELEASE:
+	case TAP_EVENT_TOUCH: 
+	case TAP_EVENT_BUTTON:
+	case TAP_EVENT_THUMB:
+	case TAP_EVENT_PALM:
+	case TAP_EVENT_PALM_UP:
+		break;
+	case TAP_EVENT_TIMEOUT:
+		tp_tap_notify(tp,
+				tp->tap.saved_press_time,
+				1,
+				LIBINPUT_BUTTON_STATE_PRESSED);
+		tp_tap_notify(tp,
+				tp->tap.saved_release_time,
+				1,
+				LIBINPUT_BUTTON_STATE_RELEASED);
+		tp->tap.state = TAP_STATE_IDLE;
+		break;
+	}
 }
 
 static void
@@ -332,14 +436,19 @@
 		tp->tap.state = dest[nfingers_tapped - 1];
 		tp->tap.saved_press_time = time;
 		tp_tap_set_timer(tp, time);
+		if (nfingers_tapped == 1 && t != NULL) {
+			struct tp_touch *t1 = &tp->touches[0];
+			t1->pinned.is_pinned_edge_dragging = true;
+			t1->pinned.center = t->point;
+		}
 		break;
 	}
 	case TAP_EVENT_TIMEOUT:
-		tp->tap.state = TAP_STATE_IDLE;
 		tp_tap_notify(tp,
 			      tp->tap.saved_release_time,
 			      nfingers_tapped,
 			      LIBINPUT_BUTTON_STATE_RELEASED);
+		tp->tap.state = TAP_STATE_IDLE;
 		break;
 	case TAP_EVENT_BUTTON:
 		tp->tap.state = TAP_STATE_DEAD;
@@ -443,19 +552,23 @@
 		tp_tap_clear_timer(tp);
 		break;
 	case TAP_EVENT_RELEASE:
-		tp_tap_notify(tp,
-			      tp->tap.saved_press_time,
-			      2,
-			      LIBINPUT_BUTTON_STATE_PRESSED);
-		if (tp->tap.drag_enabled) {
-			tp->tap.state = TAP_STATE_2FGTAP_TAPPED;
-			tp_tap_set_drag_timer(tp, time, 2);
+		if (tp_edge_aft_for_tow_finger(tp, time)) {
+			tp->tap.state = TAP_STATE_IDLE;
 		} else {
 			tp_tap_notify(tp,
-				      tp->tap.saved_release_time,
-				      2,
-				      LIBINPUT_BUTTON_STATE_RELEASED);
-			tp->tap.state = TAP_STATE_IDLE;
+			    tp->tap.saved_press_time,
+			    2,
+			    LIBINPUT_BUTTON_STATE_PRESSED);
+			if (tp->tap.drag_enabled && !evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD)) {
+				tp->tap.state = TAP_STATE_2FGTAP_TAPPED;
+				tp_tap_set_drag_timer(tp, time, 2);
+			} else {
+				tp_tap_notify(tp,
+					tp->tap.saved_release_time,
+					2,
+					LIBINPUT_BUTTON_STATE_RELEASED);
+				tp->tap.state = TAP_STATE_IDLE;
+			}
 		}
 		break;
 	case TAP_EVENT_MOTION:
@@ -498,6 +611,35 @@
 	}
 }
 
+static bool
+tp_edge_aft_for_tow_finger(struct tp_dispatch *tp, uint64_t time)
+{
+    double width, height;
+    evdev_device_get_size(tp->device, &width, &height);
+    struct phys_coords mm = { 15.0, 15.0 };
+
+	if (tp->gesture.touches[0] == NULL || tp->gesture.touches[1] == NULL) {
+		return false;
+	}
+    struct device_coords first = tp->gesture.touches[0]->point;
+    struct device_coords second = tp->gesture.touches[1]->point;
+
+    struct phys_coords first_mm = evdev_device_units_to_mm(tp->device, &first);
+    struct phys_coords second_mm = evdev_device_units_to_mm(tp->device, &second);
+
+	if (first_mm.x < mm.x || first_mm.x > width - mm.x || second_mm.x < mm.x || second_mm.x > width - mm.x) {
+		struct phys_coords delta_mm;
+        delta_mm.x = fabs(first_mm.x - second_mm.x);
+		delta_mm.y = fabs(first_mm.y - second_mm.y);
+		double distance_mm = hypot(delta_mm.x, delta_mm.y);
+		if (distance_mm > 0.5 * width) {
+			evdev_log_libinput_info(tp->device, "fingers on the edge, distance:%lf", distance_mm);
+			return true;
+		}
+	}
+	return false;
+}
+
 static void
 tp_tap_touch3_handle_event(struct tp_dispatch *tp,
 			   struct tp_touch *t,
@@ -749,17 +891,13 @@
 		break;
 	}
 	case TAP_EVENT_RELEASE:
-		tp->tap.state = TAP_STATE_1FGTAP_TAPPED;
+		tp->tap.state = TAP_STATE_DOUBLE_TAP;
 		tp_tap_notify(tp,
 			      tp->tap.saved_release_time,
 			      nfingers_tapped,
 			      LIBINPUT_BUTTON_STATE_RELEASED);
-		tp_tap_notify(tp,
-			      tp->tap.saved_press_time,
-			      1,
-			      LIBINPUT_BUTTON_STATE_PRESSED);
 		tp->tap.saved_release_time = time;
-		tp_tap_set_timer(tp, time);
+		tp_double_tap_set_timer(tp, time);
 		break;
 	case TAP_EVENT_MOTION:
 	case TAP_EVENT_TIMEOUT: {
@@ -1143,6 +1281,12 @@
 	case TAP_STATE_DEAD:
 		tp_tap_dead_handle_event(tp, t, event, time);
 		break;
+	case TAP_STATE_HOLDING:
+		tp_tap_holding_handle_event(tp, t, event, time);
+		break;
+	case TAP_STATE_DOUBLE_TAP:
+		tp_tap_double_tapped_handle_event(tp, t, event, time);
+		break;
 	}
 
 	if (tp->tap.state == TAP_STATE_IDLE || tp->tap.state == TAP_STATE_DEAD)
@@ -1186,7 +1330,7 @@
 	if (tp->semi_mt && tp->nfingers_down != tp->old_nfingers_down)
 		return false;
 
-	return length_in_mm(mm) > DEFAULT_TAP_MOVE_THRESHOLD;
+	return fabs(mm.x) > DEFAULT_TAP_MOVE_THRESHOLD || fabs(mm.y) > DEFAULT_TAP_MOVE_THRESHOLD;
 }
 
 static bool
@@ -1294,6 +1438,8 @@
 	 */
 	switch (tp->tap.state) {
 	case TAP_STATE_TOUCH:
+		filter_motion = 0;
+		break;
 	case TAP_STATE_1FGTAP_TAPPED:
 	case TAP_STATE_2FGTAP_TAPPED:
 	case TAP_STATE_3FGTAP_TAPPED:
@@ -1419,23 +1565,7 @@
 static enum libinput_config_tap_state
 tp_tap_default(struct evdev_device *evdev)
 {
-	/**
-	 * If we don't have a left button we must have tapping enabled by
-	 * default.
-	 */
-	if (!libevdev_has_event_code(evdev->evdev, EV_KEY, BTN_LEFT))
-		return LIBINPUT_CONFIG_TAP_ENABLED;
-
-	/**
-	 * Tapping is disabled by default for two reasons:
-	 * * if you don't know that tapping is a thing (or enabled by
-	 *   default), you get spurious mouse events that make the desktop
-	 *   feel buggy.
-	 * * if you do know what tapping is and you want it, you
-	 *   usually know where to enable it, or at least you can search for
-	 *   it.
-	 */
-	return LIBINPUT_CONFIG_TAP_DISABLED;
+	return LIBINPUT_CONFIG_TAP_ENABLED;
 }
 
 static enum libinput_config_tap_state
@@ -1499,7 +1629,7 @@
 static inline enum libinput_config_drag_state
 tp_drag_default(struct evdev_device *device)
 {
-	return LIBINPUT_CONFIG_DRAG_ENABLED;
+	return LIBINPUT_CONFIG_DRAG_DISABLED;
 }
 
 static enum libinput_config_drag_state
@@ -1661,3 +1791,63 @@
 		return false;
 	}
 }
+
+void
+tp_tap_original_down(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	struct evdev_device *device = tp->device;
+	int slot_idx = tp->slot;
+	int seat_slot = t->seat_slot;
+	int32_t pressure = t->pressure;
+	int tool_type = t->tool_type;
+	struct device_coords point;
+	struct device_coord_rect rect;
+	point = t->point;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	rect = t->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touchpad_notify_touch_down(base, time, slot_idx, seat_slot, pressure, tool_type, axis, &point, &rect);
+}
+
+void
+tp_tap_original_up(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	int slot_idx = tp->slot;
+	int seat_slot = t->seat_slot;
+	t->seat_slot = -1;
+	int tool_type = t->tool_type;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	touchpad_notify_touch_up(base, time, slot_idx, seat_slot, tool_type, axis);
+}
+
+void
+tp_tap_original_motion(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	struct evdev_device *device = tp->device;
+	int seat_slot = t->seat_slot;
+	int slot_idx = tp->slot;
+	int32_t pressure = t->pressure;
+	int tool_type = t->tool_type;
+	struct device_coords point;
+    struct device_coord_rect rect;
+	point = t->point;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	rect = t->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touchpad_notify_touch_motion(base, time, slot_idx, seat_slot, pressure, tool_type, axis, &point, &rect);
+}
\ No newline at end of file
diff -Naur old/src/evdev-mt-touchpad-thumb.c new/src/evdev-mt-touchpad-thumb.c
--- old/src/evdev-mt-touchpad-thumb.c	2025-03-26 11:12:53.945121848 +0800
+++ new/src/evdev-mt-touchpad-thumb.c	2025-03-26 11:16:26.434458838 +0800
@@ -114,7 +114,7 @@
 static bool
 tp_thumb_needs_jail(const struct tp_dispatch *tp, const struct tp_touch *t)
 {
-	if (t->point.y < tp->thumb.upper_thumb_line ||
+	if (t->point.y <= tp->thumb.upper_thumb_line ||
 	    tp->scroll.method == LIBINPUT_CONFIG_SCROLL_EDGE)
 		return false;
 
@@ -360,7 +360,7 @@
 
 	if (newest &&
 	    (newest->initial_time - oldest->initial_time) < THUMB_TIMEOUT &&
-	    first->point.y < tp->thumb.lower_thumb_line) {
+	    first->point.y <= tp->thumb.lower_thumb_line) {
 		tp_thumb_lift(tp);
 		return;
 	}
@@ -409,11 +409,18 @@
 
 	/* detect thumbs by pressure in the bottom 15mm, detect thumbs by
 	 * lingering in the bottom 8mm */
-	mm.y = h * 0.85;
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD)) {
+		mm.y = h * 1;
+	} else {
+		mm.y = h * 0.85;
+	}
 	edges = evdev_device_mm_to_units(device, &mm);
 	tp->thumb.upper_thumb_line = edges.y;
-
-	mm.y = h * 0.92;
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD)) {
+		mm.y = h * 1;
+	} else {
+		mm.y = h * 0.92;
+	}
 	edges = evdev_device_mm_to_units(device, &mm);
 	tp->thumb.lower_thumb_line = edges.y;
 
diff -Naur old/src/evdev-mt-touchpad.c new/src/evdev-mt-touchpad.c
--- old/src/evdev-mt-touchpad.c	2025-03-26 11:12:53.945121848 +0800
+++ new/src/evdev-mt-touchpad.c	2025-03-26 11:16:26.434458838 +0800
@@ -38,7 +38,7 @@
 
 #define DEFAULT_TRACKPOINT_ACTIVITY_TIMEOUT ms2us(300)
 #define DEFAULT_TRACKPOINT_EVENT_TIMEOUT ms2us(40)
-#define DEFAULT_KEYBOARD_ACTIVITY_TIMEOUT_1 ms2us(200)
+#define DEFAULT_KEYBOARD_ACTIVITY_TIMEOUT_1 ms2us(400)
 #define DEFAULT_KEYBOARD_ACTIVITY_TIMEOUT_2 ms2us(500)
 #define FAKE_FINGER_OVERFLOW bit(7)
 #define THUMB_IGNORE_SPEED_THRESHOLD 20 /* mm/s */
@@ -330,6 +330,35 @@
 }
 
 static inline void
+tp_tool_key_set(struct tp_dispatch *tp,
+		   unsigned int code,
+		   bool is_press)
+{
+	unsigned int shift = 0;
+
+	switch (code) {
+		case BTN_TOOL_PEN:
+		case BTN_TOOL_RUBBER:
+		case BTN_TOOL_BRUSH:
+		case BTN_TOOL_PENCIL:
+		case BTN_TOOL_AIRBRUSH:
+		case BTN_TOOL_FINGER:
+		case BTN_TOOL_MOUSE:
+		case BTN_TOOL_LENS:
+			shift = code - BTN_TOOL_PEN;
+			break;
+		default:
+			return;
+	}
+
+	if (is_press) {
+		tp->tool_touches |= 0x1 << shift;
+	} else {
+		tp->tool_touches &= ~(0x1 << shift);
+	}
+}
+
+static inline void
 tp_new_touch(struct tp_dispatch *tp, struct tp_touch *t, uint64_t time)
 {
 	if (t->state == TOUCH_BEGIN ||
@@ -346,6 +375,8 @@
 		tp->nfingers_down++;
 		t->state = TOUCH_UPDATE;
 		t->has_ended = false;
+		evdev_log_libinput_info(tp->device,
+		    "nfingers_down: %d, TOUCH_MAYBE_END", tp->nfingers_down);
 		return;
 	}
 
@@ -359,10 +390,13 @@
 	t->palm.state = PALM_NONE;
 	t->state = TOUCH_HOVERING;
 	t->pinned.is_pinned = false;
+	t->pinned.is_pinned_edge_dragging = false;
 	t->speed.last_speed = 0;
 	t->speed.exceeded_count = 0;
 	t->hysteresis.x_motion_history = 0;
+	t->seat_slot = -1;
 	tp->queued |= TOUCHPAD_EVENT_MOTION;
+	evdev_log_libinput_info(tp->device, "tp_new_touch");
 }
 
 static inline void
@@ -371,6 +405,7 @@
 	t->dirty = true;
 	t->state = TOUCH_BEGIN;
 	t->initial_time = time;
+	t->first = t->point;
 	t->was_down = true;
 	tp->nfingers_down++;
 	t->palm.time = time;
@@ -448,10 +483,19 @@
 		return;
 	}
 
+	if (t->is_tool_palm) {
+		for (int i = 4; i > 0; i--) {
+			tp->history_tool_palm[i] = tp->history_tool_palm[i - 1];
+		}
+		tp->history_tool_palm[0].last = tp_motion_history_offset(t, 0)->point;
+		tp->history_tool_palm[0].last_time = time;
+	}
+
 	t->dirty = true;
 	t->palm.state = PALM_NONE;
 	t->state = TOUCH_END;
 	t->pinned.is_pinned = false;
+	t->pinned.is_pinned_edge_dragging = false;
 	t->palm.time = 0;
 	t->speed.exceeded_count = 0;
 	tp->queued |= TOUCHPAD_EVENT_MOTION;
@@ -515,6 +559,88 @@
 	return absinfo->maximum - (value - absinfo->minimum);
 }
 
+void tp_ext_post_event(struct tp_dispatch* dispatch, bool is_up, uint64_t time)
+{
+	struct tp_touch * t = tp_current_touch(dispatch);
+	int seat_slot = t->seat_slot;
+	if (is_up) {
+		if (seat_slot == -1) {
+			evdev_log_libinput_info(dispatch->device,
+			    "Report LIBINPUT_EVENT_TOUCHPAD_UP with code: %d but seat_slot = -1, seat_slot: %d",
+				LIBINPUT_EVENT_TOUCHPAD_UP, seat_slot);
+			return;
+		}
+
+		dispatch->orginal.active_slot_count--;
+		if (dispatch->orginal.active_slot_count < 0) {
+			dispatch->orginal.active_slot_count = 0;
+		}
+
+		if (dispatch->orginal.active_slot_count == 0) {
+			dispatch->orginal.seat_slot_id = 0;
+		}
+
+		tp_tap_original_up(dispatch, t, time);
+		evdev_log_libinput_info(dispatch->device,
+			"Report LIBINPUT_EVENT_TOUCHPAD_UP with code: %d, seat_slot:%d", LIBINPUT_EVENT_TOUCHPAD_UP, seat_slot);
+		return;
+	}
+
+	if (seat_slot == -1) {
+		t->seat_slot = dispatch->orginal.seat_slot_id++;
+		dispatch->orginal.active_slot_count++;
+
+		evdev_log_libinput_info(dispatch->device, "Report LIBINPUT_EVENT_TOUCHPAD_DOWN with code: %d, seat_slot: %d",
+			LIBINPUT_EVENT_TOUCHPAD_DOWN, t->seat_slot);
+		tp_tap_original_down(dispatch, t, time);
+		return;
+	}
+
+	tp_tap_original_motion(dispatch, t, time);
+}
+
+void tp_ext_on_xy_update(struct tp_dispatch* dispatch)
+{
+	dispatch->orginal.xy_updated = true;
+}
+
+void tp_ext_on_mt_slot(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
+void tp_ext_before_new_touch(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
+void tp_ext_before_delete_touch(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+	};
+
+	tp_ext_post_event(dispatch, true, time);
+}
+
+void tp_ext_on_sync(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
 static void
 tp_process_absolute(struct tp_dispatch *tp,
 		    const struct input_event *e,
@@ -524,6 +650,7 @@
 
 	switch(e->code) {
 	case ABS_MT_POSITION_X:
+		tp_ext_on_xy_update(tp);
 		evdev_device_check_abs_axis_range(tp->device,
 						  e->code,
 						  e->value);
@@ -532,6 +659,7 @@
 		tp->queued |= TOUCHPAD_EVENT_MOTION;
 		break;
 	case ABS_MT_POSITION_Y:
+		tp_ext_on_xy_update(tp);
 		evdev_device_check_abs_axis_range(tp->device,
 						  e->code,
 						  e->value);
@@ -540,14 +668,17 @@
 		tp->queued |= TOUCHPAD_EVENT_MOTION;
 		break;
 	case ABS_MT_SLOT:
+		tp_ext_on_mt_slot(tp, time);
 		tp->slot = e->value;
 		break;
 	case ABS_MT_TRACKING_ID:
 		if (e->value != -1) {
+			tp_ext_before_new_touch(tp, time);
 			tp->nactive_slots += 1;
 			tp_new_touch(tp, t, time);
 		} else {
 			assert(tp->nactive_slots >= 1);
+			tp_ext_before_delete_touch(tp, time);
 			tp->nactive_slots -= 1;
 			tp_end_sequence(tp, t, time);
 		}
@@ -559,6 +690,7 @@
 		break;
 	case ABS_MT_TOOL_TYPE:
 		t->is_tool_palm = e->value == MT_TOOL_PALM;
+		t->tool_type = e->value;
 		t->dirty = true;
 		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
 		break;
@@ -572,6 +704,26 @@
 		t->dirty = true;
 		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
 		break;
+	case ABS_MT_WIDTH_MAJOR:
+		t->tool_rect.w = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_WIDTH_MINOR:
+		t->tool_rect.h = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_TOOL_X:
+		t->tool_rect.x = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_TOOL_Y:
+		t->tool_rect.y = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
 	}
 }
 
@@ -776,6 +928,7 @@
 		case BTN_TOOL_QUADTAP:
 		case BTN_TOOL_QUINTTAP:
 			tp_fake_finger_set(tp, e->code, !!e->value);
+			evdev_log_libinput_info(tp->device, "e->code: %d, e->value: %d", e->code, e->value);
 			break;
 		case BTN_0:
 		case BTN_1:
@@ -783,6 +936,20 @@
 			tp_process_trackpoint_button(tp, e, time);
 			break;
 	}
+
+	switch (e->code) {
+		case BTN_TOOL_PEN:
+		case BTN_TOOL_RUBBER:
+		case BTN_TOOL_BRUSH:
+		case BTN_TOOL_PENCIL:
+		case BTN_TOOL_AIRBRUSH:
+		case BTN_TOOL_FINGER:
+		case BTN_TOOL_MOUSE:
+		case BTN_TOOL_LENS:
+			tp_tool_key_set(tp, e->code, !!e->value);
+		default:
+			break;
+	}
 }
 
 static void
@@ -812,7 +979,8 @@
 	mm = evdev_device_unit_delta_to_mm(tp->device, &delta);
 
 	/* 1.5mm movement -> unpin */
-	if (hypot(mm.x, mm.y) >= 1.5) {
+	if (hypot(mm.x, mm.y) >= 3.5) {
+		evdev_log_libinput_info(tp->device, "3.5mm movement -> unpin");
 		t->pinned.is_pinned = false;
 		return;
 	}
@@ -827,6 +995,10 @@
 		t->pinned.is_pinned = true;
 		t->pinned.center = t->point;
 	}
+	if (tp->nactive_slots == 1) {
+		t = &tp->touches[0];
+		t->pinned.is_pinned_edge_dragging = true;
+	}
 }
 
 bool
@@ -841,16 +1013,100 @@
 }
 
 bool
-tp_touch_active_for_gesture(const struct tp_dispatch *tp, const struct tp_touch *t)
+tp_touch_active_for_gesture(const struct tp_dispatch *tp, const struct tp_touch *t, uint64_t time)
 {
+	bool is_palm_none = t->palm.state == PALM_NONE;
+	/*
+	 * Loosen dwt restriction on Huawei FreeTouch touchpads.
+	 * Allow a dwt-palm to move the pointer if it has been lasting for some time.
+	 */
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD)) {
+		uint64_t timeThreshold = ms2us(100);
+		struct quirks_context *quirks;
+		struct quirks *q;
+		uint32_t value;
+		quirks = evdev_libinput_context(tp->device)->quirks;
+		q = quirks_fetch_for_device(quirks, tp->device->udev_device);
+		if (q && quirks_get_uint32(q, QUIRK_ATTR_DWT_POINTER_UNLOCK_TIME_THRESHOLD, &value)) {
+			timeThreshold = ms2us((uint64_t) value);
+		}
+		quirks_unref(q);
+		is_palm_none = t->palm.state == PALM_NONE ||
+					   (t->palm.state == PALM_TYPING && t->palm.time + timeThreshold < time);
+	}
+
 	return (t->state == TOUCH_BEGIN || t->state == TOUCH_UPDATE) &&
-		t->palm.state == PALM_NONE &&
+		is_palm_none &&
 		!t->pinned.is_pinned &&
-		!tp_thumb_ignored_for_gesture(tp, t) &&
 		tp_button_touch_active(tp, t) &&
 		tp_edge_scroll_touch_active(tp, t);
 }
 
+int
+tp_touch_tool_palm_num(const struct tp_dispatch *tp)
+{
+	int num = 0;
+	struct tp_touch *t;
+	unsigned int i;
+	for (i = 0; i < tp->num_slots; i++) {
+		t = &tp->touches[i];
+		if ((t->state == TOUCH_BEGIN || t->state == TOUCH_UPDATE) && t->is_tool_palm) {
+			num++;
+		}
+	}
+	return num;
+}
+
+bool
+tp_touch_unintended_touch_for_typing(const struct tp_dispatch *tp, const struct tp_touch *t, uint64_t time)
+{
+	bool is_unintended_touch = false;
+	if (t->state != TOUCH_BEGIN && t->state != TOUCH_UPDATE) {
+		return is_unintended_touch;
+	}
+
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD)) {
+		struct device_coords delta;
+		for (int i = 0; i < 5; i++) {
+			uint64_t last_time = tp->history_tool_palm[i].last_time;
+			struct device_coords last_point = tp->history_tool_palm[i].last;
+			delta.x = abs(t->first.x - last_point.x);
+			delta.y = abs(t->first.y - last_point.y);
+			struct phys_coords delta_mm = evdev_device_unit_delta_to_mm(tp->device, &delta);
+			double distance = hypot(delta_mm.x, delta_mm.y);
+			int suppress_time = distance > 25.0 ? 600 : 1000;
+			if (last_time < time && (time - last_time) < ms2us(suppress_time) &&
+				tp->dwt.keyboard_last_press_time < time && (time - tp->dwt.keyboard_last_press_time) < ms2us(suppress_time)) {
+				is_unintended_touch = true;
+			 }
+
+			 if (last_time < time && (time - last_time) < ms2us(1200) && distance <= 30.0 &&
+				tp->dwt.keyboard_last_backspace_time < time && (time - tp->dwt.keyboard_last_backspace_time) < ms2us(1200)) {
+				is_unintended_touch = true;
+			 }
+		}
+
+		double width, height;
+		evdev_device_get_size(tp->device, &width, &height);
+		struct phys_coords point_mm = evdev_device_units_to_mm(tp->device, &t->point);
+
+		if (tp->dwt.keyboard_last_leftctrl_time < time && (time - tp->dwt.keyboard_last_leftctrl_time) < ms2us(1000) &&
+			point_mm.x < 10.0) {
+			is_unintended_touch = true;
+		}
+
+		int tool_palm_num = tp_touch_tool_palm_num(tp);
+		if (tool_palm_num == 1) {
+			if (point_mm.x < 10.0 || point_mm.x > width - 10.0 || point_mm.y < 10.0) {
+				is_unintended_touch = true;
+			}
+	    } else if (tool_palm_num >= 2) {
+			is_unintended_touch = true;
+		}
+	}
+	return is_unintended_touch;
+}
+
 static inline bool
 tp_palm_was_in_side_edge(const struct tp_dispatch *tp, const struct tp_touch *t)
 {
@@ -1862,7 +2118,8 @@
 	ignore_motion |= tp_tap_handle_state(tp, time);
 	ignore_motion |= tp_post_button_events(tp, time);
 
-	if (tp->palm.trackpoint_active || tp->dwt.keyboard_active) {
+	if (tp->palm.trackpoint_active ||
+		(tp->dwt.keyboard_active && !evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD))) {
 		tp_edge_scroll_stop_events(tp, time);
 		tp_gesture_cancel(tp, time);
 		return;
@@ -1908,6 +2165,7 @@
 	tp_post_events(tp, time);
 	tp_post_process_state(tp, time);
 
+    tp_clickpad_rightbutton_apply_config(tp->device);
 	tp_clickpad_middlebutton_apply_config(tp->device);
 	tp_apply_rotation(tp->device);
 }
@@ -1958,6 +2216,7 @@
 		tp_process_msc(tp, e, time);
 		break;
 	case EV_SYN:
+		tp_ext_on_sync(tp, time);
 		tp_handle_state(tp, time);
 #if 0
 		tp_debug_touch_state(tp, device);
@@ -2289,6 +2548,45 @@
 	}
 }
 
+bool
+tp_touch_may_palm_touch(const struct tp_dispatch *tp, uint64_t time)
+{
+	bool may_palm_touch = false;
+
+	if (evdev_device_has_model_quirk(tp->device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD)) {
+		double width, height;
+		evdev_device_get_size(tp->device, &width, &height);
+		bool left_touch = false;
+		bool right_touch = false;
+		bool left_large_touch = false;
+		bool right_large_touch = false;
+
+        struct tp_touch *t;
+	    for (unsigned int i = 0; i < tp->num_slots; i++) {
+			t = &tp->touches[i];
+			struct phys_coords point_mm = evdev_device_units_to_mm(tp->device, &t->point);
+			if ((t->state == TOUCH_BEGIN || t->state == TOUCH_UPDATE)) {
+				if (point_mm.x < 30.0) {
+					left_touch = true;
+					if (t->major > 8) {
+						left_large_touch = true;
+					}
+				}
+				if (point_mm.x > width - 30.0) {
+					right_touch = true;
+					if (t->major > 8) {
+						right_large_touch = true;
+					}
+				}
+			}
+		}
+		bool edge_large_touch = left_large_touch || right_large_touch;
+		int palm_num = tp_touch_tool_palm_num(tp);
+		may_palm_touch = (left_touch && right_touch && edge_large_touch) || (palm_num >= 1);
+	}
+	return may_palm_touch;
+}
+
 static void
 tp_keyboard_event(uint64_t time, struct libinput_event *event, void *data)
 {
@@ -2318,6 +2616,10 @@
 	if (tp_key_ignore_for_dwt(key))
 		return;
 
+	if (key == KEY_LEFTCTRL) {
+		tp->dwt.keyboard_last_leftctrl_time = time;
+	}
+
 	/* modifier keys don't trigger disable-while-typing so things like
 	 * ctrl+zoom or ctrl+click are possible */
 	is_modifier = tp_key_is_modifier(key);
@@ -2343,7 +2645,14 @@
 		timeout = DEFAULT_KEYBOARD_ACTIVITY_TIMEOUT_2;
 	}
 
+	if (tp_touch_may_palm_touch(tp, time)) {
+		timeout = timeout * 2;
+	}
+
 	tp->dwt.keyboard_last_press_time = time;
+	if (key == KEY_BACKSPACE) {
+		tp->dwt.keyboard_last_backspace_time = time;
+	}
 	long_set_bit(tp->dwt.key_mask, key);
 	libinput_timer_set(&tp->dwt.keyboard_timer,
 			   time + timeout);
@@ -2447,12 +2756,26 @@
 
 	switch (libinput_event_switch_get_switch_state(swev)) {
 	case LIBINPUT_SWITCH_STATE_OFF:
-		tp_resume(tp, tp->device, SUSPEND_LID);
-		evdev_log_debug(tp->device, "lid: resume touchpad\n");
+		// tp_resume(tp, tp->device, SUSPEND_LID);
+		evdev_log_libinput_info(tp->device, "lid: resume touchpad\n");
 		break;
 	case LIBINPUT_SWITCH_STATE_ON:
-		tp_suspend(tp, tp->device, SUSPEND_LID);
-		evdev_log_debug(tp->device, "lid: suspending touchpad\n");
+		// tp_suspend(tp, tp->device, SUSPEND_LID);
+		evdev_log_libinput_info(tp->device, "lid: suspending touchpad\n");
+		tp->slot = 0;
+		tp->orginal.active_slot_count = 0;
+		tp->orginal.seat_slot_id = 0;
+		struct tp_touch *t;
+		tp_for_each_touch(tp, t) {
+			if (t == NULL) {
+				continue;
+			}
+			evdev_log_libinput_info(tp->device, "t->index:%d, t->is_tool_palm:%d, t->tool_type:%d, t->palm.state:%d",
+				t->index, t->is_tool_palm, t->tool_type, t->palm.state);
+			t->is_tool_palm = false;
+			t->tool_type = 0;
+			t->palm.state = PALM_NONE;
+		}
 		break;
 	}
 }
@@ -2860,6 +3183,9 @@
 	t->tp = tp;
 	t->has_ended = true;
 	t->index = index;
+	t->seat_slot = -1;
+	t->tool_type = -1;
+	evdev_log_libinput_info(tp->device, "tp_init_touch");
 }
 
 static inline void
@@ -3355,6 +3681,10 @@
 	if (evdev_device_has_model_quirk(device, QUIRK_MODEL_APPLE_TOUCHPAD))
 		return;
 
+	/* Disable edge palm detection on Huawei FreeTouch touchpads. */
+	if (evdev_device_has_model_quirk(device, QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD))
+		return;
+
 	evdev_device_get_size(device, &width, &height);
 
 	/* Enable edge palm detection on touchpads >= 70 mm. Anything
@@ -3362,18 +3692,18 @@
 	if (width < 70.0)
 		return;
 
-	/* palm edges are 8% of the width on each side */
-	mm.x = min(8, width * 0.08);
+	/* palm edges are 5mm of the width on each side */
+	mm.x = 5;
 	edges = evdev_device_mm_to_units(device, &mm);
 	tp->palm.left_edge = edges.x;
 
-	mm.x = width - min(8, width * 0.08);
+	mm.x = width - 5;
 	edges = evdev_device_mm_to_units(device, &mm);
 	tp->palm.right_edge = edges.x;
 
 	if (!tp->buttons.has_topbuttons && height > 55) {
-		/* top edge is 5% of the height */
-		mm.y = height * 0.05;
+		/* top edge is 5mm of the height */
+		mm.y = 5;
 		edges = evdev_device_mm_to_units(device, &mm);
 		tp->palm.upper_edge = edges.y;
 	}
@@ -3488,6 +3818,26 @@
 }
 
 static void
+tp_init_axis_speed_gain(struct tp_dispatch *tp,
+			struct evdev_device *device)
+{
+	struct quirks_context *quirks;
+	struct quirks *q;
+	double threshold;
+
+	quirks = evdev_libinput_context(device)->quirks;
+	q = quirks_fetch_for_device(quirks, device->udev_device);
+	if (!q)
+		return;
+
+	if (quirks_get_double(q, QUIRK_ATTR_TOUCHPAD_AXIS_SPEED_GAIN, &threshold)) {
+		tp->axis_speed_gain.use_gain = true;
+		tp->axis_speed_gain.gain = threshold;
+	}
+	quirks_unref(q);
+}
+
+static void
 tp_init_sendevents(struct tp_dispatch *tp,
 		   struct evdev_device *device)
 {
@@ -3512,6 +3862,19 @@
 			    tp_keyboard_timeout, tp);
 }
 
+static void 
+tp_init_touchpad_info(struct tp_dispatch *tp,
+		   struct evdev_device *device)
+{
+	double width, height;
+	evdev_device_get_size(tp->device, &width, &height);
+	tp->device->touchpad_hypot_size = sqrt(pow(width, 2) + pow(height, 2));
+	const struct input_absinfo *x, *y;
+	x = libevdev_get_abs_info(device->evdev, ABS_X);
+	y = libevdev_get_abs_info(device->evdev, ABS_Y);
+	tp->device->touchpad_ppi = sqrt(pow(x->maximum, 2) + pow(y->maximum, 2)) / tp->device->touchpad_hypot_size;
+}
+
 static bool
 tp_pass_sanity_check(struct tp_dispatch *tp,
 		     struct evdev_device *device)
@@ -3775,6 +4138,8 @@
 	tp_init_scroll(tp, device);
 	tp_init_gesture(tp);
 	tp_init_thumb(tp);
+	tp_init_axis_speed_gain(tp, device);
+	tp_init_touchpad_info(tp, device);
 
 	/* Lenovo X1 Gen6 buffers the events in a weird way, making jump
 	 * detection impossible. See
@@ -3788,6 +4153,10 @@
 	if (tp->gesture.enabled)
 		device->seat_caps |= EVDEV_DEVICE_GESTURE;
 
+	tp->orginal.seat_slot_id = 0;
+	tp->orginal.active_slot_count = 0;
+	tp->orginal.xy_updated = 0;
+
 	return true;
 }
 
@@ -3971,6 +4340,14 @@
 
 	tp = zalloc(sizeof *tp);
 
+	const struct input_absinfo* absInfo = device->is_mt ? libevdev_get_abs_info(device->evdev, ABS_MT_PRESSURE)
+		: libevdev_get_abs_info(device->evdev, ABS_PRESSURE);
+	if (absInfo == NULL) {
+		device->pressureMax = 0.0;
+	} else {
+		device->pressureMax = absInfo->maximum;
+	}
+
 	if (!tp_init(tp, device)) {
 		tp_interface_destroy(&tp->base);
 		return NULL;
@@ -3988,3 +4365,27 @@
 
 	return &tp->base;
 }
+
+bool
+evdev_device_touchpad_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType)
+{
+	struct tp_dispatch *tp = tp_dispatch(device->dispatch);
+
+	unsigned int shift = 0;
+	switch (btnToolType) {
+	case BTN_TOOL_PEN:
+	case BTN_TOOL_RUBBER:
+	case BTN_TOOL_BRUSH:
+	case BTN_TOOL_PENCIL:
+	case BTN_TOOL_AIRBRUSH:
+	case BTN_TOOL_FINGER:
+	case BTN_TOOL_MOUSE:
+	case BTN_TOOL_LENS:
+		shift = btnToolType - BTN_TOOL_PEN;
+		break;
+	default:
+		return false;
+	}
+
+	return (tp->tool_touches >> shift) & 0x1;
+}
diff -Naur old/src/evdev-mt-touchpad.h new/src/evdev-mt-touchpad.h
--- old/src/evdev-mt-touchpad.h	2025-03-26 11:12:53.945121848 +0800
+++ new/src/evdev-mt-touchpad.h	2025-03-26 11:16:26.434458838 +0800
@@ -132,6 +132,8 @@
 	TAP_STATE_2FGTAP_DRAGGING_2,
 	TAP_STATE_3FGTAP_DRAGGING_2,
 	TAP_STATE_DEAD, /**< finger count exceeded */
+	TAP_STATE_HOLDING,
+	TAP_STATE_DOUBLE_TAP,
 };
 
 enum tp_tap_touch_state {
@@ -192,10 +194,15 @@
 	int pressure;
 	bool is_tool_palm; /* MT_TOOL_PALM */
 	int major, minor;
+    struct device_coord_rect tool_rect;
+	struct device_coords first; /* first coordinates when touch down */
 
 	bool was_down; /* if distance == 0, false for pure hovering
 			  touches */
 
+	int seat_slot;
+	int tool_type;
+
 	struct {
 		/* A quirk mostly used on Synaptics touchpads. In a
 		   transition to/from fake touches > num_slots, the current
@@ -229,6 +236,7 @@
 	 */
 	struct {
 		bool is_pinned;
+		bool is_pinned_edge_dragging;
 		struct device_coords center;
 	} pinned;
 
@@ -282,6 +290,18 @@
 	SUSPEND_TABLET_MODE     = 0x8,
 };
 
+enum tp_pointer_motion_lock_state {
+	POINTER_MOTION_LOCK_STATE_UNLOCKED = 0,
+	POINTER_MOTION_LOCK_STATE_JUDGING,
+	POINTER_MOTION_LOCK_STATE_LOCKED,
+};
+
+enum tp_scroll_lock_state {
+	SCROLL_LOCK_STATE_UNLOCKED = 0,
+	SCROLL_LOCK_STATE_JUDGING,
+	SCROLL_LOCK_STATE_LOCKED,
+};
+
 struct tp_dispatch {
 	struct evdev_dispatch base;
 	struct evdev_device *device;
@@ -310,6 +330,17 @@
 	 */
 	unsigned int fake_touches;
 
+	/* bit 0: BTN_TOOL_PEN
+	 * bit 1: BTN_TOOL_RUBBER
+	 * bit 2: BTN_TOOL_BRUSH
+	 * bit 3: BTN_TOOL_PENCIL
+	 * bit 4: BTN_TOOL_AIRBRUSH
+	 * bit 5: BTN_TOOL_FINGER
+	 * bit 6: BTN_TOOL_MOUSE
+	 * bit 7: BTN_TOOL_LENS
+	 */
+	unsigned int tool_touches;
+
 	struct {
 		bool detection_disabled;
 		struct ratelimit warning;
@@ -363,12 +394,27 @@
 		struct device_float_coords center;
 		struct libinput_timer hold_timer;
 		bool hold_enabled;
+		bool is_rotate;
+		double angle_delta;
+		unsigned int moved_count;
 	} gesture;
 
 	struct {
+		int32_t right_edge;		/* in device coordinates */
+		int32_t left_edge;		/* in device coordinates */
+		int32_t upper_edge;		/* in device coordinates */
+		int32_t lower_edge;		/* in device coordinates */
+		double speed;		/* in device_coord/us */
+
+		struct device_float_coords dir;		/* normalized direction of the drag */
+		uint64_t prev_time;		/* previous event time in us */
+	} press_and_drag;
+
+	struct {
 		bool is_clickpad;		/* true for clickpads */
 		bool has_topbuttons;
 		bool use_clickfinger;		/* number of fingers decides button number */
+		bool suspended;
 		bool click_pending;
 		uint32_t state;
 		uint32_t old_state;
@@ -399,6 +445,7 @@
 
 		enum libinput_config_click_method click_method;
 		struct libinput_device_config_click_method config_method;
+		uint32_t area;
 	} buttons;
 
 	struct {
@@ -414,6 +461,8 @@
 		struct {
 			uint64_t h, v;
 		} duration;
+		struct normalized_coords scroll_delta;
+		bool correct_pinch_flag;
 	} scroll;
 
 	enum touchpad_event queued;
@@ -482,6 +531,8 @@
 		bool keyboard_active;
 		struct libinput_timer keyboard_timer;
 		uint64_t keyboard_last_press_time;
+		uint64_t keyboard_last_backspace_time;
+		uint64_t keyboard_last_leftctrl_time;
 	} dwt;
 
 	struct {
@@ -535,6 +586,45 @@
 		struct evdev_device *tablet_device;
 		bool tablet_left_handed_state;
 	} left_handed;
+
+	struct {
+		int seat_slot_id;
+		int active_slot_count;
+		int xy_updated;
+	} orginal;
+
+	struct {
+		enum tp_pointer_motion_lock_state state;
+		uint64_t judge_start_time;
+		struct device_float_coords judge_moved;
+		struct device_float_coords lock_moved;
+		struct device_float_coords last_moved;
+	} pointer_motion_lock;
+
+	struct scroll_idle_lock {
+		enum tp_scroll_lock_state state;
+		uint64_t judge_start_time;
+		double judge_moved;
+		double lock_moved;
+	} scroll_idle_lock[2]; /* 2 direction, 0 : x, 1 : y */
+
+	struct scroll_direction_lock {
+		enum tp_scroll_lock_state state;
+		int direction;
+		double judge_moved;
+		double lock_moved;
+		double last_moved;
+	} scroll_direction_lock[2]; /* 2 direction, 0 : x, 1 : y */
+
+	struct history_tool_palm {
+		struct device_coords last; /* last coords for a tool palm touch */
+		uint64_t last_time; /* timestamp when a tool palm touch up */
+	} history_tool_palm[5];
+
+	struct {
+		bool use_gain;
+		double gain;
+	} axis_speed_gain;
 };
 
 static inline struct tp_dispatch*
@@ -617,7 +707,14 @@
 
 bool
 tp_touch_active_for_gesture(const struct tp_dispatch *tp,
-			    const struct tp_touch *t);
+			    const struct tp_touch *t, uint64_t time);
+
+int
+tp_touch_tool_palm_num(const struct tp_dispatch *tp);
+
+bool
+tp_touch_unintended_touch_for_typing(const struct tp_dispatch *tp,
+			    const struct tp_touch *t, uint64_t time);
 
 int
 tp_tap_handle_state(struct tp_dispatch *tp, uint64_t time);
@@ -675,6 +772,12 @@
 void
 tp_tap_resume(struct tp_dispatch *tp, uint64_t time);
 
+void
+tp_button_suspend(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_button_resume(struct tp_dispatch *tp, uint64_t time);
+
 bool
 tp_tap_dragging(const struct tp_dispatch *tp);
 
@@ -767,4 +870,25 @@
 struct tp_touch*
 tp_thumb_get_touch(struct tp_dispatch *tp);
 
+void
+tp_tap_original_down(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
+void
+tp_tap_original_up(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
+void
+tp_tap_original_motion(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
+void
+tp_clickpad_rightbutton_apply_config(struct evdev_device *device);
+
+static bool
+tp_edge_aft_for_tow_finger(struct tp_dispatch *tp, uint64_t time);
+
 #endif
diff -Naur old/src/evdev-privacy-switch.c new/src/evdev-privacy-switch.c
--- old/src/evdev-privacy-switch.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-privacy-switch.c	2025-03-26 11:16:26.434458838 +0800
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <string.h>
+
+#include "config.h"
+#include "libinput-version.h"
+#include "evdev-privacy-switch.h"
+#include "libinput.h"
+#include "libinput-util.h"
+
+struct privacy_switch_dispatch {
+	struct evdev_dispatch base;
+	struct evdev_device* device;
+	uint64_t time;
+	uint32_t mask;
+	struct privacy_switch ev_switch;
+	struct {
+		struct libinput_device_config_send_events config;
+		enum libinput_config_send_events_mode current_mode;
+	} sendevents;
+};
+
+static inline struct
+privacy_switch_dispatch* get_privacy_switch_dispatch(struct evdev_dispatch* dispatch)
+{
+    evdev_verify_dispatch_type(dispatch, DISPATCH_PRIVACY_SWITCH);
+
+    struct privacy_switch_dispatch* pSwitchDispatch = NULL;
+    pSwitchDispatch = container_of(dispatch, struct privacy_switch_dispatch, base);
+
+    return pSwitchDispatch;
+}
+
+static void
+privacy_switch_post_event(struct privacy_switch_dispatch* pSwitchDispatch,
+    struct evdev_device* device, struct input_event* event, uint64_t time)
+{
+    if (pSwitchDispatch == NULL || device == NULL || event == NULL) {
+        return;
+    }
+    pSwitchDispatch->mask = 1;
+    pSwitchDispatch->ev_switch.time = time;
+    pSwitchDispatch->ev_switch.sw = LIBINPUT_SWITCH_PRIVACY;
+
+
+    if (event->value == 1) {
+        pSwitchDispatch->ev_switch.state = LIBINPUT_SWITCH_STATE_ON;
+    } else {
+        pSwitchDispatch->ev_switch.state = LIBINPUT_SWITCH_STATE_OFF;
+    }
+}
+
+static inline void privacy_switch_reset_mask(struct privacy_switch_dispatch* pSwitchDispatch)
+{
+	pSwitchDispatch->mask = 0;
+}
+
+static void
+privacy_switch_flush(struct privacy_switch_dispatch* pSwitchDispatch, struct evdev_device* device, uint64_t time)
+{
+    if (pSwitchDispatch == NULL || device == NULL) {
+        return;
+    }
+
+    if (pSwitchDispatch->mask == 1) {
+        privacy_switch_notify_event(&device->base, time, &pSwitchDispatch->ev_switch);
+        privacy_switch_reset_mask(pSwitchDispatch);
+    }
+}
+
+static void
+privacy_switch_process(struct evdev_dispatch* dispatch, struct evdev_device* device,
+    struct input_event* event, uint64_t time)
+{
+    if (dispatch == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    struct privacy_switch_dispatch* pSwitchDispatch = get_privacy_switch_dispatch(dispatch);
+    if (pSwitchDispatch == NULL) {
+        return;
+    }
+
+    switch (event->type) {
+    case EV_SW: {
+        privacy_switch_post_event(pSwitchDispatch, device, event, time);
+    }
+    break;
+    case EV_SYN: {
+        privacy_switch_flush(pSwitchDispatch, device, time);
+    }
+    break;
+    default:
+        libinput_log_printf("unsupported privacy_switch event type: %d, devname: %s.\n", event->type, device->devname);
+    break;
+    }
+}
+
+static void
+privacy_switch_destroy(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return;
+    }
+    struct privacy_switch_dispatch* pSwitchDispatch = get_privacy_switch_dispatch(dispatch);
+    if (pSwitchDispatch == NULL) {
+        return;
+    }
+
+    free(pSwitchDispatch);
+}
+
+static void
+privacy_switch_device_added(struct evdev_device* device,
+    struct evdev_device* added_device)
+{
+    if (device == NULL || added_device == NULL || device->dispatch == NULL) {
+        return;
+    }
+    struct privacy_switch_dispatch* privacy_switch_dispatch = get_privacy_switch_dispatch(device->dispatch);
+    if (privacy_switch_dispatch == NULL) {
+        return;
+    }
+    if (libinput_device_get_device_group(&device->base) !=
+        libinput_device_get_device_group(&added_device->base)) {
+        return;
+    }
+    bool is_privacy_switch = false;
+    is_privacy_switch = evdev_device_has_capability(added_device,
+        LIBINPUT_DEVICE_CAP_SWITCH);
+
+    if (is_privacy_switch) {
+        evdev_log_debug(device,
+            "privacy_switch: activated for %s<->%s\n",
+            device->devname,
+            added_device->devname);
+        privacy_switch_dispatch->device = added_device;
+    }
+}
+
+static void
+privacy_switch_device_removed(struct evdev_device* device, struct evdev_device* removed_device)
+{
+    if (device == NULL || removed_device == NULL) {
+        return;
+    }
+    struct privacy_switch_dispatch* pSwitchDispatch = get_privacy_switch_dispatch(device->dispatch);
+    if (pSwitchDispatch == NULL) {
+        return;
+    }
+
+    if (pSwitchDispatch->device == removed_device) {
+        pSwitchDispatch->device = NULL;
+    }
+}
+
+static void privacy_switch_suspend(struct evdev_dispatch* dispatch, struct evdev_device* device)
+{
+    if (dispatch == NULL || device == NULL) {
+        return;
+    }
+    struct privacy_switch_dispatch* pSwitchDispatch = get_privacy_switch_dispatch(dispatch);
+    if (pSwitchDispatch == NULL) {
+        return;
+    }
+    privacy_switch_flush(pSwitchDispatch, device, 0);
+}
+
+static struct evdev_dispatch_interface privacy_switch_interface = {
+    .process = privacy_switch_process,
+    .suspend = privacy_switch_suspend,
+    .remove = NULL,
+    .destroy = privacy_switch_destroy,
+    .device_added = privacy_switch_device_added,
+    .device_removed = privacy_switch_device_removed,
+    .device_suspended = NULL,
+    .device_resumed = NULL,
+    .post_added = NULL,
+    .touch_arbitration_toggle = NULL,
+    .touch_arbitration_update_rect = NULL,
+    .get_switch_state = NULL,
+};
+
+static enum libinput_config_status
+privacy_switch_sendevents_set_mode(struct libinput_device* device,
+    enum libinput_config_send_events_mode mode)
+{
+    if (device == NULL)     {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct privacy_switch_dispatch* pSwitchDispatch = (struct privacy_switch_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || pSwitchDispatch == NULL) {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    if (mode == pSwitchDispatch->sendevents.current_mode) {
+        return LIBINPUT_CONFIG_STATUS_SUCCESS;
+    }
+
+    switch (mode) {
+    case LIBINPUT_CONFIG_SEND_EVENTS_ENABLED:
+        break;
+    case LIBINPUT_CONFIG_SEND_EVENTS_DISABLED:
+        privacy_switch_suspend(ev_device->dispatch, ev_device);
+        break;
+    default:
+        return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+    }
+
+    pSwitchDispatch->sendevents.current_mode = mode;
+
+    return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+static uint32_t
+privacy_switch_sendevents_get_modes(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+}
+
+static enum libinput_config_send_events_mode
+privacy_switch_sendevents_get_mode(struct libinput_device* device)
+{
+    if (device == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct privacy_switch_dispatch* pDispatch = (struct privacy_switch_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || pDispatch == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    return pDispatch->sendevents.current_mode;
+}
+
+static enum libinput_config_send_events_mode
+privacy_switch_sendevents_get_default_mode(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+}
+
+static bool
+privacy_switch_init(struct privacy_switch_dispatch* pSwitch, struct evdev_device* device)
+{
+    if (pSwitch == NULL || device == NULL) {
+        return false;
+    }
+
+    pSwitch->base.dispatch_type = DISPATCH_PRIVACY_SWITCH;
+    pSwitch->base.interface = &privacy_switch_interface;
+    pSwitch->device = device;
+
+    return true;
+}
+
+struct evdev_dispatch*
+evdev_privacy_switch_create(struct evdev_device* device)
+{
+    if (device == NULL) {
+        return NULL;
+    }
+
+    struct privacy_switch_dispatch* privacySwitch = NULL;
+    privacySwitch = zalloc(sizeof * privacySwitch);
+
+    if (!privacy_switch_init(privacySwitch, device)) {
+        privacy_switch_destroy(&privacySwitch->base);
+        privacySwitch = NULL;
+        return NULL;
+    }
+
+    device->base.config.sendevents = &privacySwitch->sendevents.config;
+    privacySwitch->sendevents.current_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+    privacySwitch->sendevents.config.get_modes = privacy_switch_sendevents_get_modes;
+    privacySwitch->sendevents.config.set_mode = privacy_switch_sendevents_set_mode;
+    privacySwitch->sendevents.config.get_mode = privacy_switch_sendevents_get_mode;
+    privacySwitch->sendevents.config.get_default_mode = privacy_switch_sendevents_get_default_mode;
+
+    return &privacySwitch->base;
+}
+
diff -Naur old/src/evdev-privacy-switch.h new/src/evdev-privacy-switch.h
--- old/src/evdev-privacy-switch.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-privacy-switch.h	2025-03-26 11:16:26.434458838 +0800
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef LIBINPUT_EVDEV_PRIVACY_SWITCH_H
+#define LIBINPUT_EVDEV_PRIVACY_SWITCH_H
+
+#include "evdev.h"
+#include "libinput-private.h"
+
+struct privacy_switch {
+	uint64_t time;
+	enum libinput_switch sw;
+	enum libinput_switch_state state;
+};
+
+struct evdev_dispatch* evdev_privacy_switch_create(struct evdev_device* device);
+
+#endif
diff -Naur old/src/evdev-tablet.c new/src/evdev-tablet.c
--- old/src/evdev-tablet.c	2025-03-26 11:12:53.949121875 +0800
+++ new/src/evdev-tablet.c	2025-03-26 11:16:26.434458838 +0800
@@ -220,6 +220,8 @@
 	case ABS_TILT_Y:
 	case ABS_DISTANCE:
 	case ABS_WHEEL:
+	case ABS_MT_TOOL_TYPE:
+	case ABS_MT_ANGLE:
 		axis = evcode_to_axis(e->code);
 		if (axis == LIBINPUT_TABLET_TOOL_AXIS_NONE) {
 			evdev_log_bug_libinput(device,
@@ -231,7 +233,6 @@
 		tablet->prev_value[axis] = tablet->current_value[axis];
 		if (tablet_filter_axis_fuzz(tablet, device, e, axis))
 			break;
-
 		tablet->current_value[axis] = e->value;
 		set_bit(tablet->changed_axes, axis);
 		tablet_set_status(tablet, TABLET_AXES_UPDATED);
@@ -374,7 +375,11 @@
 adjust_tilt(const struct input_absinfo *absinfo)
 {
 	double value = (absinfo->value - absinfo->minimum) / absinfo_range(absinfo);
+#ifdef OHOS_BUILD_ENABLE_PEN
+	const int WACOM_MAX_DEGREES = 90;
+#else
 	const int WACOM_MAX_DEGREES = 64;
+#endif // OHOS_BUILD_ENABLE_PEN
 
 	/* If resolution is nonzero, it's in units/radian. But require
 	 * a min/max less/greater than zero so we can assume 0 is the
@@ -675,6 +680,22 @@
 	}
 }
 
+static inline void
+tablet_update_angle(struct tablet_dispatch *tablet,
+		    struct evdev_device *device)
+{
+	int a;
+	const struct input_absinfo *absinfo;
+
+	a = LIBINPUT_TABLET_TOOL_AXIS_ANGLE;
+	if (bit_is_set(tablet->changed_axes, a)) {
+		absinfo = libevdev_get_abs_info(device->evdev, ABS_MT_ANGLE);
+		tablet->axes.angle = absinfo->value;
+	} else {
+		tablet->axes.angle = 0;
+	}
+}
+
 static void
 tablet_smoothen_axes(const struct tablet_dispatch *tablet,
 		     struct tablet_axes *axes)
@@ -722,6 +743,7 @@
 	tablet_update_slider(tablet, device);
 	tablet_update_tilt(tablet, device);
 	tablet_update_wheel(tablet, device);
+	tablet_update_angle(tablet, device);
 	/* We must check ROTATION_Z after TILT_X/Y so that the tilt axes are
 	 * already normalized and set if we have the mouse/lens tool */
 	tablet_update_rotation(tablet, device);
@@ -734,6 +756,7 @@
 	axes.wheel = tablet->axes.wheel;
 	axes.wheel_discrete = tablet->axes.wheel_discrete;
 	axes.rotation = tablet->axes.rotation;
+	axes.angle = tablet->axes.angle;
 
 	rc = true;
 
@@ -991,6 +1014,8 @@
 		copy_axis_cap(tablet, tool, LIBINPUT_TABLET_TOOL_AXIS_SLIDER);
 	if (axes & WACOM_AXIS_TYPE_PRESSURE)
 		copy_axis_cap(tablet, tool, LIBINPUT_TABLET_TOOL_AXIS_PRESSURE);
+	if (axes & WACOM_AXIS_TYPE_ANGLE)
+		copy_axis_cap(tablet, tool, LIBINPUT_TABLET_TOOL_AXIS_ANGLE);
 
 	rc = 0;
 
@@ -1026,6 +1051,7 @@
 		copy_axis_cap(tablet, tool, LIBINPUT_TABLET_TOOL_AXIS_TILT_X);
 		copy_axis_cap(tablet, tool, LIBINPUT_TABLET_TOOL_AXIS_TILT_Y);
 		copy_axis_cap(tablet, tool, LIBINPUT_TABLET_TOOL_AXIS_SLIDER);
+		copy_axis_cap(tablet, tool, LIBINPUT_TABLET_TOOL_AXIS_ANGLE);
 
 		/* Rotation is special, it can be either ABS_Z or
 		 * BTN_TOOL_MOUSE+ABS_TILT_X/Y. Aiptek tablets have
@@ -1107,9 +1133,15 @@
 		tool->pressure.heuristic_state = PRESSURE_HEURISTIC_STATE_PROXIN1;
 	}
 
+#ifdef OHOS_BUILD_ENABLE_PEN
+	/* 1 and 0.125% of the pressure range */
+	hi = axis_range_percentage(pressure, 1);
+	lo = axis_range_percentage(pressure, 0.125);
+#else
 	/* 5 and 1% of the pressure range */
 	hi = axis_range_percentage(pressure, 5);
 	lo = axis_range_percentage(pressure, 1);
+#endif // OHOS_BUILD_ENABLE_PEN
 
 	if (q && quirks_get_range(q, QUIRK_ATTR_PRESSURE_RANGE, &r)) {
 		if (r.lower >= r.upper) {
@@ -1184,6 +1216,7 @@
 			.serial = serial,
 			.tool_id = tool_id,
 			.refcount = 1,
+			.pressure.mt_tool_type = tablet->current_value[LIBINPUT_TABLET_TOOL_AXIS_TYPE],
 		};
 
 		tool_set_pressure_thresholds(tablet, tool);
@@ -2563,6 +2596,34 @@
 	return true;
 }
 
+static void
+tablet_reset_abs_resolution(struct evdev_device *device)
+{
+    if (!device->abs.is_fake_resolution) {
+        return;
+    }
+    struct libevdev *evdev = device->evdev;
+    const struct input_absinfo *absy;
+    const struct input_absinfo *absx;
+    size_t widthmm = 271;
+    size_t heightmm = 170;
+    size_t xres = 0;
+    size_t yres = 0;
+
+    absx = libevdev_get_abs_info(evdev, ABS_X);
+    absy = libevdev_get_abs_info(evdev, ABS_Y);
+    xres = (absx->maximum - absx->minimum) / widthmm;
+    yres = (absy->maximum - absy->minimum) / heightmm;
+    if (xres == 0 || yres == 0) {
+        return;
+    }
+    libevdev_set_abs_resolution(evdev, ABS_X, xres);
+    libevdev_set_abs_resolution(evdev, ABS_Y, yres);
+    device->abs.is_fake_resolution = false;
+    libinput_log_printf("\t\tdevice:%s no resolution or size hints, assuming a size of %dx%d mm\n",
+        device->devname, widthmm, heightmm);
+}
+
 static int
 tablet_init(struct tablet_dispatch *tablet,
 	    struct evdev_device *device)
@@ -2577,6 +2638,7 @@
 	tablet->status = TABLET_NONE;
 	tablet->current_tool.type = LIBINPUT_TOOL_NONE;
 	list_init(&tablet->tool_list);
+    tablet_reset_abs_resolution(device);
 
 	if (tablet_reject_device(device))
 		return -1;
@@ -2604,7 +2666,7 @@
 	tablet_init_smoothing(device, tablet);
 
 	for (axis = LIBINPUT_TABLET_TOOL_AXIS_X;
-	     axis <= LIBINPUT_TABLET_TOOL_AXIS_MAX;
+	     axis <= LIBINPUT_TABLET_TOOL_AXIS_ANGLE;
 	     axis++) {
 		if (tablet_device_has_axis(tablet, axis))
 			set_bit(tablet->axis_caps, axis);
diff -Naur old/src/evdev-tablet.h new/src/evdev-tablet.h
--- old/src/evdev-tablet.h	2025-03-26 11:12:53.949121875 +0800
+++ new/src/evdev-tablet.h	2025-03-26 11:16:26.434458838 +0800
@@ -152,6 +152,12 @@
 	case ABS_WHEEL:
 		axis = LIBINPUT_TABLET_TOOL_AXIS_SLIDER;
 		break;
+	case ABS_MT_TOOL_TYPE:
+		axis = LIBINPUT_TABLET_TOOL_AXIS_TYPE;
+		break;
+	case ABS_MT_ANGLE:
+		axis = LIBINPUT_TABLET_TOOL_AXIS_ANGLE;
+		break;
 	default:
 		axis = LIBINPUT_TABLET_TOOL_AXIS_NONE;
 		break;
@@ -210,9 +216,15 @@
 	case LIBINPUT_TABLET_TOOL_AXIS_SIZE_MAJOR:
 		evcode = ABS_MT_TOUCH_MAJOR;
 		break;
+	case LIBINPUT_TABLET_TOOL_AXIS_TYPE:
+		evcode = ABS_MT_TOOL_TYPE;
+		break;
 	case LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR:
 		evcode = ABS_MT_TOUCH_MINOR;
 		break;
+	case LIBINPUT_TABLET_TOOL_AXIS_ANGLE:
+		evcode = ABS_MT_ANGLE;
+		break;
 	default:
 		abort();
 	}
diff -Naur old/src/evdev.c new/src/evdev.c
--- old/src/evdev.c	2025-03-26 11:12:53.949121875 +0800
+++ new/src/evdev.c	2025-03-26 11:16:26.434458838 +0800
@@ -52,26 +52,6 @@
 #define DEFAULT_WHEEL_CLICK_ANGLE 15
 #define DEFAULT_BUTTON_SCROLL_TIMEOUT ms2us(200)
 
-enum evdev_device_udev_tags {
-	EVDEV_UDEV_TAG_INPUT		= bit(0),
-	EVDEV_UDEV_TAG_KEYBOARD		= bit(1),
-	EVDEV_UDEV_TAG_MOUSE		= bit(2),
-	EVDEV_UDEV_TAG_TOUCHPAD		= bit(3),
-	EVDEV_UDEV_TAG_TOUCHSCREEN	= bit(4),
-	EVDEV_UDEV_TAG_TABLET		= bit(5),
-	EVDEV_UDEV_TAG_JOYSTICK		= bit(6),
-	EVDEV_UDEV_TAG_ACCELEROMETER	= bit(7),
-	EVDEV_UDEV_TAG_TABLET_PAD	= bit(8),
-	EVDEV_UDEV_TAG_POINTINGSTICK	= bit(9),
-	EVDEV_UDEV_TAG_TRACKBALL	= bit(10),
-	EVDEV_UDEV_TAG_SWITCH		= bit(11),
-};
-
-struct evdev_udev_tag_match {
-	const char *name;
-	enum evdev_device_udev_tags tag;
-};
-
 static const struct evdev_udev_tag_match evdev_udev_tag_matches[] = {
 	{"ID_INPUT",			EVDEV_UDEV_TAG_INPUT},
 	{"ID_INPUT_KEYBOARD",		EVDEV_UDEV_TAG_KEYBOARD},
@@ -131,7 +111,12 @@
 {
 	int key_count = 0;
 	assert(code >= 0 && code < KEY_CNT);
-
+	if (code == BTN_LEFT) {
+		if (device->key_count[code] == pressed) {
+			return pressed;
+		}
+	}
+	
 	if (pressed) {
 		key_count = ++device->key_count[code];
 	} else {
@@ -209,6 +194,56 @@
 }
 
 static void
+evdev_pointer_post_button_touchpad(struct evdev_device *device,
+			  uint64_t time,
+			  unsigned int button,
+			  enum libinput_button_state state)
+{
+	int down_count;
+
+	down_count = evdev_update_key_down_count(device, button, state);
+
+	if ((state == LIBINPUT_BUTTON_STATE_PRESSED && down_count == 1) ||
+	    (state == LIBINPUT_BUTTON_STATE_RELEASED && down_count == 0)) {
+		pointer_notify_button_touchpad(&device->base, time, button, state);
+
+		if (state == LIBINPUT_BUTTON_STATE_RELEASED) {
+			if (device->left_handed.change_to_enabled)
+				device->left_handed.change_to_enabled(device);
+
+			if (device->scroll.change_scroll_method)
+				device->scroll.change_scroll_method(device);
+		}
+	}
+
+}
+
+static void
+evdev_pointer_post_tap(struct evdev_device *device,
+			  uint64_t time,
+			  unsigned int button,
+			  enum libinput_button_state state)
+{
+	int down_count;
+
+	down_count = evdev_update_key_down_count(device, button, state);
+
+	if ((state == LIBINPUT_BUTTON_STATE_PRESSED && down_count == 1) ||
+	    (state == LIBINPUT_BUTTON_STATE_RELEASED && down_count == 0)) {
+		pointer_notify_tap(&device->base, time, button, state);
+
+		if (state == LIBINPUT_BUTTON_STATE_RELEASED) {
+			if (device->left_handed.change_to_enabled)
+				device->left_handed.change_to_enabled(device);
+
+			if (device->scroll.change_scroll_method)
+				device->scroll.change_scroll_method(device);
+		}
+	}
+
+}
+
+static void
 evdev_button_scroll_timeout(uint64_t time, void *data)
 {
 	struct evdev_device *device = data;
@@ -329,6 +364,36 @@
 }
 
 void
+evdev_pointer_notify_button_touchpad(struct evdev_device *device,
+			    uint64_t time,
+			    unsigned int button,
+			    enum libinput_button_state state)
+{
+	if (device->scroll.method == LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN &&
+	    button == device->scroll.button) {
+		evdev_button_scroll_button(device, time, state);
+		return;
+	}
+
+	evdev_pointer_post_button_touchpad(device, time, button, state);
+}
+
+void
+evdev_pointer_notify_tap(struct evdev_device *device,
+			    uint64_t time,
+			    unsigned int button,
+			    enum libinput_button_state state)
+{
+	if (device->scroll.method == LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN &&
+	    button == device->scroll.button) {
+		evdev_button_scroll_button(device, time, state);
+		return;
+	}
+
+	evdev_pointer_post_tap(device, time, button, state);
+}
+
+void
 evdev_device_led_update(struct evdev_device *device, enum libinput_led leds)
 {
 	static const struct {
@@ -369,6 +434,17 @@
 }
 
 void
+evdev_transform_absolute_rect(struct evdev_device *device,
+			 struct device_coord_rect *rect)
+{
+	if (!device->abs.apply_calibration)
+		return;
+
+	matrix_mult_vec(&device->abs.calibration, &rect->x, &rect->y);
+	matrix_mult_vec(&device->abs.calibration, &rect->w, &rect->h);
+}
+
+void
 evdev_transform_relative(struct evdev_device *device,
 			 struct device_coords *point)
 {
@@ -384,7 +460,10 @@
 static inline double
 scale_axis(const struct input_absinfo *absinfo, double val, double to_range)
 {
-	return (val - absinfo->minimum) * to_range / absinfo_range(absinfo);
+    if (absinfo->maximum < absinfo->minimum) {
+        return 0.0;
+    }
+    return (val - absinfo->minimum) * to_range / absinfo_range(absinfo);
 }
 
 double
@@ -1965,6 +2044,9 @@
 	return true;
 }
 
+static enum evdev_device_udev_tags
+update_device_capability(struct evdev_device *device);
+
 static struct evdev_dispatch *
 evdev_configure_device(struct evdev_device *device)
 {
@@ -1974,11 +2056,17 @@
 	struct evdev_dispatch *dispatch;
 
 	udev_tags = evdev_device_get_udev_tags(device, device->udev_device);
+    libinput_log_printf("----evdev_configure_device  tagged as supported input device---- %d \r\n", udev_tags);
 
 	if ((udev_tags & EVDEV_UDEV_TAG_INPUT) == 0 ||
 	    (udev_tags & ~EVDEV_UDEV_TAG_INPUT) == 0) {
+		udev_tags = update_device_capability(device);
+	}
+	if ((udev_tags & EVDEV_UDEV_TAG_INPUT) == 0 ||
+	    (udev_tags & ~EVDEV_UDEV_TAG_INPUT) == 0) {
 		evdev_log_info(device,
 			       "not tagged as supported input device\n");
+        libinput_log_printf("----evdev_configure_device not tagged as supported input device---- \r\n");
 		return NULL;
 	}
 
@@ -2008,12 +2096,6 @@
 		evdev_disable_accelerometer_axes(device);
 	}
 
-	if (evdev_device_is_joystick_or_gamepad(device)) {
-		evdev_log_info(device,
-			       "device is a joystick or a gamepad, ignoring\n");
-		return NULL;
-	}
-
 	if (evdev_reject_device(device)) {
 		evdev_log_info(device, "was rejected\n");
 		return NULL;
@@ -2029,8 +2111,23 @@
 			udev_tags &= ~EVDEV_UDEV_TAG_TOUCHSCREEN;
 	}
 
+    if (udev_tags & EVDEV_UDEV_TAG_JOYSTICK) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_JOYSTICK_BULID-- \r\n");
+        dispatch = evdev_joystick_create(device);
+        device->seat_caps |= EVDEV_DEVICE_JOYSTICK;
+		return dispatch;
+    }
+	if (udev_tags & EVDEV_UDEV_TAG_SWITCH && libevdev_has_event_code(evdev, EV_SW, SW_SUPER_PRIVACY)) {
+		libinput_log_printf("device is a super privacy switch device.\r\n");
+		dispatch = evdev_privacy_switch_create(device);
+		device->seat_caps |= EVDEV_DEVICE_SWITCH;
+		device->tags |= EVDEV_TAG_PRIVACY_SWITCH;
+		return dispatch;
+	}
+
 	if (evdev_device_has_model_quirk(device,
 					 QUIRK_MODEL_DELL_CANVAS_TOTEM)) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TOTEM_BULID-- \r\n");
 		dispatch = evdev_totem_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET;
 		evdev_log_info(device, "device is a totem\n");
@@ -2046,6 +2143,7 @@
 
 	/* libwacom assigns tablet _and_ tablet_pad to the pad devices */
 	if (udev_tags & EVDEV_UDEV_TAG_TABLET_PAD) {
+	libinput_log_printf("----evdev_configure_device--_LIBINPUT_TABLET_PAD_BULID-- \r\n");
 		dispatch = evdev_tablet_pad_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET_PAD;
 		evdev_log_info(device, "device is a tablet pad\n");
@@ -2054,6 +2152,7 @@
 	}
 
 	if ((udev_tags & tablet_tags) == EVDEV_UDEV_TAG_TABLET) {
+	libinput_log_printf("----evdev_configure_device--_LIBINPUT_TABLET_BULID-- \r\n");
 		dispatch = evdev_tablet_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET;
 		evdev_log_info(device, "device is a tablet\n");
@@ -2061,6 +2160,7 @@
 	}
 
 	if (udev_tags & EVDEV_UDEV_TAG_TOUCHPAD) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TOUCHPAD_BULID-- \r\n");
 		if (udev_tags & EVDEV_UDEV_TAG_TABLET)
 			evdev_tag_tablet_touchpad(device);
 		/* whether velocity should be averaged, false by default */
@@ -2147,6 +2247,10 @@
 		return NULL;
 	}
 
+	if (udev_tags & EVDEV_UDEV_TAG_MSDP) {
+		device->seat_caps |= EVDEV_DEVICE_MSDP;
+	}
+
 	if (evdev_device_has_model_quirk(device, QUIRK_MODEL_INVERT_HORIZONTAL_SCROLLING)) {
 		device->scroll.invert_horizontal_scrolling = true;
 	}
@@ -2518,6 +2622,18 @@
 }
 
 unsigned int
+evdev_device_get_id_bustype(struct evdev_device *device)
+{
+	return libevdev_get_id_bustype(device->evdev);
+}
+
+unsigned int
+evdev_device_get_id_version(struct evdev_device *device)
+{
+	return libevdev_get_id_version(device->evdev);
+}
+
+unsigned int
 evdev_device_get_id_product(struct evdev_device *device)
 {
 	return libevdev_get_id_product(device->evdev);
@@ -2535,6 +2651,33 @@
 	return udev_device_ref(device->udev_device);
 }
 
+enum evdev_device_udev_tags
+	evdev_device_get_udev_device_tags(struct evdev_device* device)
+{
+    enum evdev_device_udev_tags udev_tags;
+    udev_tags = evdev_device_get_udev_tags(device, device->udev_device);
+    return udev_tags;
+}
+
+int
+evdev_has_event_type(struct evdev_device *device, unsigned int type)
+{
+    return libevdev_has_event_type(device->evdev, type);
+}
+
+int
+evdev_get_event_value(struct evdev_device *device, unsigned int type, unsigned int code)
+{
+    return libevdev_get_event_value(device->evdev, type, code);
+}
+
+int
+evdev_kernel_set_led_value(struct evdev_device *device, unsigned int code, unsigned int state)
+{
+    enum libevdev_led_value value = (state == 0 ? LIBEVDEV_LED_OFF : LIBEVDEV_LED_ON);
+    return libevdev_kernel_set_led_value(device->evdev, code, value);
+}
+
 void
 evdev_device_set_default_calibration(struct evdev_device *device,
 				     const float calibration[6])
@@ -2702,6 +2845,9 @@
 		return !!(device->seat_caps & EVDEV_DEVICE_TABLET_PAD);
 	case LIBINPUT_DEVICE_CAP_SWITCH:
 		return !!(device->seat_caps & EVDEV_DEVICE_SWITCH);
+	case LIBINPUT_DEVICE_CAP_JOYSTICK:
+		return !!(device->seat_caps & EVDEV_DEVICE_JOYSTICK);
+
 	default:
 		return false;
 	}
@@ -2902,10 +3048,9 @@
 	if (device->scroll.direction != 0) {
 		switch (source) {
 		case LIBINPUT_POINTER_AXIS_SOURCE_FINGER:
-			pointer_notify_axis_finger(&device->base,
-						   time,
-						   device->scroll.direction,
-						   &zero);
+			gesture_notify_axis_finger(&device->base, time,
+					LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END,
+					0, &zero);
 			break;
 		case LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS:
 			pointer_notify_axis_continuous(&device->base,
@@ -3163,3 +3308,85 @@
 #endif
 	return has_left_handed;
 }
+
+static inline bool
+is_touchscreen(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_ABS) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_MT_POSITION_X) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_MT_POSITION_Y) &&
+			libevdev_has_property(evdev, INPUT_PROP_DIRECT));
+}
+
+static inline bool
+is_mouse(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_REL) &&
+			libevdev_has_event_code(evdev, EV_REL, REL_X) &&
+			libevdev_has_event_code(evdev, EV_REL, REL_Y));
+}
+
+static inline bool
+is_keyboard(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_KEY) &&
+			!libevdev_has_event_type(evdev, EV_ABS) &&
+			!libevdev_has_event_type(evdev, EV_REL));
+}
+
+static inline bool
+is_touchpad(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_ABS) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_MT_POSITION_X));
+}
+
+static inline bool
+is_switch(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_SW));
+}
+
+static inline bool
+is_touchhand(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_ABS) &&
+	        libevdev_has_event_code(evdev, EV_ABS, ABS_HAND_FEATURE));
+}
+
+is_tablet_tool(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_KEY) &&
+			(libevdev_has_event_code(evdev, EV_KEY, BTN_TOOL_PEN) ||
+			 libevdev_has_event_code(evdev, EV_KEY, BTN_STYLUS)) &&
+			libevdev_has_event_type(evdev, EV_ABS) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_X) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_Y));
+}
+
+static enum evdev_device_udev_tags
+update_device_capability(struct evdev_device *device)
+{
+	if (is_touchhand(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_MSDP);
+	}
+	if (is_touchscreen(device->evdev)) {
+        return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_TOUCHSCREEN);
+	}
+	if (is_mouse(device->evdev)) {
+        return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_MOUSE);
+	}
+	if (is_keyboard(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_KEYBOARD);
+	}
+	if (is_tablet_tool(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_TABLET);
+	}
+	if (is_touchpad(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_TOUCHPAD);
+	}
+	if (is_switch(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_SWITCH);
+	}
+    return 0;
+}
diff -Naur old/src/evdev.h new/src/evdev.h
--- old/src/evdev.h	2025-03-26 11:12:53.949121875 +0800
+++ new/src/evdev.h	2025-03-26 11:16:26.434458838 +0800
@@ -61,6 +61,8 @@
 	EVDEV_DEVICE_TABLET_PAD		= bit(4),
 	EVDEV_DEVICE_GESTURE		= bit(5),
 	EVDEV_DEVICE_SWITCH		= bit(6),
+	EVDEV_DEVICE_JOYSTICK = bit(7),
+	EVDEV_DEVICE_MSDP		= bit(8),
 };
 
 enum evdev_device_tags {
@@ -74,6 +76,12 @@
 	EVDEV_TAG_EXTERNAL_KEYBOARD	= bit(7),
 	EVDEV_TAG_TABLET_MODE_SWITCH	= bit(8),
 	EVDEV_TAG_TABLET_TOUCHPAD	= bit(9),
+	EVDEV_TAG_PRIVACY_SWITCH	=bit(10),
+};
+
+struct evdev_udev_tag_match {
+    const char* name;
+    enum evdev_device_udev_tags tag;
 };
 
 enum evdev_middlebutton_state {
@@ -177,6 +185,7 @@
 	enum evdev_device_tags tags;
 	bool is_mt;
 	bool is_suspended;
+	int32_t pressureMax;
 	int dpi; /* HW resolution */
 	double trackpoint_multiplier; /* trackpoint constant multiplier */
 	bool use_velocity_averaging; /* whether averaging should be applied on velocity calculation */
@@ -185,6 +194,8 @@
 	struct ratelimit nonpointer_rel_limit; /* ratelimit for REL_* events from non-pointer devices */
 	uint32_t model_flags;
 	struct mtdev *mtdev;
+	double touchpad_ppi;
+	double touchpad_hypot_size;
 
 	struct {
 		const struct input_absinfo *absinfo_x, *absinfo_y;
@@ -271,6 +282,15 @@
 		uint32_t button_mask;
 		uint64_t first_event_time;
 	} middlebutton;
+
+	struct {
+		int32_t seconds;
+		int32_t microseconds;
+	} sensor_timestamp;
+	
+	struct {
+		int32_t hand_feature;
+	} hand_status;
 };
 
 static inline struct evdev_device *
@@ -354,6 +374,8 @@
 	DISPATCH_TABLET,
 	DISPATCH_TABLET_PAD,
 	DISPATCH_TOTEM,
+	DISPATCH_JOYSTICK,
+	DISPATCH_PRIVACY_SWITCH,
 };
 
 struct evdev_dispatch {
@@ -407,6 +429,10 @@
 			 struct device_coords *point);
 
 void
+evdev_transform_absolute_rect(struct evdev_device *device,
+			 struct device_coord_rect *rect);
+
+void
 evdev_transform_relative(struct evdev_device *device,
 			 struct device_coords *point);
 
@@ -431,12 +457,21 @@
 evdev_device_init_pointer_acceleration(struct evdev_device *device,
 				       struct motion_filter *filter);
 
+struct evdev_dispatch*
+evdev_joystick_create(struct evdev_device* device);
+
+struct evdev_dispatch*
+evdev_privacy_switch_create(struct evdev_device* device);
+
 struct evdev_dispatch *
 evdev_touchpad_create(struct evdev_device *device);
 
 struct evdev_dispatch *
 evdev_mt_touchpad_create(struct evdev_device *device);
 
+bool
+evdev_device_touchpad_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType);
+
 struct evdev_dispatch *
 evdev_tablet_create(struct evdev_device *device);
 
@@ -474,6 +509,12 @@
 evdev_device_get_name(struct evdev_device *device);
 
 unsigned int
+evdev_device_get_id_bustype(struct evdev_device *device);
+
+unsigned int
+evdev_device_get_id_version(struct evdev_device *device);
+
+unsigned int
 evdev_device_get_id_product(struct evdev_device *device);
 
 unsigned int
@@ -482,6 +523,19 @@
 struct udev_device *
 evdev_device_get_udev_device(struct evdev_device *device);
 
+/**  @brief   获取设备类型 */
+enum evdev_device_udev_tags
+evdev_device_get_udev_device_tags(struct evdev_device* device);
+
+int
+evdev_has_event_type(struct evdev_device *device, unsigned int type);
+
+int
+evdev_get_event_value(struct evdev_device *device, unsigned int type, unsigned int code);
+
+int
+evdev_kernel_set_led_value(struct evdev_device *device, unsigned int code, unsigned int state);
+
 void
 evdev_device_set_default_calibration(struct evdev_device *device,
 				     const float calibration[6]);
@@ -507,6 +561,9 @@
 int
 evdev_device_get_touch_count(struct evdev_device *device);
 
+bool
+evdev_device_touch_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType);
+
 int
 evdev_device_has_switch(struct evdev_device *device,
 			enum libinput_switch sw);
@@ -561,6 +618,19 @@
 			    uint64_t time,
 			    unsigned int button,
 			    enum libinput_button_state state);
+
+void
+evdev_pointer_notify_button_touchpad(struct evdev_device *device,
+			    uint64_t time,
+			    unsigned int button,
+			    enum libinput_button_state state);
+
+void
+evdev_pointer_notify_tap(struct evdev_device *device,
+			    uint64_t time,
+			    unsigned int button,
+			    enum libinput_button_state state);
+
 void
 evdev_pointer_notify_physical_button(struct evdev_device *device,
 				     uint64_t time,
@@ -646,6 +716,9 @@
 static inline double
 evdev_convert_to_mm(const struct input_absinfo *absinfo, double v)
 {
+	if (absinfo->resolution  == 0){
+	    return 0.0;
+	}
 	double value = v - absinfo->minimum;
 	return value/absinfo->resolution;
 }
@@ -781,12 +854,15 @@
 
 	if (!is_logged(evdev_libinput_context(device), priority))
 		return;
-
+        const char *name = evdev_device_get_sysname(device);
+        if (strchr(name, '%') != NULL) {
+                return;
+        }
 	/* Anything info and above is user-visible, use the device name */
 	snprintf(buf,
 		 sizeof(buf),
 		 "%-7s - %s%s%s",
-		 evdev_device_get_sysname(device),
+		 name,
 		 (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  device->log_prefix_name : "",
 		 (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  ": " : "",
 		 format);
@@ -855,6 +931,9 @@
 #define evdev_log_bug_kernel(d_, ...) evdev_log_msg((d_), LIBINPUT_LOG_PRIORITY_ERROR, "kernel bug: " __VA_ARGS__)
 #define evdev_log_bug_libinput(d_, ...) evdev_log_msg((d_), LIBINPUT_LOG_PRIORITY_ERROR, "libinput bug: " __VA_ARGS__)
 #define evdev_log_bug_client(d_, ...) evdev_log_msg((d_), LIBINPUT_LOG_PRIORITY_ERROR, "client bug: " __VA_ARGS__)
+#define evdev_log_libinput_info(d_, ...) evdev_log_msg((d_), LIBINPUT_LOG_PRIORITY_ERROR, "LOG_LEVEL_I: " __VA_ARGS__)
+#define evdev_log_libinput_debug(d_, ...) evdev_log_msg((d_), LIBINPUT_LOG_PRIORITY_ERROR, "LOG_LEVEL_D: " __VA_ARGS__)
+#define evdev_log_libinput_error(d_, ...) evdev_log_msg((d_), LIBINPUT_LOG_PRIORITY_ERROR, "LOG_LEVEL_E: " __VA_ARGS__)
 
 #define evdev_log_debug_ratelimit(d_, r_, ...) \
 	evdev_log_msg_ratelimit((d_), (r_), LIBINPUT_LOG_PRIORITY_DEBUG, __VA_ARGS__)
@@ -1028,7 +1107,8 @@
 				   "Axis %#x value %d is outside expected range [%d, %d]\n"
 				   "See %s/absolute_coordinate_ranges.html for details\n",
 				   code, value, min, max,
-				   HTTP_DOC_LINK);
+				   "");
+				//HTTP_DOC_LINK);
 	}
 }
 
@@ -1047,4 +1127,7 @@
 	free(kbd);
 }
 
+void evdev_set_rightbutton_area(const int32_t width_percent, 
+                                const int32_t height_percent);
+
 #endif /* EVDEV_H */
diff -Naur old/src/libinput-private.h new/src/libinput-private.h
--- old/src/libinput-private.h	2025-03-26 11:12:53.949121875 +0800
+++ new/src/libinput-private.h	2025-03-26 11:16:26.434458838 +0800
@@ -43,12 +43,26 @@
 #include "libinput-version.h"
 
 struct libinput_source;
+struct privacy_switch;
+
+/* The extra data of mt_slot struction */
+struct extra_data {
+    int32_t blob_id;
+	int32_t move_flag;
+  int32_t orientation;
+};
 
 /* A coordinate pair in device coordinates */
 struct device_coords {
 	int x, y;
 };
 
+/* Size of touch point region (major and minor axes of ellipse) */
+struct touch_axis {
+    int32_t major;
+    int32_t minor;
+};
+
 /*
  * A coordinate pair in device coordinates, capable of holding non discrete
  * values, this is necessary e.g. when device coordinates get averaged.
@@ -424,10 +438,12 @@
 	LIBINPUT_TABLET_TOOL_AXIS_SLIDER = 8,
 	LIBINPUT_TABLET_TOOL_AXIS_REL_WHEEL = 9,
 	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MAJOR = 10,
-	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR = 11,
+	LIBINPUT_TABLET_TOOL_AXIS_TYPE = 11,
+	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR = 12,
+	LIBINPUT_TABLET_TOOL_AXIS_ANGLE = 13,
 };
 
-#define LIBINPUT_TABLET_TOOL_AXIS_MAX LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR
+#define LIBINPUT_TABLET_TOOL_AXIS_MAX LIBINPUT_TABLET_TOOL_AXIS_ANGLE
 
 struct tablet_axes {
 	struct device_coords point;
@@ -440,6 +456,7 @@
 	double wheel;
 	int wheel_discrete;
 	struct phys_ellipsis size;
+	int angle;
 };
 
 enum pressure_heuristic_state {
@@ -463,7 +480,7 @@
 		struct threshold threshold; /* in device coordinates */
 		int offset; /* in device coordinates */
 		bool has_offset;
-
+		int32_t mt_tool_type;
 		enum pressure_heuristic_state heuristic_state;
 	} pressure;
 };
@@ -498,6 +515,20 @@
 	void *notify_func_data;
 };
 
+struct joystick_axis_abs_infos {
+	struct libinput_event_joystick_axis_abs_info abs_throttle;
+	struct libinput_event_joystick_axis_abs_info abs_hat0x;
+	struct libinput_event_joystick_axis_abs_info abs_hat0y;
+	struct libinput_event_joystick_axis_abs_info abs_x;
+	struct libinput_event_joystick_axis_abs_info abs_y;
+	struct libinput_event_joystick_axis_abs_info abs_z;
+	struct libinput_event_joystick_axis_abs_info abs_rx;
+	struct libinput_event_joystick_axis_abs_info abs_ry;
+	struct libinput_event_joystick_axis_abs_info abs_rz;
+	struct libinput_event_joystick_axis_abs_info abs_gas;
+	struct libinput_event_joystick_axis_abs_info abs_brake;
+};
+
 typedef void (*libinput_source_dispatch_t)(void *data);
 
 #define log_debug(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_DEBUG, __VA_ARGS__)
@@ -506,6 +537,9 @@
 #define log_bug_kernel(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "kernel bug: " __VA_ARGS__)
 #define log_bug_libinput(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "libinput bug: " __VA_ARGS__)
 #define log_bug_client(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "client bug: " __VA_ARGS__)
+#define log_libinput_info(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "LOG_LEVEL_I: " __VA_ARGS__)
+#define log_libinput_debug(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "LOG_LEVEL_D: " __VA_ARGS__)
+#define log_libinput_error(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "LOG_LEVEL_E: " __VA_ARGS__)
 
 #define log_debug_ratelimit(li_, r_, ...) log_msg_ratelimit((li_), (r_), LIBINPUT_LOG_PRIORITY_DEBUG, __VA_ARGS__)
 #define log_info_ratelimit(li_, r_, ...) log_msg_ratelimit((li_), (r_), LIBINPUT_LOG_PRIORITY_INFO, __VA_ARGS__)
@@ -628,6 +662,12 @@
 		      const struct device_float_coords *raw);
 
 void
+touchpad_pointer_notify_motion(struct libinput_device *device,
+		      uint64_t time,
+		      const struct normalized_coords *delta,
+		      const struct device_float_coords *raw);
+
+void
 pointer_notify_motion_absolute(struct libinput_device *device,
 			       uint64_t time,
 			       const struct device_coords *point);
@@ -639,6 +679,18 @@
 		      enum libinput_button_state state);
 
 void
+pointer_notify_button_touchpad(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state);
+
+void
+pointer_notify_tap(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state);
+
+void
 pointer_notify_axis_finger(struct libinput_device *device,
 			   uint64_t time,
 			   uint32_t axes,
@@ -664,24 +716,39 @@
 			  const struct wheel_v120 *v120);
 
 void
+touch_notify_msdp(struct libinput_device *device,
+			uint64_t time);
+
+void
 touch_notify_touch_down(struct libinput_device *device,
 			uint64_t time,
 			int32_t slot,
 			int32_t seat_slot,
-			const struct device_coords *point);
+			int32_t pressure,
+			const struct extra_data *extraData,
+            const struct touch_axis *axis,
+			const struct device_coords *point,
+			int32_t tool_type,
+			const struct device_coord_rect *tool_rect);
 
 void
 touch_notify_touch_motion(struct libinput_device *device,
 			  uint64_t time,
 			  int32_t slot,
 			  int32_t seat_slot,
-			  const struct device_coords *point);
+			  int32_t pressure,
+			  const struct extra_data *extraData,
+              const struct touch_axis *axis,
+			  const struct device_coords *point,
+			  int32_t tool_type,
+			  const struct device_coord_rect *tool_rect);
 
 void
 touch_notify_touch_up(struct libinput_device *device,
 		      uint64_t time,
 		      int32_t slot,
-		      int32_t seat_slot);
+		      int32_t seat_slot,
+		      int32_t tool_type);
 
 void
 touch_notify_touch_cancel(struct libinput_device *device,
@@ -694,12 +761,53 @@
 		   uint64_t time);
 
 void
+touchpad_notify_touch_down(struct libinput_device *device,
+			uint64_t time,
+			int32_t slot,
+			int32_t seat_slot,
+			int32_t pressure,
+			int32_t tool_type,
+			struct touch_axis axis,
+			const struct device_coords *point,
+			const struct device_coord_rect *tool_rect);
+
+void
+touchpad_notify_touch_motion(struct libinput_device *device,
+			  uint64_t time,
+			  int32_t slot,
+			  int32_t seat_slot,
+			  int32_t pressure,
+			  int32_t tool_type,
+			  struct touch_axis axis,
+			  const struct device_coords *point,
+			  const struct device_coord_rect *tool_rect);
+
+void
+touchpad_notify_touch_up(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t slot,
+		      int32_t seat_slot,
+		      int32_t tool_type,
+			  struct touch_axis axis);
+
+void
 gesture_notify_swipe(struct libinput_device *device,
 		     uint64_t time,
 		     enum libinput_event_type type,
 		     int finger_count,
 		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel);
+		     const struct normalized_coords *unaccel,
+		     const struct sloted_coords_info *raw_touches);
+
+void
+gesture_notify_swipe_private(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_event_type type,
+		     int finger_count,
+		     const struct normalized_coords *delta,
+		     const struct normalized_coords *unaccel,
+			 struct device_coords *coords,
+			 int coordsLen);
 
 void
 gesture_notify_swipe_end(struct libinput_device *device,
@@ -725,6 +833,13 @@
 			 bool cancelled);
 
 void
+gesture_notify_axis_finger(struct libinput_device *device,
+			  uint64_t time,
+			  enum libinput_event_type type,
+			  uint32_t axes,
+			  const struct normalized_coords *delta);
+
+void
 gesture_notify_hold(struct libinput_device *device,
 		    uint64_t time,
 		    int finger_count);
@@ -799,6 +914,17 @@
 		     enum libinput_switch sw,
 		     enum libinput_switch_state state);
 
+void
+joysticks_notify_axis(struct libinput_device *device,
+			uint64_t time,
+			uint32_t axes,
+			const struct joystick_axis_abs_infos *axis_abs);
+
+void
+privacy_switch_notify_event(struct libinput_device *device,
+			uint64_t time,
+			struct privacy_switch* ev_switch);
+
 static inline uint64_t
 libinput_now(struct libinput *libinput)
 {
diff -Naur old/src/libinput-util.c new/src/libinput-util.c
--- old/src/libinput-util.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/libinput-util.c	2025-03-26 11:16:26.434458838 +0800
@@ -0,0 +1,102 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2013-2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * This list data structure is verbatim copy from wayland-util.h from the
+ * Wayland project; except that wl_ prefix has been removed.
+ */
+
+#include "libinput-util.h"
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+
+static FILE* p_log_fp = NULL;
+
+FILE *libinput_get_log_fp()
+{
+    if (p_log_fp == NULL) {
+        const char *pLogDir = getenv("LIBINPUT_LOG_DIR");
+        if (pLogDir == NULL) {
+            pLogDir = (char *)_LIBINPUT_LOG_DIR;
+        }
+
+        const int r = mkdir(pLogDir, 0755);
+        if (r < 0 && errno != EEXIST) {
+            const int saved_errno = errno;
+            printf("could not create %s, errno: %d\n", pLogDir, saved_errno);
+            return NULL;
+        }
+
+        const char *p_log_path = getenv("LIBINPUT_LOG_PATH");
+        if (p_log_path == NULL) {
+            p_log_path = (char *)_LIBINPUT_LOG_PATH;
+        }
+        p_log_fp = fopen(p_log_path, "w+");
+    }
+
+    return p_log_fp;
+}
+
+void libinput_log_printf(const char* fmt, ...)
+{
+    p_log_fp = libinput_get_log_fp();
+#ifdef HAVE_LIBINPUT_LOG_CONSOLE_ENABLE
+    char buf[1024] = {0};
+
+    va_list args;
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    buf[1024 - 1] = '\0';
+
+    printf("%s\n", buf);
+
+    if (p_log_fp != NULL) {
+        fputs(buf, p_log_fp);
+        fflush(p_log_fp);
+    }
+#else
+    if (p_log_fp != NULL) {
+        va_list args;
+        va_start(args, fmt);
+        vfprintf(p_log_fp, fmt, args);
+        va_end(args);
+        fflush(p_log_fp);
+    }
+#endif
+}
+
+uint64_t getMicrotime()
+{
+    struct timeval currentTime;
+    gettimeofday(&currentTime, NULL);
+    return currentTime.tv_sec * 1000000 + currentTime.tv_usec;
+}
+
+uint64_t getTranTime(struct input_event *event)
+{
+    return event->input_event_sec * 1000000 + event->input_event_usec;
+}
+#endif
diff -Naur old/src/libinput-util.h new/src/libinput-util.h
--- old/src/libinput-util.h	2025-03-26 11:12:53.949121875 +0800
+++ new/src/libinput-util.h	2025-03-26 11:16:26.434458838 +0800
@@ -27,9 +27,9 @@
 
 #include "config.h"
 
-#ifdef NDEBUG
-#warning "libinput relies on assert(). #defining NDEBUG is not recommended"
-#endif
+// #ifdef NDEBUG
+// #warning "libinput relies on assert(). #defining NDEBUG is not recommended"
+// #endif
 
 #include "libinput.h"
 
@@ -56,6 +56,15 @@
 #define DEFAULT_MOUSE_DPI 1000
 #define DEFAULT_TRACKPOINT_SENSITIVITY 128
 
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+void libinput_log_printf(const char* fmt, ...);
+uint64_t getMicrotime();
+uint64_t getTranTime(struct input_event *event);
+#else
+#define libinput_log_printf(fmt, ...)
+#endif
+
 #define trace(...) \
 	do { \
 	printf("%s() - \033[0;31m", __func__); \
diff -Naur old/src/libinput.c new/src/libinput.c
--- old/src/libinput.c	2025-03-26 11:12:53.949121875 +0800
+++ new/src/libinput.c	2025-03-26 11:16:26.438458863 +0800
@@ -36,9 +36,12 @@
 
 #include "libinput.h"
 #include "libinput-private.h"
+#include "evdev-mt-touchpad.h"
 #include "evdev.h"
 #include "timer.h"
 #include "quirks.h"
+#include "evdev-joystick.h"
+#include "evdev-privacy-switch.h"
 
 #define require_event_type(li_, type_, retval_, ...)	\
 	if (type_ == LIBINPUT_EVENT_NONE) abort(); \
@@ -84,9 +87,16 @@
 	CASE_RETURN_STRING(LIBINPUT_EVENT_DEVICE_ADDED);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_DEVICE_REMOVED);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_KEYBOARD_KEY);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_TAP);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_MOTION);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_BUTTON);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_JOYSTICK_AXIS);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_JOYSTICK_BUTTON);	
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_AXIS);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_SCROLL_WHEEL);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_SCROLL_FINGER);
@@ -96,6 +106,9 @@
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_MOTION);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_CANCEL);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_FRAME);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_DOWN);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_UP);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_MOTION);	
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_AXIS);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_TIP);
@@ -113,6 +126,7 @@
 	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_HOLD_BEGIN);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_HOLD_END);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_SWITCH_TOGGLE);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_MSDP);
 	case LIBINPUT_EVENT_NONE:
 		abort();
 	}
@@ -193,6 +207,13 @@
 	int32_t slot;
 	int32_t seat_slot;
 	struct device_coords point;
+	struct device_coord_rect tool_rect;
+	int32_t pressure;
+	struct touch_axis axis;
+	int32_t tool_type;
+	int32_t blob_id;
+	int32_t move_flag;
+  int32_t orientation;
 };
 
 struct libinput_event_gesture {
@@ -202,8 +223,10 @@
 	int cancelled;
 	struct normalized_coords delta;
 	struct normalized_coords delta_unaccel;
+	struct sloted_coords_info solt_touches;
 	double scale;
 	double angle;
+	struct device_coords coords[5];
 };
 
 struct libinput_event_tablet_tool {
@@ -217,6 +240,7 @@
 	struct libinput_tablet_tool *tool;
 	enum libinput_tablet_tool_proximity_state proximity_state;
 	enum libinput_tablet_tool_tip_state tip_state;
+	int32_t mt_tool_type;
 };
 
 struct libinput_event_tablet_pad {
@@ -337,6 +361,45 @@
 	libinput->log_handler = log_handler;
 }
 
+struct vkeyboard_data {
+	bool numLock;
+	bool capsLock;
+	bool scrollLock;
+};
+
+struct vkeyboard_data vkeyboardData = {false, false, false};
+
+LIBINPUT_EXPORT void
+libinput_toggle_caps_key()
+{
+	vkeyboardData.capsLock = !vkeyboardData.capsLock;
+}
+
+LIBINPUT_EXPORT void
+libinput_set_touch_event_type(struct libinput_event_touch* event_touch, enum libinput_event_type eventType)
+{
+	event_touch->base.type = eventType;
+}
+
+LIBINPUT_EXPORT struct libinput_event_keyboard*
+libinput_create_keyboard_event(struct libinput_event_touch* event_touch,
+             int32_t key, enum libinput_key_state state)
+{
+    struct libinput_event_keyboard *key_event;
+
+    key_event = zalloc(sizeof *key_event);
+
+    *key_event = (struct libinput_event_keyboard) {
+        .base.device = event_touch->base.device,
+        .base.type = LIBINPUT_EVENT_KEYBOARD_KEY,
+        .time = event_touch->time,
+        .key = key,
+        .state = state,
+    };
+
+    return key_event;
+}
+
 static void
 libinput_device_group_destroy(struct libinput_device_group *group);
 
@@ -362,6 +425,7 @@
 	return event->device;
 }
 
+
 LIBINPUT_EXPORT struct libinput_event_pointer *
 libinput_event_get_pointer_event(struct libinput_event *event)
 {
@@ -374,7 +438,12 @@
 			   LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
 			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER,
 			   LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
-			   LIBINPUT_EVENT_POINTER_AXIS);
+			   LIBINPUT_EVENT_POINTER_AXIS,
+			   LIBINPUT_EVENT_POINTER_TAP,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD,
+			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN,
+			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END);
 
 	return (struct libinput_event_pointer *) event;
 }
@@ -404,6 +473,18 @@
 	return (struct libinput_event_touch *) event;
 }
 
+LIBINPUT_EXPORT struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+	return (struct libinput_event_touch *) event;
+}
+
 LIBINPUT_EXPORT struct libinput_event_gesture *
 libinput_event_get_gesture_event(struct libinput_event *event)
 {
@@ -417,7 +498,10 @@
 			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_HOLD_BEGIN,
-			   LIBINPUT_EVENT_GESTURE_HOLD_END);
+			   LIBINPUT_EVENT_GESTURE_HOLD_END,
+			   LIBINPUT_EVENT_POINTER_TAP,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return (struct libinput_event_gesture *) event;
 }
@@ -473,6 +557,19 @@
 	return (struct libinput_event_switch *) event;
 }
 
+LIBINPUT_EXPORT int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&(event->base)),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
+               LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+	return event->mt_tool_type;
+}
+
 LIBINPUT_EXPORT uint32_t
 libinput_event_keyboard_get_time(struct libinput_event_keyboard *event)
 {
@@ -558,18 +655,37 @@
 			   LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
 			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER,
 			   LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
-			   LIBINPUT_EVENT_POINTER_AXIS);
+			   LIBINPUT_EVENT_POINTER_AXIS,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->time;
 }
 
+LIBINPUT_EXPORT uint64_t
+libinput_event_get_sensortime(struct libinput_event *event)
+{
+	struct evdev_device *device = evdev_device(event->device);
+	int32_t seconds = device->sensor_timestamp.seconds;
+	int32_t microseconds = device->sensor_timestamp.microseconds;
+	return ((uint64_t)seconds * 1000 * 1000) + microseconds;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_get_hand_feature(struct libinput_event *event)
+{
+	struct evdev_device *device = evdev_device(event->device);
+	int32_t value = device->hand_status.hand_feature;
+	return value;
+}
+
 LIBINPUT_EXPORT double
 libinput_event_pointer_get_dx(struct libinput_event_pointer *event)
 {
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_MOTION);
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->delta.x;
 }
@@ -580,7 +696,8 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_MOTION);
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->delta.y;
 }
@@ -592,7 +709,8 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_MOTION);
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->delta_raw.x;
 }
@@ -604,7 +722,8 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_MOTION);
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->delta_raw.y;
 }
@@ -671,7 +790,9 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_BUTTON);
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_TAP,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return event->button;
 }
@@ -682,7 +803,9 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_BUTTON);
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_TAP,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return event->state;
 }
@@ -694,11 +817,45 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_BUTTON);
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return event->seat_button_count;
 }
 
+LIBINPUT_EXPORT uint32_t
+libinput_event_pointer_get_button_area(
+	struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
+
+	struct evdev_device *device = evdev_device(event->base.device);
+	struct evdev_dispatch *dispatch = device->dispatch;
+	struct tp_dispatch *tp = (struct tp_dispatch *)(dispatch);
+
+	return tp->buttons.area;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_pointer_get_finger_count(
+	struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
+
+	struct evdev_device *device = evdev_device(event->base.device);
+	struct evdev_dispatch *dispatch = device->dispatch;
+	struct tp_dispatch *tp = (struct tp_dispatch *)(dispatch);
+
+	return tp->nfingers_down;
+}
 LIBINPUT_EXPORT int
 libinput_event_pointer_has_axis(struct libinput_event_pointer *event,
 				enum libinput_pointer_axis axis)
@@ -900,6 +1057,12 @@
 	return event->seat_slot;
 }
 
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_orientation(struct libinput_event_touch *event)
+{
+	return event->orientation;
+}
+
 LIBINPUT_EXPORT double
 libinput_event_touch_get_x(struct libinput_event_touch *event)
 {
@@ -930,6 +1093,20 @@
 }
 
 LIBINPUT_EXPORT double
+libinput_event_touch_get_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->point.y);
+}
+
+LIBINPUT_EXPORT double
 libinput_event_touch_get_y_transformed(struct libinput_event_touch *event,
 				       uint32_t height)
 {
@@ -945,7 +1122,65 @@
 }
 
 LIBINPUT_EXPORT double
-libinput_event_touch_get_y(struct libinput_event_touch *event)
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_x(device, event->tool_rect.x, width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.y);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_y(device, event->tool_rect.y, height);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event)
 {
 	struct evdev_device *device = evdev_device(event->base.device);
 
@@ -955,9 +1190,300 @@
 			   LIBINPUT_EVENT_TOUCH_DOWN,
 			   LIBINPUT_EVENT_TOUCH_MOTION);
 
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.w);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_x(device, event->tool_rect.w, width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.h);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_y(device, event->tool_rect.h, height);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->slot;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->seat_slot;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->point.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
 	return evdev_convert_to_mm(device->abs.absinfo_y, event->point.y);
 }
 
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.y);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.w);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.h);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		return 0.0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		return 0.0;
+	}
+	double range = evDevice->pressureMax;
+	if (range == 0.0) {
+		return 0.0;
+	}
+	double value = event->pressure / range;
+	return max(0.0, value);
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		libinput_log_printf("device is nullptr\n");
+		return 0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		libinput_log_printf("evdev_device is nullptr\n");
+		return 0;
+	}
+	const struct input_absinfo* absInfo = libevdev_get_abs_info(evDevice->evdev, ABS_MT_TOUCH_MAJOR);
+	if (absInfo == NULL) {
+		libinput_log_printf("ABS_MT_TOUCH_MAJOR absInfo is nullptr\n");
+		return 0;
+	}
+	if (event->axis.major > absInfo->maximum || event->axis.major < 0) {
+		libinput_log_printf(" major = %d > absInfo->maximum\n", event->axis.major);
+		return 0;
+	}
+    return event->axis.major;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		libinput_log_printf("device is nullptr\n");
+		return 0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		libinput_log_printf("evdev_device is nullptr\n");
+		return 0;
+	}
+	const struct input_absinfo* absInfo = libevdev_get_abs_info(evDevice->evdev, ABS_MT_TOUCH_MINOR);
+	if (absInfo == NULL) {
+		libinput_log_printf("ABS_MT_TOUCH_MAJOR absInfo is nullptr\n");
+		return 0;
+	}
+	if (event->axis.minor > absInfo->maximum || event->axis.minor < 0) {
+		libinput_log_printf(" major = %d > absInfo->maximum\n", event->axis.minor);
+		return 0;
+	}
+    return event->axis.minor;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->tool_type;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType)
+{
+	if (device == NULL) {
+		return -1;
+	}
+	return evdev_device_touchpad_btn_tool_type_down((struct evdev_device *)device, btnToolType);
+}
+
 LIBINPUT_EXPORT uint32_t
 libinput_event_gesture_get_time(struct libinput_event_gesture *event)
 {
@@ -1118,6 +1644,44 @@
 }
 
 LIBINPUT_EXPORT int
+libinput_event_gesture_get_device_coords_x(struct libinput_event_gesture *event, uint32_t idx)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->coords[idx].x;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_gesture_get_device_coords_y(struct libinput_event_gesture *event, uint32_t idx)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->coords[idx].y;
+}
+
+LIBINPUT_EXPORT struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(
+	struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE);
+
+	return &event->solt_touches;
+}
+
+LIBINPUT_EXPORT int
 libinput_event_tablet_tool_x_has_changed(
 				struct libinput_event_tablet_tool *event)
 {
@@ -1134,6 +1698,24 @@
 }
 
 LIBINPUT_EXPORT int
+libinput_has_event_led_type(struct libinput_device *device)
+{
+    return evdev_has_event_type((struct evdev_device *)device, EV_LED);
+}
+
+LIBINPUT_EXPORT int
+libinput_get_funckey_state(struct libinput_device *device,  unsigned int code)
+{
+    return evdev_get_event_value((struct evdev_device *)device, EV_LED, code);
+}
+
+LIBINPUT_EXPORT int
+libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state)
+{
+    return evdev_kernel_set_led_value((struct evdev_device *)device, code, state);
+}
+
+LIBINPUT_EXPORT int
 libinput_event_tablet_tool_y_has_changed(
 				struct libinput_event_tablet_tool *event)
 {
@@ -1637,6 +2219,20 @@
 	return event->seat_button_count;
 }
 
+LIBINPUT_EXPORT int32_t
+libinput_event_tablet_tool_get_angle(struct libinput_event_tablet_tool *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+		LIBINPUT_EVENT_TABLET_TOOL_TIP,
+		LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+		LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.angle;
+}
+
 LIBINPUT_EXPORT enum libinput_tablet_tool_type
 libinput_tablet_tool_get_type(struct libinput_tablet_tool *tool)
 {
@@ -1892,11 +2488,8 @@
 	/* If we fail, we'll fail next time too */
 	libinput->quirks_initialized = true;
 
-	data_path = getenv("LIBINPUT_QUIRKS_DIR");
-	if (!data_path) {
-		data_path = LIBINPUT_QUIRKS_DIR;
-		override_file = LIBINPUT_QUIRKS_OVERRIDE_FILE;
-	}
+		data_path = (char *)LIBINPUT_QUIRKS_DIR;
+		override_file = (char *)LIBINPUT_QUIRKS_OVERRIDE_FILE;
 
 	quirks = quirks_init_subsystem(data_path,
 				       override_file,
@@ -2396,6 +2989,9 @@
 	case LIBINPUT_DEVICE_CAP_SWITCH:
 		capability = "CAP_SWITCH";
 		break;
+	case LIBINPUT_DEVICE_CAP_JOYSTICK:
+        capability = "CAP_JOYSTICK";
+        break;
 	}
 
 	log_bug_libinput(device->seat->libinput,
@@ -2459,6 +3055,30 @@
 }
 
 void
+touchpad_pointer_notify_motion(struct libinput_device *device,
+		      uint64_t time,
+		      const struct normalized_coords *delta,
+		      const struct device_float_coords *raw)
+{
+	struct libinput_event_pointer *motion_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	motion_event = zalloc(sizeof *motion_event);
+
+	*motion_event = (struct libinput_event_pointer) {
+		.time = time,
+		.delta = *delta,
+		.delta_raw = *raw,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD,
+			  &motion_event->base);
+}
+
+void
 pointer_notify_motion_absolute(struct libinput_device *device,
 			       uint64_t time,
 			       const struct device_coords *point)
@@ -2511,6 +3131,94 @@
 }
 
 void
+pointer_notify_button_touchpad(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state)
+{
+	struct libinput_event_pointer *button_event;
+	int32_t seat_button_count;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	button_event = zalloc(sizeof *button_event);
+
+	seat_button_count = update_seat_button_count(device->seat,
+						     button,
+						     state);
+
+	*button_event = (struct libinput_event_pointer) {
+		.time = time,
+		.button = button,
+		.state = state,
+		.seat_button_count = seat_button_count,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD,
+			  &button_event->base);
+}
+
+void
+pointer_notify_tap(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state)
+{
+	struct libinput_event_pointer *button_event;
+	int32_t seat_button_count;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	button_event = zalloc(sizeof *button_event);
+
+	seat_button_count = update_seat_button_count(device->seat,
+						     button,
+						     state);
+
+	*button_event = (struct libinput_event_pointer) {
+		.time = time,
+		.button = button,
+		.state = state,
+		.seat_button_count = seat_button_count,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_TAP,
+			  &button_event->base);
+}
+
+void
+gesture_notify_axis_finger(struct libinput_device *device,
+			  uint64_t time,
+			  enum libinput_event_type type,
+			  uint32_t axes,
+			  const struct normalized_coords *delta)
+{
+	struct libinput_event_pointer *axis_event;
+	const struct discrete_coords zero_discrete = {0};
+	const struct wheel_v120 zero_v120 = {0};
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	axis_event = zalloc(sizeof *axis_event);
+
+	*axis_event = (struct libinput_event_pointer) {
+		.time = time,
+		.delta = *delta,
+		.source = LIBINPUT_POINTER_AXIS_SOURCE_FINGER,
+		.axes = axes,
+		.discrete = zero_discrete,
+		.v120 = zero_v120,
+	};
+
+	post_device_event(device, time, type, &axis_event->base);
+}
+
+void
 pointer_notify_axis_finger(struct libinput_device *device,
 			  uint64_t time,
 			  uint32_t axes,
@@ -2639,11 +3347,33 @@
 }
 
 void
+touch_notify_msdp(struct libinput_device *device,
+			uint64_t time)
+{
+	struct libinput_event_touch *touch_event;
+
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_MSDP,
+			  &touch_event->base);
+}
+
+void
 touch_notify_touch_down(struct libinput_device *device,
 			uint64_t time,
 			int32_t slot,
 			int32_t seat_slot,
-			const struct device_coords *point)
+			int32_t pressure,
+			const struct extra_data *extraData,
+            const struct touch_axis *axis,
+			const struct device_coords *point,
+			int32_t tool_type,
+			const struct device_coord_rect *tool_rect)
 {
 	struct libinput_event_touch *touch_event;
 
@@ -2657,6 +3387,13 @@
 		.slot = slot,
 		.seat_slot = seat_slot,
 		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.blob_id = extraData->blob_id,
+		.move_flag = extraData->move_flag,
+		.axis = *axis,
+		.tool_type = tool_type,
+    .orientation = extraData->orientation,
 	};
 
 	post_device_event(device, time,
@@ -2669,7 +3406,12 @@
 			  uint64_t time,
 			  int32_t slot,
 			  int32_t seat_slot,
-			  const struct device_coords *point)
+			  int32_t pressure,
+			  const struct extra_data *extraData,
+              const struct touch_axis *axis,
+			  const struct device_coords *point,
+			  int32_t tool_type,
+			  const struct device_coord_rect *tool_rect)
 {
 	struct libinput_event_touch *touch_event;
 
@@ -2683,6 +3425,12 @@
 		.slot = slot,
 		.seat_slot = seat_slot,
 		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.axis = *axis,
+		.tool_type = tool_type,
+		.blob_id = extraData->blob_id,
+		.move_flag = extraData->move_flag,
 	};
 
 	post_device_event(device, time,
@@ -2694,7 +3442,8 @@
 touch_notify_touch_up(struct libinput_device *device,
 		      uint64_t time,
 		      int32_t slot,
-		      int32_t seat_slot)
+		      int32_t seat_slot,
+		      int32_t tool_type)
 {
 	struct libinput_event_touch *touch_event;
 
@@ -2707,6 +3456,7 @@
 		.time = time,
 		.slot = slot,
 		.seat_slot = seat_slot,
+		.tool_type = tool_type,
 	};
 
 	post_device_event(device, time,
@@ -2759,6 +3509,90 @@
 }
 
 void
+touchpad_notify_touch_down(struct libinput_device *device,
+			uint64_t time,
+			int32_t slot,
+			int32_t seat_slot,
+			int32_t pressure,
+			int32_t tool_type,
+			struct touch_axis axis,
+			const struct device_coords *point,
+			const struct device_coord_rect *tool_rect)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.axis = axis,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			  &touch_event->base);
+}
+
+void
+touchpad_notify_touch_motion(struct libinput_device *device,
+			  uint64_t time,
+			  int32_t slot,
+			  int32_t seat_slot,
+			  int32_t pressure,
+			  int32_t tool_type,
+			  struct touch_axis axis,
+			  const struct device_coords *point,
+			  const struct device_coord_rect *tool_rect)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.point = *point,
+		.tool_rect = *tool_rect,
+		.axis = axis,
+		.pressure = pressure,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_MOTION,
+			  &touch_event->base);
+}
+
+void
+touchpad_notify_touch_up(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t slot,
+		      int32_t seat_slot,
+		      int32_t tool_type,
+			  struct touch_axis axis)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.axis = axis,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_UP,
+			  &touch_event->base);
+}
+
+void
 tablet_notify_axis(struct libinput_device *device,
 		   uint64_t time,
 		   struct libinput_tablet_tool *tool,
@@ -2776,6 +3610,7 @@
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.tip_state = tip_state,
 		.axes = *axes,
+		.mt_tool_type = tool->pressure.mt_tool_type,
 	};
 
 	memcpy(axis_event->changed_axes,
@@ -2806,6 +3641,7 @@
 		.tip_state = LIBINPUT_TABLET_TOOL_TIP_UP,
 		.proximity_state = proximity_state,
 		.axes = *axes,
+		.mt_tool_type = tool->pressure.mt_tool_type,
 	};
 	memcpy(proximity_event->changed_axes,
 	       changed_axes,
@@ -2835,6 +3671,7 @@
 		.tip_state = tip_state,
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.axes = *axes,
+		.mt_tool_type = tool->pressure.mt_tool_type,
 	};
 	memcpy(tip_event->changed_axes,
 	       changed_axes,
@@ -2873,6 +3710,7 @@
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.tip_state = tip_state,
 		.axes = *axes,
+		.mt_tool_type = tool->pressure.mt_tool_type,
 	};
 
 	post_device_event(device,
@@ -2999,6 +3837,7 @@
 	       bool cancelled,
 	       const struct normalized_coords *delta,
 	       const struct normalized_coords *unaccel,
+	       const struct sloted_coords_info *solt_touches,
 	       double scale,
 	       double angle)
 {
@@ -3019,6 +3858,48 @@
 		.angle = angle,
 	};
 
+	if (solt_touches != NULL) {
+		gesture_event->solt_touches = *solt_touches;
+	} else {
+        memset(&gesture_event->solt_touches, 0, sizeof(struct sloted_coords_info));
+    }
+
+	post_device_event(device, time, type,
+			  &gesture_event->base);
+}
+
+static void
+gesture_notify_private(struct libinput_device *device,
+	       uint64_t time,
+	       enum libinput_event_type type,
+	       int finger_count,
+	       int cancelled,
+	       const struct normalized_coords *delta,
+	       const struct normalized_coords *unaccel,
+	       double scale,
+	       double angle,
+		   struct device_coords *coords,
+		   int coordsLen)
+{
+	struct libinput_event_gesture *gesture_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_GESTURE))
+		return;
+
+	gesture_event = zalloc(sizeof *gesture_event);
+
+	*gesture_event = (struct libinput_event_gesture) {
+		.time = time,
+		.finger_count = finger_count,
+		.cancelled = cancelled,
+		.delta = *delta,
+		.delta_unaccel = *unaccel,
+		.scale = scale,
+		.angle = angle,
+	};
+
+	memcpy(gesture_event->coords, coords, coordsLen * sizeof(struct device_coords));
+
 	post_device_event(device, time, type,
 			  &gesture_event->base);
 }
@@ -3029,13 +3910,28 @@
 		     enum libinput_event_type type,
 		     int finger_count,
 		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel)
+		     const struct normalized_coords *unaccel,
+		     const struct sloted_coords_info *solt_touches)
 {
-	gesture_notify(device, time, type, finger_count, 0, delta, unaccel,
+	gesture_notify(device, time, type, finger_count, 0, delta, unaccel, solt_touches,
 		       0.0, 0.0);
 }
 
 void
+gesture_notify_swipe_private(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_event_type type,
+		     int finger_count,
+		     const struct normalized_coords *delta,
+		     const struct normalized_coords *unaccel,
+		     struct device_coords *coords,
+		     int coordsLen)
+{
+	gesture_notify_private(device, time, type, finger_count, 0, delta, unaccel,
+		       0.0, 0.0, coords, coordsLen);
+}
+
+void
 gesture_notify_swipe_end(struct libinput_device *device,
 			 uint64_t time,
 			 int finger_count,
@@ -3044,7 +3940,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_SWIPE_END,
-		       finger_count, cancelled, &zero, &zero, 0.0, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, 0.0, 0.0);
 }
 
 void
@@ -3058,7 +3954,7 @@
 		     double angle)
 {
 	gesture_notify(device, time, type, finger_count, 0,
-		       delta, unaccel, scale, angle);
+		       delta, unaccel, NULL, scale, angle);
 }
 
 void
@@ -3071,7 +3967,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_PINCH_END,
-		       finger_count, cancelled, &zero, &zero, scale, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, scale, 0.0);
 }
 
 void
@@ -3082,7 +3978,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_HOLD_BEGIN,
-		       finger_count, 0, &zero, &zero, 0.0, 0.0);
+		       finger_count, 0, &zero, &zero, NULL, 0.0, 0.0);
 }
 
 void
@@ -3094,7 +3990,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_HOLD_END,
-		       finger_count, cancelled, &zero, &zero, 0, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, 0, 0.0);
 }
 
 void
@@ -3127,6 +4023,63 @@
 #endif
 }
 
+void
+joysticks_notify_axis(struct libinput_device *device,
+		    uint64_t time,
+		    uint32_t axes,
+			const struct joystick_axis_abs_infos *axis_abs)
+{
+	struct libinput_event_joystick_axis* joystick_axis_event;
+
+	joystick_axis_event = zalloc(sizeof * joystick_axis_event);
+
+	*joystick_axis_event = (struct libinput_event_joystick_axis){
+		.type = EV_ABS,
+		.time = time,
+		.axis_value_mask = axes,
+		.abs_throttle = axis_abs->abs_throttle,
+		.abs_hat0x = axis_abs->abs_hat0x,
+		.abs_hat0y = axis_abs->abs_hat0y,
+		.abs_x = axis_abs->abs_x,
+		.abs_y = axis_abs->abs_y,
+		.abs_z = axis_abs->abs_z,
+		.abs_rx = axis_abs->abs_rx,
+		.abs_ry = axis_abs->abs_ry,
+		.abs_rz = axis_abs->abs_rz,
+		.abs_gas = axis_abs->abs_gas,
+		.abs_brake = axis_abs->abs_brake,
+	};
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_x.code, axis_abs->abs_x.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_y.code, axis_abs->abs_y.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_z.code, axis_abs->abs_z.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_rz.code, axis_abs->abs_rz.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_gas.code, axis_abs->abs_gas.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_brake.code, axis_abs->abs_brake.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_hat0x.code, axis_abs->abs_hat0x.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_hat0y.code, axis_abs->abs_hat0y.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_throttle.code, axis_abs->abs_throttle.value);
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_JOYSTICK_AXIS,
+			  &joystick_axis_event->base);
+}
+
+void privacy_switch_notify_event(struct libinput_device *device, uint64_t time, struct privacy_switch* ev_switch)
+{
+	struct libinput_event_switch *switch_event;
+
+	switch_event = zalloc(sizeof *switch_event);
+
+	*switch_event = (struct libinput_event_switch) {
+		.time = ev_switch->time,
+		.sw = ev_switch->sw,
+		.state = ev_switch->state,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_SWITCH_TOGGLE,
+			  &switch_event->base);
+}
+
 static void
 libinput_post_event(struct libinput *libinput,
 		    struct libinput_event *event)
@@ -3180,6 +4133,96 @@
 	libinput->events_in = (libinput->events_in + 1) % libinput->events_len;
 }
 
+
+LIBINPUT_EXPORT void
+libinput_post_handle_event(struct libinput* libinput, struct libinput_event* event)
+{
+	libinput_post_event(libinput, event);
+}
+
+LIBINPUT_EXPORT struct libinput_event_joystick_button*
+libinput_event_get_joystick_button_event(struct libinput_event* event)
+{
+    require_event_type(libinput_event_get_context(event),
+        event->type,
+        NULL,
+        LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return (struct libinput_event_joystick_button*)event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_joystick_axis*
+libinput_event_get_joystick_axis_event(struct libinput_event* event)
+{
+	require_event_type(libinput_event_get_context(event),
+        event->type,
+        NULL,
+        LIBINPUT_EVENT_JOYSTICK_AXIS);
+
+    return (struct libinput_event_joystick_axis*)event;
+}
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis)
+{
+	if (event == NULL) {
+		return 0;
+	}
+
+	return (event->axis_value_mask & (uint32_t)axis);
+}
+
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event)
+{
+	if (event == NULL) {
+		return 0;
+	}
+
+	return event->time;
+}
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis)
+{
+	switch (axis) {
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X:
+	return &event->abs_x;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y:
+	return &event->abs_y;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z:
+	return &event->abs_z;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX:
+	return &event->abs_rx;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY:
+	return &event->abs_ry;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ:
+	return &event->abs_rz;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE:
+	return &event->abs_throttle;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X:
+	return &event->abs_hat0x;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y:
+	return &event->abs_hat0y;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS:
+	return &event->abs_gas;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE:
+	return &event->abs_brake;
+	default:
+	break;
+	}
+
+	return NULL;
+}
+
 LIBINPUT_EXPORT struct libinput_event *
 libinput_get_event(struct libinput *libinput)
 {
@@ -3263,12 +4306,169 @@
 	return evdev_device_get_sysname((struct evdev_device *) device);
 }
 
+LIBINPUT_EXPORT const char*
+libinput_device_get_phys(struct libinput_device* device)
+{
+	struct libevdev* evdev = ((struct evdev_device*)device)->evdev;
+	if (evdev == NULL) {
+		return NULL;
+	}
+	return libevdev_get_phys(evdev);
+}
+
+LIBINPUT_EXPORT const char*
+libinput_device_get_uniq(struct libinput_device* device)
+{
+	struct libevdev* evdev = ((struct evdev_device*)device)->evdev;
+	if (evdev == NULL) {
+		return NULL;
+	}
+	return libevdev_get_uniq(evdev);
+}
+
 LIBINPUT_EXPORT const char *
 libinput_device_get_name(struct libinput_device *device)
 {
 	return evdev_device_get_name((struct evdev_device *) device);
 }
 
+LIBINPUT_EXPORT enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device)
+{
+	if(device == NULL)
+	{
+		return EVDEV_UDEV_TAG_INPUT;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	enum evdev_device_udev_tags udev_tags;
+	udev_tags = evdev_device_get_udev_device_tags(evdevDevice);
+    return udev_tags;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode)
+{
+	if(device == NULL)
+	{
+		return EVDEV_UDEV_TAG_INPUT;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_KEY)) {
+		return 0;
+	}
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_KEY, keyCode)) {
+		return 1;
+	}
+	return 0;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->minimum;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->maximum;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->fuzz;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->flat;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->resolution;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device)
+{
+	return evdev_device_get_id_bustype((struct evdev_device *) device);
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_get_id_version(struct libinput_device* device)
+{
+	return evdev_device_get_id_version((struct evdev_device *) device);
+}
+
 LIBINPUT_EXPORT unsigned int
 libinput_device_get_id_product(struct libinput_device *device)
 {
@@ -3356,6 +4556,15 @@
 }
 
 LIBINPUT_EXPORT int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType)
+{
+	if (device == NULL) {
+		return -1;
+	}
+	return evdev_device_touch_btn_tool_type_down((struct evdev_device *)device, btnToolType);
+}
+
+LIBINPUT_EXPORT int
 libinput_device_switch_has_switch(struct libinput_device *device,
 				  enum libinput_switch sw)
 {
@@ -3537,7 +4746,8 @@
 			   LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
 			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER,
 			   LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
-			   LIBINPUT_EVENT_POINTER_AXIS);
+			   LIBINPUT_EVENT_POINTER_AXIS,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return &event->base;
 }
@@ -3558,6 +4768,19 @@
 }
 
 LIBINPUT_EXPORT struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
 libinput_event_gesture_get_base_event(struct libinput_event_gesture *event)
 {
 	require_event_type(libinput_event_get_context(&event->base),
@@ -4764,3 +5987,301 @@
 	}
 }
 #endif
+
+LIBINPUT_EXPORT struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event)
+{
+	if (!event)
+		return 0;
+
+	require_event_type(libinput_event_get_context(event),
+		event->type,
+		NULL,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+	return (struct libinput_event_joystick_button*)event;
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_joystick_button_time(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+        event->base.type,
+        0,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return event->time;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return event->key;
+}
+
+LIBINPUT_EXPORT enum libinput_button_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event)
+{
+	if (!event)
+		return 0;
+
+	require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+	return event->state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return event->seat_key_count;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+        LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return event->value;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_pressure(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_TOUCH_DOWN,
+		LIBINPUT_EVENT_TOUCH_UP,
+		LIBINPUT_EVENT_TOUCH_MOTION,
+		LIBINPUT_EVENT_TOUCH_CANCEL,
+		LIBINPUT_EVENT_TOUCH_FRAME);
+
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		return 0.0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		return 0.0;
+	}
+
+	const struct input_absinfo* absInfo = evDevice->is_mt ? libevdev_get_abs_info(evDevice->evdev, ABS_MT_PRESSURE)
+		: libevdev_get_abs_info(evDevice->evdev, ABS_PRESSURE);
+	if (!absInfo) {
+		return 0.0;
+	}
+	double range = absInfo->maximum;
+	double value = event->pressure / range;
+	return max(0.0, value);
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_blob_id(struct libinput_event_touch* event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_TOUCH_DOWN,
+		LIBINPUT_EVENT_TOUCH_UP,
+		LIBINPUT_EVENT_TOUCH_MOTION,
+		LIBINPUT_EVENT_TOUCH_CANCEL,
+		LIBINPUT_EVENT_TOUCH_FRAME);
+
+	return event->blob_id;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_move_flag(struct libinput_event_touch* event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_TOUCH_DOWN,
+		LIBINPUT_EVENT_TOUCH_UP,
+		LIBINPUT_EVENT_TOUCH_MOTION,
+		LIBINPUT_EVENT_TOUCH_CANCEL,
+		LIBINPUT_EVENT_TOUCH_FRAME);
+
+	return event->move_flag;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return event->tool_type;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+                event->base.type,
+                0,
+                LIBINPUT_EVENT_TOUCH_DOWN,
+                LIBINPUT_EVENT_TOUCH_UP,
+                LIBINPUT_EVENT_TOUCH_MOTION,
+                LIBINPUT_EVENT_TOUCH_CANCEL,
+				LIBINPUT_EVENT_TOUCH_FRAME);
+
+    return event->axis.major;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+                event->base.type,
+                0,
+                LIBINPUT_EVENT_TOUCH_DOWN,
+                LIBINPUT_EVENT_TOUCH_UP,
+                LIBINPUT_EVENT_TOUCH_MOTION,
+                LIBINPUT_EVENT_TOUCH_CANCEL,
+				LIBINPUT_EVENT_TOUCH_FRAME);
+
+    return event->axis.minor;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_config_rightbutton_area(struct libinput *libinput,
+                const int32_t height_percent, const int32_t width_percent)
+{
+    const int32_t one_hundred = 100;
+
+    if (libinput == NULL) {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    if ((height_percent <= 0 || height_percent > one_hundred) ||
+        (width_percent <= 0 || width_percent > one_hundred)) {
+        log_error(libinput,
+                  "Failed to config right button area of touchpad. "
+                  "Invalid height(%d) or width percent(%d).\n",
+                  height_percent, width_percent);
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    /* Function returns a pointer to a static variable without checking
+     * whether the pointer is NULL
+     */
+    evdev_set_rightbutton_area(width_percent, height_percent);
+    return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+LIBINPUT_EXPORT void
+libinput_touchpad_event_clear(struct libinput_device *device)
+{
+	struct evdev_dispatch *dispatch = evdev_device(device)->dispatch;
+	if (dispatch == NULL) {
+		return;
+	}
+	struct tp_dispatch *tp = tp_dispatch(dispatch);
+	if (tp == NULL) {
+		return;
+	}
+	tp->slot = 0;
+	tp->orginal.active_slot_count = 0;
+	tp->orginal.seat_slot_id = 0;
+	struct tp_touch *t;
+	tp_for_each_touch(tp, t) {
+		if (t == NULL) {
+			continue;
+		}
+		evdev_log_libinput_info(tp->device, "t->index:%d, t->is_tool_palm:%d, t->tool_type:%d, t->palm.state:%d",
+			t->index, t->is_tool_palm, t->tool_type, t->palm.state);
+		t->is_tool_palm = false;
+		t->tool_type = 0;
+		t->palm.state = PALM_NONE;
+	}
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_touchpad_device_get_frequency(struct libinput_device *device)
+{
+	const int32_t default_frequency = 125;
+	struct evdev_dispatch *dispatch = evdev_device(device)->dispatch;
+	if (dispatch == NULL) {
+		return default_frequency;
+	}
+	struct tp_dispatch *tp = tp_dispatch(dispatch);
+	if (tp == NULL) {
+		return default_frequency;
+	}
+
+	uint32_t frequency = default_frequency;
+	struct quirks_context *quirks;
+	struct quirks *q;
+
+	quirks = evdev_libinput_context(tp->device)->quirks;
+	q = quirks_fetch_for_device(quirks, tp->device->udev_device);
+	if (!q || !quirks_get_uint32(q, QUIRK_ATTR_TOUCHPAD_FREQUENCY, &frequency))
+		return default_frequency;
+	quirks_unref(q);
+	return frequency;
+}
+
+LIBINPUT_EXPORT double
+libinput_touchpad_device_get_ppi(struct libinput_device *device)
+{
+	const double default_ppi = 29.8;
+	struct evdev_dispatch *dispatch = evdev_device(device)->dispatch;
+	if (dispatch == NULL) {
+		return default_ppi;
+	}
+	struct tp_dispatch *tp = tp_dispatch(dispatch);
+	if (tp == NULL) {
+		return default_ppi;
+	}
+	double ppi = tp->device->touchpad_ppi;
+	return ppi;
+}
+
+LIBINPUT_EXPORT double
+libinput_touchpad_device_get_hypot_size(struct libinput_device *device)
+{
+	const double default_hypot_size = 140.0;
+	struct evdev_dispatch *dispatch = evdev_device(device)->dispatch;
+	if (dispatch == NULL) {
+		return default_hypot_size;
+	}
+	struct tp_dispatch *tp = tp_dispatch(dispatch);
+	if (tp == NULL) {
+		return default_hypot_size;
+	}
+	double hypot_size = tp->device->touchpad_hypot_size;
+	return hypot_size;
+}
diff -Naur old/src/libinput.h new/src/libinput.h
--- old/src/libinput.h	2025-03-26 11:12:53.949121875 +0800
+++ new/src/libinput.h	2025-03-26 11:16:26.438458863 +0800
@@ -196,6 +196,23 @@
 	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
 	LIBINPUT_DEVICE_CAP_GESTURE = 5,
 	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+	LIBINPUT_DEVICE_CAP_JOYSTICK = 7,
+};
+
+enum evdev_device_udev_tags {
+    EVDEV_UDEV_TAG_INPUT = 1 << 0,
+    EVDEV_UDEV_TAG_KEYBOARD = 1 << 1,
+    EVDEV_UDEV_TAG_MOUSE = 1 << 2,
+    EVDEV_UDEV_TAG_TOUCHPAD = 1 << 3,
+    EVDEV_UDEV_TAG_TOUCHSCREEN = 1 << 4,
+    EVDEV_UDEV_TAG_TABLET = 1 << 5,
+    EVDEV_UDEV_TAG_JOYSTICK = 1 << 6,
+    EVDEV_UDEV_TAG_ACCELEROMETER = 1 << 7,
+    EVDEV_UDEV_TAG_TABLET_PAD = 1 << 8,
+    EVDEV_UDEV_TAG_POINTINGSTICK = 1 << 9,
+    EVDEV_UDEV_TAG_TRACKBALL = 1 << 10,
+    EVDEV_UDEV_TAG_SWITCH = 1 << 11,
+	EVDEV_UDEV_TAG_MSDP = 1 << 12,
 };
 
 /**
@@ -321,6 +338,49 @@
 };
 
 /**
+ * @ingroup event_joystick
+ *
+ * The source for a @ref LIBINPUT_EVENT_POINTER_AXIS event. See
+ * libinput_event_get_joystick_axis_event() for details.
+ *
+ * @since 1.16.4
+ */
+enum libinput_joystick_axis_source {
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_UNKNOWN = 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X = 1 << 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y = 1 << 1,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z = 1 << 2,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX = 1 << 3,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY = 1 << 4,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ = 1 << 5,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE = 1 << 6,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RUDDER = 1 << 7,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_WHEEL = 1 << 8,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS = 1 << 9,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE = 1 << 10,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X = 1 << 11,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y = 1 << 12,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1X = 1 << 13,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1Y = 1 << 14,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2X = 1 << 15,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2Y = 1 << 16,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3X = 1 << 17,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3Y = 1 << 18,
+};
+
+#define MAX_SOLTED_COORDS_NUM 10
+struct sloted_coords {
+	int32_t is_active;
+	float x;
+	float y;
+};
+
+struct sloted_coords_info {
+	struct sloted_coords coords[MAX_SOLTED_COORDS_NUM];
+	unsigned int active_count;
+};
+
+/**
  * @ingroup device
  *
  * Available tool types for a device with the @ref
@@ -393,6 +453,17 @@
 	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
 };
 
+struct libinput_event_joystick_axis_abs_info {
+	int32_t code;
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+	float	standardValue;
+};
+
 /**
  * @defgroup tablet_pad_modes Tablet pad modes
  *
@@ -702,6 +773,7 @@
 	 * in tablet mode.
 	 */
 	LIBINPUT_SWITCH_TABLET_MODE,
+	LIBINPUT_SWITCH_PRIVACY,
 };
 
 /**
@@ -822,6 +894,16 @@
 	 */
 	LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
 
+	LIBINPUT_EVENT_POINTER_TAP,
+	LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD,
+	LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD,
+
+	LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN,
+	LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END,
+
+	LIBINPUT_EVENT_JOYSTICK_BUTTON = 450,
+	LIBINPUT_EVENT_JOYSTICK_AXIS,
+
 	LIBINPUT_EVENT_TOUCH_DOWN = 500,
 	LIBINPUT_EVENT_TOUCH_UP,
 	LIBINPUT_EVENT_TOUCH_MOTION,
@@ -832,6 +914,10 @@
 	 */
 	LIBINPUT_EVENT_TOUCH_FRAME,
 
+	LIBINPUT_EVENT_TOUCHPAD_DOWN = 550,
+	LIBINPUT_EVENT_TOUCHPAD_UP,
+	LIBINPUT_EVENT_TOUCHPAD_MOTION,
+
 	/**
 	 * One or more axes have changed state on a device with the @ref
 	 * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. This event is only sent
@@ -984,6 +1070,8 @@
 	 * @since 1.7
 	 */
 	LIBINPUT_EVENT_SWITCH_TOGGLE = 900,
+
+	LIBINPUT_EVENT_MSDP = 1000,
 };
 
 /**
@@ -1084,6 +1172,19 @@
 /**
  * @ingroup event
  *
+ * Return the touchpad event that is this input event. If the event type does
+ * not match the touchpad event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_touchpad_get_base_event().
+ *
+ * @return A touch event, or NULL for other events
+ */
+struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
  * Return the gesture event that is this input event. If the event type does
  * not match the gesture event types, this function returns NULL.
  *
@@ -1466,6 +1567,10 @@
 enum libinput_button_state
 libinput_event_pointer_get_button_state(struct libinput_event_pointer *event);
 
+uint32_t
+libinput_event_pointer_get_button_area(
+	struct libinput_event_pointer *event);
+
 /**
  * @ingroup event_pointer
  *
@@ -1486,6 +1591,21 @@
 /**
  * @ingroup event_pointer
  *
+ * For the button of a @ref LIBINPUT_EVENT_POINTER_BUTTON event, return the
+ * total number of fingers on touchpad.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_BUTTON. For other events, this function
+ * returns 0.
+ *
+ * @return The finger counts for touchpad button event
+ */
+uint32_t
+libinput_event_pointer_get_finger_count(
+	struct libinput_event_pointer *event);
+/**
+ * @ingroup event_pointer
+ *
  * Check if the event has a valid value for the given axis.
  *
  * If this function returns non-zero for an axis and
@@ -1787,6 +1907,9 @@
 int32_t
 libinput_event_touch_get_seat_slot(struct libinput_event_touch *event);
 
+int32_t
+libinput_event_touch_get_orientation(struct libinput_event_touch *event);
+
 /**
  * @ingroup event_touch
  *
@@ -1870,6 +1993,120 @@
 				       uint32_t height);
 
 /**
+ * @brief 获取触摸屏的工具类型区域属性
+ */
+int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_x_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return The current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_y_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return The current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area. To get the corresponding output
+ * screen width, use
+ * libinput_event_touch_get_tool_width_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current width
+ */
+double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area, converted to screen width.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return Convert current width to screen width
+ */
+double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area. To get the corresponding output
+ * screen height, use
+ * libinput_event_touch_get_tool_height_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current height
+ */
+double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area, converted to screen height.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return Convert current height to screen height
+ */
+double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
  * @ingroup event_touch
  *
  * @return The generic libinput_event of this event
@@ -1878,6 +2115,228 @@
 libinput_event_touch_get_base_event(struct libinput_event_touch *event);
 
 /**
+ * @defgroup event_touch Touchpad events
+ *
+ * Events from absolute touchpad devices.
+ */
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the slot of this touchpad event. See the kernel's multitouch
+ * protocol B documentation for more information.
+ *
+ * If the touchpad event has no assigned slot, for example if it is from a
+ * single touchpad device, this function returns -1.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The slot of this touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the seat slot of the touchpad event. A seat slot is a non-negative seat
+ * wide unique identifier of an active touchpad point.
+ *
+ * Events from single touchpad devices will be represented as one individual
+ * touchpad point per device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The seat slot of the touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute x coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute y coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the pressure of the touch pad
+ *
+ * @param event The libinput touch event
+ * @return Touchpad pressure value
+ *
+ */
+double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The long axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The short axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板的工具类型区域属性
+ */
+int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板工具类型按钮是否按下
+ */
+int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
+ * @ingroup event_touch
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the X coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The X coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the Y coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The Y coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the width of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The width of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the height of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The height of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event);
+
+/**
  * @defgroup event_gesture Gesture events
  *
  * Gesture events are generated when a gesture is recognized on a touchpad.
@@ -2090,6 +2549,49 @@
 libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);
 
 /**
+ * 获取gesture中手指的坐标信息, idx表示手指的索引
+ */
+int
+libinput_event_gesture_get_device_coords_x(struct libinput_event_gesture *event, uint32_t idx);
+int
+libinput_event_gesture_get_device_coords_y(struct libinput_event_gesture *event, uint32_t idx);
+/**
+ * 获取带slot的touches信息, 仅支持LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE
+ */
+struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(struct libinput_event_gesture *event);
+
+/**
+ * @brief Obtain the device values the EV_LED event type
+ *
+ * @param device  A current input device
+ * @return int Obtained is Supported
+ */
+int libinput_has_event_led_type(struct libinput_device *device);
+
+/**
+ * @brief Obtain the function key enablement status of a keyboard device
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @return int Obtained state
+ */
+int libinput_get_funckey_state(struct libinput_device *device, unsigned int code);
+
+/**
+ * @brief Turn an LED on or off. Convenience function, if you need to modify multiple
+ * LEDs simultaneously, use libinput_set_led_state() instead.
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @param state value Specifies whether to turn the LED on or off
+ * @return int 0 on success, or a negative errno on failure
+ */
+int libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state);
+
+/**
  * @defgroup event_tablet Tablet events
  *
  * Events that come from tools on tablet devices. For events from the pad,
@@ -2590,6 +3092,18 @@
 libinput_event_tablet_tool_get_size_minor(struct libinput_event_tablet_tool *event);
 
 /**
+ * @ingroup config
+ *
+ * Get the current side rotation angle of the stylus.
+ *
+ * @param tool The libinput tool
+ * @return angle value of the stylus
+ *
+ */
+int32_t
+libinput_event_tablet_tool_get_angle(struct libinput_event_tablet_tool *tool);
+
+/**
  * @ingroup event_tablet
  *
  * Return the delta for the wheel in degrees.
@@ -2817,6 +3331,19 @@
 /**
  * @ingroup event_tablet
  *
+ * Get the stylus event type reported from evdev_tablet
+ *
+ * @param event The libinput tablet tool event
+ * @return Tool type for stylus events
+ *
+ * @since 1.2
+ */
+int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
  * Return the high-level tool type for a tool object.
  *
  * The high level tool describes general interaction expected with the tool.
@@ -3663,6 +4190,56 @@
 int
 libinput_dispatch(struct libinput *libinput);
 
+/****************************************************************************
+* @brief : brief
+* @author : fms
+* @date : 2021/3/8 20:55
+* @version : ver 1.0
+* @inparam :libinput  event
+* @outparam :
+*****************************************************************************/
+void
+libinput_post_handle_event(struct libinput* libinput,
+	struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick button event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_button_event(struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick axis event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_axis*
+    libinput_event_get_joystick_axis_event(struct libinput_event* event);
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event);
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
 /**
  * @ingroup base
  *
@@ -3866,6 +4443,30 @@
 			 libinput_log_handler log_handler);
 
 /**
+ * @ingroup base
+ *
+ * Toggle the status of virtual keyboard caps key.
+ */
+void
+libinput_toggle_caps_key();
+
+void
+libinput_set_touch_event_type(struct libinput_event_touch* event_touch, enum libinput_event_type eventType);
+
+/**
+ * @ingroup base
+ *
+ * Create a keyboard event based on the given touch event.
+ *
+ * @param event_touch The touch event
+ * @param key key code
+ * @param state key state, pressed or released
+ * @return The keyboard event
+ */
+struct libinput_event_keyboard*
+libinput_create_keyboard_event(struct libinput_event_touch* event_touch, int32_t key, enum libinput_key_state state);
+
+/**
  * @defgroup seat Initialization and manipulation of seats
  *
  * A seat has two identifiers, the physical name and the logical name. A
@@ -4133,6 +4734,42 @@
 const char *
 libinput_device_get_name(struct libinput_device *device);
 
+/**  @brief   获取设备类型*/
+enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device);
+
+/**  @brief   设备按键能力查询*/
+int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode);
+
+/**  @brief   获取设备特定轴的最小值*/
+int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的最大值*/
+int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的fuzz值*/
+int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的flat值*/
+int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的resolution值*/
+int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备的bustype值*/
+unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device);
+
+/**  @brief   获取设备的version值*/
+unsigned int
+libinput_device_get_id_version(struct libinput_device* device);
+
 /**
  * @ingroup device
  *
@@ -4343,6 +4980,12 @@
 libinput_device_touch_get_touch_count(struct libinput_device *device);
 
 /**
+ * @brief 获取触摸屏工具类型按钮是否按下
+ */
+int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
  * @ingroup device
  *
  * Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
@@ -5722,6 +6365,9 @@
 enum libinput_config_click_method
 libinput_device_config_click_get_default_method(struct libinput_device *device);
 
+uint64_t
+libinput_event_get_sensortime(struct libinput_event *event);
+
 /**
  * @ingroup config
  */
@@ -6398,6 +7044,166 @@
 unsigned int
 libinput_device_config_rotation_get_default_angle(struct libinput_device *device);
 
+/**
+ * @ingroup event
+ *
+ * Get the struct libinput_event_joystick_button from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput_event_joystick_button for this event.
+ */
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the time from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The time for this event.
+ */
+uint64_t libinput_event_joystick_button_time(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the key value from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The key value for this event.
+ */
+uint32_t libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the seat key count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The seat key count for this event.
+ */
+uint32_t libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the value count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The value for this event.
+ */
+int libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the pressure of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Pressure value of touch screen
+ *
+ * @since 1.4
+ */
+double
+libinput_event_touch_get_pressure(struct libinput_event_touch* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the move_flag of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Move_flag value of touch screen
+ *
+ * @since 1.4
+ */
+int32_t
+libinput_event_touch_get_move_flag(struct libinput_event_touch* event);
+
+int32_t
+libinput_event_get_hand_feature(struct libinput_event *event);
+
+/**
+ * @ingroup config
+ *
+ * Get the blob_id of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Blob_id value of touch screen
+ *
+ * @since 1.4
+ */
+int32_t
+libinput_event_touch_get_blob_id(struct libinput_event_touch* event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Long axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Short axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+const char*
+libinput_device_get_phys(struct libinput_device* device);
+
+const char*
+libinput_device_get_uniq(struct libinput_device* device);
+
+enum libinput_button_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Enable to config the right button area on the click-touchpad without
+ * physic buttons. Once the configuration is changed, the right button
+ * area will take effect at next sync report. See the libinput documentation
+ * for details.
+ *
+ * @note Configuration changes may not take effect immediately. The
+ * configuration fails to take effect if touchpad is not click-touchpad,
+ * with physical button or middle button. Other scenarios, such as touchpad
+ * with Apple quirks, also cause the configuration fails to take effect.
+ *
+ * @param libinput A libinput context initialized with
+ * libinput_udev_create_context()
+ * @param height_percent The height percent to config.
+ * @param width_percent The width percent to config.
+ *
+ * @return A config status code. If the param is valid the feature always
+ * succeeds.
+ */
+enum libinput_config_status
+libinput_config_rightbutton_area(struct libinput *libinput,
+                const int32_t height_percent, const int32_t width_percent);
+
+void
+libinput_touchpad_event_clear(struct libinput_device *device);
+
+int32_t
+libinput_touchpad_device_get_frequency(struct libinput_device *device);
+
+double
+libinput_touchpad_device_get_ppi(struct libinput_device *device);
+
+double
+libinput_touchpad_device_get_hypot_size(struct libinput_device *device);
 #ifdef __cplusplus
 }
 #endif
diff -Naur old/src/path-seat.c new/src/path-seat.c
--- old/src/path-seat.c	2025-03-26 11:12:53.949121875 +0800
+++ new/src/path-seat.c	2025-03-26 11:16:26.438458863 +0800
@@ -137,7 +137,7 @@
 	if (seat_logical_name_override) {
 		seat_logical_name = safe_strdup(seat_logical_name_override);
 	} else {
-		seat_prop = udev_device_get_property_value(udev_device, "WL_SEAT");
+		seat_prop = udev_device_get_sysname(udev_device);
 		seat_logical_name = safe_strdup(seat_prop ? seat_prop : default_seat_name);
 	}
 
@@ -365,25 +365,26 @@
 	struct libinput_device *device;
 
 	if (strlen(path) > PATH_MAX) {
-		log_bug_client(libinput,
+		log_libinput_error(libinput,
 			       "Unexpected path, limited to %d characters.\n",
 			       PATH_MAX);
 		return NULL;
 	}
 
 	if (libinput->interface_backend != &interface_backend) {
-		log_bug_client(libinput, "Mismatching backends.\n");
+		log_libinput_error(libinput, "Mismatching backends.\n");
 		return NULL;
 	}
 
 	udev_device = udev_device_from_devnode(libinput, udev, path);
 	if (!udev_device) {
-		log_bug_client(libinput, "Invalid path %s\n", path);
+		log_libinput_error(libinput, "Invalid path %s\n", path);
 		return NULL;
 	}
 
 	if (ignore_litest_test_suite_device(udev_device)) {
 		udev_device_unref(udev_device);
+		log_libinput_error(libinput, "ignore_litest_test_suite_device\n");
 		return NULL;
 	}
 
diff -Naur old/src/quirks.c new/src/quirks.c
--- old/src/quirks.c	2025-03-26 11:12:53.949121875 +0800
+++ new/src/quirks.c	2025-03-26 11:16:26.438458863 +0800
@@ -271,6 +271,7 @@
 	case QUIRK_MODEL_TRACKBALL:			return "ModelTrackball";
 	case QUIRK_MODEL_WACOM_TOUCHPAD:		return "ModelWacomTouchpad";
 	case QUIRK_MODEL_PRESSURE_PAD:			return "ModelPressurePad";
+	case QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD:	return "ModelHuaweiFreeTouchTouchpad";
 
 	case QUIRK_ATTR_SIZE_HINT:			return "AttrSizeHint";
 	case QUIRK_ATTR_TOUCH_SIZE_RANGE:		return "AttrTouchSizeRange";
@@ -290,6 +291,10 @@
 	case QUIRK_ATTR_MSC_TIMESTAMP:			return "AttrMscTimestamp";
 	case QUIRK_ATTR_EVENT_CODE:			return "AttrEventCode";
 	case QUIRK_ATTR_INPUT_PROP:			return "AttrInputProp";
+	case QUIRK_ATTR_DWT_POINTER_UNLOCK_TIME_THRESHOLD:	return "AttrDwtPointerUnlockTimeThreshold";
+	case QUIRK_ATTR_TOUCHPAD_AXIS_SPEED_GAIN:	return "AttrTouchpadAxisSpeedGain";
+	case QUIRK_ATTR_TOUCHPAD_FREQUENCY: return "AttrTouchpadFrequency";
+	case QUIRK_ATTR_TOUCHPAD_HOLD_AND_MOTION_THRESHOLD: return "AttrTouchpadHoldAndMotionThreshold";
 	default:
 		abort();
 	}
@@ -859,6 +864,34 @@
 		p->type = PT_TUPLES;
 
 		rc = true;
+	} else if (streq(key, quirk_get_name(QUIRK_ATTR_DWT_POINTER_UNLOCK_TIME_THRESHOLD))) {
+		p->id = QUIRK_ATTR_DWT_POINTER_UNLOCK_TIME_THRESHOLD;
+		if (!safe_atou(value, &v))
+			goto out;
+		p->type = PT_UINT;
+		p->value.u = v;
+		rc = true;
+	} else if (streq(key, quirk_get_name(QUIRK_ATTR_TOUCHPAD_AXIS_SPEED_GAIN))) {
+		p->id = QUIRK_ATTR_TOUCHPAD_AXIS_SPEED_GAIN;
+		if (!safe_atod(value, &d))
+			goto out;
+		p->type = PT_DOUBLE;
+		p->value.d = d;
+		rc = true;
+	} else if (streq(key, quirk_get_name(QUIRK_ATTR_TOUCHPAD_FREQUENCY))) {
+		p->id = QUIRK_ATTR_TOUCHPAD_FREQUENCY;
+		if (!safe_atou(value, &v))
+			goto out;
+		p->type = PT_UINT;
+		p->value.u = v;
+		rc = true;
+	} else if (streq(key, quirk_get_name(QUIRK_ATTR_TOUCHPAD_HOLD_AND_MOTION_THRESHOLD))) {
+		p->id = QUIRK_ATTR_TOUCHPAD_HOLD_AND_MOTION_THRESHOLD;
+		if (!safe_atod(value, &d))
+			goto out;
+		p->type = PT_DOUBLE;
+		p->value.d = d;
+		rc = true;
 	} else {
 		qlog_error(ctx, "Unknown key %s in %s\n", key, s->name);
 	}
diff -Naur old/src/quirks.h new/src/quirks.h
--- old/src/quirks.h	2025-03-26 11:12:53.949121875 +0800
+++ new/src/quirks.h	2025-03-26 11:16:26.438458863 +0800
@@ -88,6 +88,7 @@
 	QUIRK_MODEL_WACOM_TOUCHPAD,
 	QUIRK_MODEL_PRESSURE_PAD,
 	QUIRK_MODEL_TOUCHPAD_PHANTOM_CLICKS,
+	QUIRK_MODEL_HUAWEI_FREETOUCH_TOUCHPAD,
 
 	_QUIRK_LAST_MODEL_QUIRK_, /* Guard: do not modify */
 
@@ -109,6 +110,10 @@
 	QUIRK_ATTR_MSC_TIMESTAMP,
 	QUIRK_ATTR_EVENT_CODE,
 	QUIRK_ATTR_INPUT_PROP,
+	QUIRK_ATTR_DWT_POINTER_UNLOCK_TIME_THRESHOLD,
+	QUIRK_ATTR_TOUCHPAD_AXIS_SPEED_GAIN,
+	QUIRK_ATTR_TOUCHPAD_FREQUENCY,
+	QUIRK_ATTR_TOUCHPAD_HOLD_AND_MOTION_THRESHOLD,
 
 	_QUIRK_LAST_ATTR_QUIRK_, /* Guard: do not modify */
 };
diff -Naur old/src/udev-seat.c new/src/udev-seat.c
--- old/src/udev-seat.c	2025-03-26 11:12:53.949121875 +0800
+++ new/src/udev-seat.c	2025-03-26 11:16:26.438458863 +0800
@@ -190,6 +190,7 @@
 
 		/* Skip unconfigured device. udev will send an event
 		 * when device is fully configured  */
+/*
 		if (!udev_device_get_is_initialized(device)) {
 			log_debug(&input->base,
 				  "%-7s - skip unconfigured input device '%s'\n",
@@ -198,6 +199,13 @@
 			udev_device_unref(device);
 			continue;
 		}
+*/
+		if (!udev_device_get_is_initialized(device)) {
+			log_info(&input->base,
+				  "%-7s - unconfigured input device '%s'\n",
+				  sysname,
+				  udev_device_get_devnode(device));
+		}
 
 		if (device_added(device, input, NULL) < 0) {
 			udev_device_unref(device);
diff -Naur old/src/util-strings.h new/src/util-strings.h
--- old/src/util-strings.h	2025-03-26 11:12:53.949121875 +0800
+++ new/src/util-strings.h	2025-03-26 11:16:26.438458863 +0800
@@ -308,7 +308,7 @@
 	if (!strv)
 		return result;
 
-	double *numv = zalloc(sizeof(double) * nelem);
+	double *numv = (double *)zalloc(sizeof(double) * nelem);
 	for (size_t idx = 0; idx < nelem; idx++) {
 		double val;
 		if (!safe_atod(strv[idx], &val))
@@ -355,7 +355,7 @@
 	if (!pairs || npairs == 0)
 		goto error;
 
-	result = zalloc(npairs * sizeof *result);
+	result = (struct key_value_double *)zalloc(npairs * sizeof *result);
 
 	for (size_t idx = 0; idx < npairs; idx++) {
 		char *pair = pairs[idx];
@@ -468,7 +468,7 @@
 		return strdup(str);
 
 	size_t slen = min(strlen(str), 512);
-	char *sanitized = zalloc(2 * slen + 1);
+	char *sanitized = (char *)zalloc(2 * slen + 1);
 	const char *src = str;
 	char *dst = sanitized;
 
diff -Naur old/src/util-time.h new/src/util-time.h
--- old/src/util-time.h	2025-03-26 11:12:53.949121875 +0800
+++ new/src/util-time.h	2025-03-26 11:16:26.438458863 +0800
@@ -109,7 +109,8 @@
 static inline struct human_time
 to_human_time(uint64_t us)
 {
-	struct human_time t;
+	uint64_t l = 0;
+	struct human_time t = {0, NULL};
 	struct c {
 		const char *unit;
 		unsigned int change_from_previous;
@@ -120,7 +121,7 @@
 		{"s", 1000, 120},
 		{"min", 60, 120},
 		{"h", 60, 48},
-		{"d", 24, ~0},
+		{"d", 24, ~l},
 	};
 	uint64_t value = us;
 
@@ -132,6 +133,6 @@
 			return t;
 		}
 	}
-
-	assert(!"We should never get here");
+return t;
+	//assert(1);
 }
diff -Naur old/tools/libinput-debug-events.c new/tools/libinput-debug-events.c
--- old/tools/libinput-debug-events.c	2025-03-26 11:12:53.957121928 +0800
+++ new/tools/libinput-debug-events.c	2025-03-26 11:16:26.438458863 +0800
@@ -110,6 +110,15 @@
 	case LIBINPUT_EVENT_TOUCH_FRAME:
 		type = "TOUCH_FRAME";
 		break;
+	case LIBINPUT_EVENT_TOUCHPAD_DOWN:
+		type = "TOUCHPAD_DOWN";
+		break;
+	case LIBINPUT_EVENT_TOUCHPAD_MOTION:
+		type = "TOUCHPAD_MOTION";
+		break;
+	case LIBINPUT_EVENT_TOUCHPAD_UP:
+		type = "TOUCHPAD_UP";
+		break;
 	case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
 		type = "GESTURE_SWIPE_BEGIN";
 		break;
@@ -161,6 +170,8 @@
 	case LIBINPUT_EVENT_SWITCH_TOGGLE:
 		type = "SWITCH_TOGGLE";
 		break;
+	default:
+		break;
 	}
 
 	prefix = (last_device != dev) ? '-' : ' ';
@@ -297,6 +308,10 @@
 					   LIBINPUT_DEVICE_CAP_SWITCH))
 		printq("S");
 
+    if (libinput_device_has_capability(dev,
+        LIBINPUT_DEVICE_CAP_JOYSTICK))
+        printq("JOYSTICK");
+
 	if (libinput_device_get_size(dev, &w, &h) == 0)
 		printq("  size %.0fx%.0fmm", w, h);
 
@@ -547,6 +562,15 @@
 }
 
 static void
+print_touchpad_event_without_coords(struct libinput_event *ev)
+{
+	struct libinput_event_touch *t = libinput_event_get_touchpad_event(ev);
+
+	print_event_time(libinput_event_touchpad_get_time(t));
+	printq("\n");
+}
+
+static void
 print_proximity_event(struct libinput_event *ev)
 {
 	struct libinput_event_tablet_tool *t = libinput_event_get_tablet_tool_event(ev);
@@ -673,6 +697,21 @@
 }
 
 static void
+print_touchpad_event_with_coords(struct libinput_event *ev)
+{
+	struct libinput_event_touch *t = libinput_event_get_touchpad_event(ev);
+	double xmm = libinput_event_touchpad_get_x(t);
+	double ymm = libinput_event_touchpad_get_y(t);
+
+	print_event_time(libinput_event_touchpad_get_time(t));
+
+	printq("%d (%d) %5.2f/%5.2fmm\n",
+	       libinput_event_touchpad_get_slot(t),
+	       libinput_event_touchpad_get_seat_slot(t),
+	       xmm, ymm);
+}
+
+static void
 print_gesture_event_without_coords(struct libinput_event *ev)
 {
 	struct libinput_event_gesture *t = libinput_event_get_gesture_event(ev);
@@ -895,6 +934,15 @@
 		case LIBINPUT_EVENT_TOUCH_FRAME:
 			print_touch_event(ev);
 			break;
+		case LIBINPUT_EVENT_TOUCHPAD_DOWN:
+			print_touchpad_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCHPAD_MOTION:
+			print_touchpad_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCHPAD_UP:
+			print_touchpad_event_without_coords(ev);
+			break;
 		case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
 			print_gesture_event_without_coords(ev);
 			break;
@@ -946,6 +994,8 @@
 		case LIBINPUT_EVENT_SWITCH_TOGGLE:
 			print_switch_event(ev);
 			break;
+		default:
+			break;
 		}
 
 		libinput_event_destroy(ev);
diff -Naur old/tools/libinput-record.c new/tools/libinput-record.c
--- old/tools/libinput-record.c	2025-03-26 11:12:53.957121928 +0800
+++ new/tools/libinput-record.c	2025-03-26 11:16:26.438458863 +0800
@@ -53,6 +53,7 @@
 #include "util-time.h"
 #include "util-input-event.h"
 #include "util-macros.h"
+#include "hm_missing.h"
 
 static const int FILE_VERSION_NUMBER = 1;
 
diff -Naur old/udev/libinput-device-group.c new/udev/libinput-device-group.c
--- old/udev/libinput-device-group.c	2025-03-26 11:12:53.957121928 +0800
+++ new/udev/libinput-device-group.c	2025-03-26 11:16:26.438458863 +0800
@@ -137,7 +137,7 @@
 				*product_id = pid;
 				best_dist = dist;
 
-				free(*phys_attr);
+				free((char*)*phys_attr);
 				*phys_attr = safe_strdup(phys);
 			}
 		}
