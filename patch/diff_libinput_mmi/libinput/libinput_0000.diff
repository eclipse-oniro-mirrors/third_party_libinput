Copyright (C) 2021-2024 Huawei Device Co., Ltd.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at\n

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

diff -Naur old/export_include/libinput.h new/export_include/libinput.h
--- old/export_include/libinput.h	2024-01-01 00:00:00.000000000 +0800
+++ new/export_include/libinput.h	2024-01-01 00:00:00.000000000 +0800
@@ -196,6 +196,23 @@
 	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
 	LIBINPUT_DEVICE_CAP_GESTURE = 5,
 	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+	LIBINPUT_DEVICE_CAP_JOYSTICK = 7,
+};
+
+enum evdev_device_udev_tags {
+    EVDEV_UDEV_TAG_INPUT = 1 << 0,
+    EVDEV_UDEV_TAG_KEYBOARD = 1 << 1,
+    EVDEV_UDEV_TAG_MOUSE = 1 << 2,
+    EVDEV_UDEV_TAG_TOUCHPAD = 1 << 3,
+    EVDEV_UDEV_TAG_TOUCHSCREEN = 1 << 4,
+    EVDEV_UDEV_TAG_TABLET = 1 << 5,
+    EVDEV_UDEV_TAG_JOYSTICK = 1 << 6,
+    EVDEV_UDEV_TAG_ACCELEROMETER = 1 << 7,
+    EVDEV_UDEV_TAG_TABLET_PAD = 1 << 8,
+    EVDEV_UDEV_TAG_POINTINGSTICK = 1 << 9,
+    EVDEV_UDEV_TAG_TRACKBALL = 1 << 10,
+    EVDEV_UDEV_TAG_SWITCH = 1 << 11,
+	EVDEV_UDEV_TAG_MSDP = 1 << 12,
 };
 
 /**
@@ -321,6 +338,49 @@
 };
 
 /**
+ * @ingroup event_joystick
+ *
+ * The source for a @ref LIBINPUT_EVENT_POINTER_AXIS event. See
+ * libinput_event_get_joystick_axis_event() for details.
+ *
+ * @since 1.16.4
+ */
+enum libinput_joystick_axis_source {
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_UNKNOWN = 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X = 1 << 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y = 1 << 1,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z = 1 << 2,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX = 1 << 3,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY = 1 << 4,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ = 1 << 5,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE = 1 << 6,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RUDDER = 1 << 7,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_WHEEL = 1 << 8,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS = 1 << 9,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE = 1 << 10,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X = 1 << 11,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y = 1 << 12,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1X = 1 << 13,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1Y = 1 << 14,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2X = 1 << 15,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2Y = 1 << 16,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3X = 1 << 17,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3Y = 1 << 18,
+};
+
+#define MAX_SOLTED_COORDS_NUM 10
+struct sloted_coords {
+	int32_t is_active;
+	float x;
+	float y;
+};
+
+struct sloted_coords_info {
+	struct sloted_coords coords[MAX_SOLTED_COORDS_NUM];
+	unsigned int active_count;
+};
+
+/**
  * @ingroup device
  *
  * Available tool types for a device with the @ref
@@ -393,6 +453,17 @@
 	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
 };
 
+struct libinput_event_joystick_axis_abs_info {
+	int32_t code;
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+	float	standardValue;
+};
+
 /**
  * @defgroup tablet_pad_modes Tablet pad modes
  *
@@ -702,6 +773,7 @@
 	 * in tablet mode.
 	 */
 	LIBINPUT_SWITCH_TABLET_MODE,
+	LIBINPUT_SWITCH_PRIVACY,
 };
 
 /**
@@ -822,6 +894,16 @@
 	 */
 	LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
 
+	LIBINPUT_EVENT_POINTER_TAP,
+	LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD,
+	LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD,
+
+	LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN,
+	LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END,
+
+	LIBINPUT_EVENT_JOYSTICK_BUTTON = 450,
+	LIBINPUT_EVENT_JOYSTICK_AXIS,
+
 	LIBINPUT_EVENT_TOUCH_DOWN = 500,
 	LIBINPUT_EVENT_TOUCH_UP,
 	LIBINPUT_EVENT_TOUCH_MOTION,
@@ -832,6 +914,10 @@
 	 */
 	LIBINPUT_EVENT_TOUCH_FRAME,
 
+	LIBINPUT_EVENT_TOUCHPAD_DOWN = 550,
+	LIBINPUT_EVENT_TOUCHPAD_UP,
+	LIBINPUT_EVENT_TOUCHPAD_MOTION,
+
 	/**
 	 * One or more axes have changed state on a device with the @ref
 	 * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. This event is only sent
@@ -984,6 +1070,8 @@
 	 * @since 1.7
 	 */
 	LIBINPUT_EVENT_SWITCH_TOGGLE = 900,
+
+	LIBINPUT_EVENT_MSDP = 1000,
 };
 
 /**
@@ -1084,6 +1172,19 @@
 /**
  * @ingroup event
  *
+ * Return the touchpad event that is this input event. If the event type does
+ * not match the touchpad event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_touchpad_get_base_event().
+ *
+ * @return A touch event, or NULL for other events
+ */
+struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
  * Return the gesture event that is this input event. If the event type does
  * not match the gesture event types, this function returns NULL.
  *
@@ -1486,6 +1587,21 @@
 /**
  * @ingroup event_pointer
  *
+ * For the button of a @ref LIBINPUT_EVENT_POINTER_BUTTON event, return the
+ * total number of fingers on touchpad.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_BUTTON. For other events, this function
+ * returns 0.
+ *
+ * @return The finger counts for touchpad button event
+ */
+uint32_t
+libinput_event_pointer_get_finger_count(
+	struct libinput_event_pointer *event);
+/**
+ * @ingroup event_pointer
+ *
  * Check if the event has a valid value for the given axis.
  *
  * If this function returns non-zero for an axis and
@@ -1870,6 +1986,120 @@
 				       uint32_t height);
 
 /**
+ * @brief 获取触摸屏的工具类型区域属性
+ */
+int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_x_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return The current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_y_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return The current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area. To get the corresponding output
+ * screen width, use
+ * libinput_event_touch_get_tool_width_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current width
+ */
+double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area, converted to screen width.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return Convert current width to screen width
+ */
+double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area. To get the corresponding output
+ * screen height, use
+ * libinput_event_touch_get_tool_height_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current height
+ */
+double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area, converted to screen height.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return Convert current height to screen height
+ */
+double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
  * @ingroup event_touch
  *
  * @return The generic libinput_event of this event
@@ -1878,6 +2108,228 @@
 libinput_event_touch_get_base_event(struct libinput_event_touch *event);
 
 /**
+ * @defgroup event_touch Touchpad events
+ *
+ * Events from absolute touchpad devices.
+ */
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the slot of this touchpad event. See the kernel's multitouch
+ * protocol B documentation for more information.
+ *
+ * If the touchpad event has no assigned slot, for example if it is from a
+ * single touchpad device, this function returns -1.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The slot of this touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the seat slot of the touchpad event. A seat slot is a non-negative seat
+ * wide unique identifier of an active touchpad point.
+ *
+ * Events from single touchpad devices will be represented as one individual
+ * touchpad point per device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The seat slot of the touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute x coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute y coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the pressure of the touch pad
+ *
+ * @param event The libinput touch event
+ * @return Touchpad pressure value
+ *
+ */
+double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The long axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The short axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板的工具类型区域属性
+ */
+int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板工具类型按钮是否按下
+ */
+int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
+ * @ingroup event_touch
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the X coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The X coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the Y coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The Y coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the width of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The width of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the height of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The height of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event);
+
+/**
  * @defgroup event_gesture Gesture events
  *
  * Gesture events are generated when a gesture is recognized on a touchpad.
@@ -2090,6 +2542,49 @@
 libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);
 
 /**
+ * 获取gesture中手指的坐标信息, idx表示手指的索引
+ */
+int
+libinput_event_gesture_get_device_coords_x(struct libinput_event_gesture *event, uint32_t idx);
+int
+libinput_event_gesture_get_device_coords_y(struct libinput_event_gesture *event, uint32_t idx);
+/**
+ * 获取带slot的touches信息, 仅支持LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE
+ */
+struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(struct libinput_event_gesture *event);
+
+/**
+ * @brief Obtain the device values the EV_LED event type
+ *
+ * @param device  A current input device
+ * @return int Obtained is Supported
+ */
+int libinput_has_event_led_type(struct libinput_device *device);
+
+/**
+ * @brief Obtain the function key enablement status of a keyboard device
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @return int Obtained state
+ */
+int libinput_get_funckey_state(struct libinput_device *device, unsigned int code);
+
+/**
+ * @brief Turn an LED on or off. Convenience function, if you need to modify multiple
+ * LEDs simultaneously, use libinput_set_led_state() instead.
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @param state value Specifies whether to turn the LED on or off
+ * @return int 0 on success, or a negative errno on failure
+ */
+int libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state);
+
+/**
  * @defgroup event_tablet Tablet events
  *
  * Events that come from tools on tablet devices. For events from the pad,
@@ -2817,6 +3312,19 @@
 /**
  * @ingroup event_tablet
  *
+ * Get the stylus event type reported from evdev_tablet
+ *
+ * @param event The libinput tablet tool event
+ * @return Tool type for stylus events
+ *
+ * @since 1.2
+ */
+int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
  * Return the high-level tool type for a tool object.
  *
  * The high level tool describes general interaction expected with the tool.
@@ -3663,6 +4171,56 @@
 int
 libinput_dispatch(struct libinput *libinput);
 
+/****************************************************************************
+* @brief : brief
+* @author : fms
+* @date : 2021/3/8 20:55
+* @version : ver 1.0
+* @inparam :libinput  event
+* @outparam :
+*****************************************************************************/
+void
+libinput_post_handle_event(struct libinput* libinput,
+	struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick button event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_button_event(struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick axis event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_axis*
+    libinput_event_get_joystick_axis_event(struct libinput_event* event);
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event);
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
 /**
  * @ingroup base
  *
@@ -4133,6 +4691,42 @@
 const char *
 libinput_device_get_name(struct libinput_device *device);
 
+/**  @brief   获取设备类型*/
+enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device);
+
+/**  @brief   设备按键能力查询*/
+int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode);
+
+/**  @brief   获取设备特定轴的最小值*/
+int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的最大值*/
+int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的fuzz值*/
+int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的flat值*/
+int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的resolution值*/
+int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备的bustype值*/
+unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device);
+
+/**  @brief   获取设备的version值*/
+unsigned int
+libinput_device_get_id_version(struct libinput_device* device);
+
 /**
  * @ingroup device
  *
@@ -4343,6 +4937,12 @@
 libinput_device_touch_get_touch_count(struct libinput_device *device);
 
 /**
+ * @brief 获取触摸屏工具类型按钮是否按下
+ */
+int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
  * @ingroup device
  *
  * Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
@@ -5722,6 +6322,9 @@
 enum libinput_config_click_method
 libinput_device_config_click_get_default_method(struct libinput_device *device);
 
+uint64_t
+libinput_event_get_sensortime(struct libinput_event *event);
+
 /**
  * @ingroup config
  */
@@ -6398,7 +7001,108 @@
 unsigned int
 libinput_device_config_rotation_get_default_angle(struct libinput_device *device);
 
+/**
+ * @ingroup event
+ *
+ * Get the struct libinput_event_joystick_button from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput_event_joystick_button for this event.
+ */
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the time from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The time for this event.
+ */
+uint64_t libinput_event_joystick_button_time(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the key value from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The key value for this event.
+ */
+uint32_t libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the seat key count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The seat key count for this event.
+ */
+uint32_t libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the value count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The value for this event.
+ */
+int libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the pressure of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Pressure value of touch screen
+ *
+ * @since 1.4
+ */
+double
+libinput_event_touch_get_pressure(struct libinput_event_touch* event);
+
+int32_t
+libinput_event_get_hand_feature(struct libinput_event *event);
+
+int32_t
+libinput_event_touch_get_blob_id(struct libinput_event_touch* event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Long axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Short axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+const char*
+libinput_device_get_phys(struct libinput_device* device);
+
+const char*
+libinput_device_get_uniq(struct libinput_device* device);
+
+enum libinput_button_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event);
 #ifdef __cplusplus
 }
 #endif
 #endif /* LIBINPUT_H */
+
diff -Naur old/hm_src/hm_missing.c new/hm_src/hm_missing.c
--- old/hm_src/hm_missing.c	1970-01-01 08:00:00.000000000 +0800
+++ new/hm_src/hm_missing.c	2024-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hm_missing.h"
+
+extern char *__progname;
+char *ohos_program_invocation_short_name()
+{
+    return __progname;
+}
\ No newline at end of file
diff -Naur old/hm_src/hm_missing.h new/hm_src/hm_missing.h
--- old/hm_src/hm_missing.h	1970-01-01 08:00:00.000000000 +0800
+++ new/hm_src/hm_missing.h	2024-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_LIBINPUT_HM_MISSING_H
+#define OHOS_LIBINPUT_HM_MISSING_H
+
+/* The full and simple forms of the name with which the program was
+   invoked.  These variables are set up automatically at startup based on
+   the value of argv[0].  */
+extern char *ohos_program_invocation_short_name();
+#define program_invocation_short_name ohos_program_invocation_short_name()
+
+#endif
diff -Naur old/include/linux/freebsd/input-event-codes.h new/include/linux/freebsd/input-event-codes.h
--- old/include/linux/freebsd/input-event-codes.h	2024-01-01 00:00:00.000000000 +0800
+++ new/include/linux/freebsd/input-event-codes.h	2024-01-01 00:00:00.000000000 +0800
@@ -335,7 +335,7 @@
 #define KEY_WIMAX		KEY_WWAN
 #define KEY_RFKILL		247	/* Key that controls all radios */
 
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
+#define KEY_MICMUTE		251	/* Mute / unmute the microphone */
 
 /* Code 255 is reserved for special needs of AT keyboard driver */
 
@@ -834,7 +834,7 @@
 #define ABS_TOOL_WIDTH		0x1c
 
 #define ABS_VOLUME		0x20
-
+#define ABS_HAND_FEATURE 0x21
 #define ABS_MISC		0x28
 
 /*
@@ -889,7 +889,8 @@
 #define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
 #define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
 #define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_MAX			0x10
+#define SW_SUPER_PRIVACY	0x11  /* set = super privacy open */
+#define SW_MAX			    0x11
 #define SW_CNT			(SW_MAX+1)
 
 /*
diff -Naur old/include/linux/linux/input-event-codes.h new/include/linux/linux/input-event-codes.h
--- old/include/linux/linux/input-event-codes.h	2024-01-01 00:00:00.000000000 +0800
+++ new/include/linux/linux/input-event-codes.h	2024-01-01 00:00:00.000000000 +0800
@@ -335,7 +335,7 @@
 #define KEY_WIMAX		KEY_WWAN
 #define KEY_RFKILL		247	/* Key that controls all radios */
 
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
+#define KEY_MICMUTE		251	/* Mute / unmute the microphone */
 
 /* Code 255 is reserved for special needs of AT keyboard driver */
 
@@ -834,7 +834,7 @@
 #define ABS_TOOL_WIDTH		0x1c
 
 #define ABS_VOLUME		0x20
-
+#define ABS_HAND_FEATURE 0x21
 #define ABS_MISC		0x28
 
 /*
@@ -889,7 +889,8 @@
 #define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
 #define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
 #define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_MAX			0x10
+#define SW_SUPER_PRIVACY	0x11  /* set = super privacy open */
+#define SW_MAX			    0x11
 #define SW_CNT			(SW_MAX+1)
 
 /*
diff -Naur old/src/evdev.c new/src/evdev.c
--- old/src/evdev.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev.c	2024-01-01 00:00:00.000000000 +0800
@@ -52,26 +52,6 @@
 #define DEFAULT_WHEEL_CLICK_ANGLE 15
 #define DEFAULT_BUTTON_SCROLL_TIMEOUT ms2us(200)
 
-enum evdev_device_udev_tags {
-	EVDEV_UDEV_TAG_INPUT		= bit(0),
-	EVDEV_UDEV_TAG_KEYBOARD		= bit(1),
-	EVDEV_UDEV_TAG_MOUSE		= bit(2),
-	EVDEV_UDEV_TAG_TOUCHPAD		= bit(3),
-	EVDEV_UDEV_TAG_TOUCHSCREEN	= bit(4),
-	EVDEV_UDEV_TAG_TABLET		= bit(5),
-	EVDEV_UDEV_TAG_JOYSTICK		= bit(6),
-	EVDEV_UDEV_TAG_ACCELEROMETER	= bit(7),
-	EVDEV_UDEV_TAG_TABLET_PAD	= bit(8),
-	EVDEV_UDEV_TAG_POINTINGSTICK	= bit(9),
-	EVDEV_UDEV_TAG_TRACKBALL	= bit(10),
-	EVDEV_UDEV_TAG_SWITCH		= bit(11),
-};
-
-struct evdev_udev_tag_match {
-	const char *name;
-	enum evdev_device_udev_tags tag;
-};
-
 static const struct evdev_udev_tag_match evdev_udev_tag_matches[] = {
 	{"ID_INPUT",			EVDEV_UDEV_TAG_INPUT},
 	{"ID_INPUT_KEYBOARD",		EVDEV_UDEV_TAG_KEYBOARD},
@@ -131,7 +111,12 @@
 {
 	int key_count = 0;
 	assert(code >= 0 && code < KEY_CNT);
-
+	if (code == BTN_LEFT) {
+		if (device->key_count[code] == pressed) {
+			return pressed;
+		}
+	}
+	
 	if (pressed) {
 		key_count = ++device->key_count[code];
 	} else {
@@ -209,6 +194,56 @@
 }
 
 static void
+evdev_pointer_post_button_touchpad(struct evdev_device *device,
+			  uint64_t time,
+			  unsigned int button,
+			  enum libinput_button_state state)
+{
+	int down_count;
+
+	down_count = evdev_update_key_down_count(device, button, state);
+
+	if ((state == LIBINPUT_BUTTON_STATE_PRESSED && down_count == 1) ||
+	    (state == LIBINPUT_BUTTON_STATE_RELEASED && down_count == 0)) {
+		pointer_notify_button_touchpad(&device->base, time, button, state);
+
+		if (state == LIBINPUT_BUTTON_STATE_RELEASED) {
+			if (device->left_handed.change_to_enabled)
+				device->left_handed.change_to_enabled(device);
+
+			if (device->scroll.change_scroll_method)
+				device->scroll.change_scroll_method(device);
+		}
+	}
+
+}
+
+static void
+evdev_pointer_post_tap(struct evdev_device *device,
+			  uint64_t time,
+			  unsigned int button,
+			  enum libinput_button_state state)
+{
+	int down_count;
+
+	down_count = evdev_update_key_down_count(device, button, state);
+
+	if ((state == LIBINPUT_BUTTON_STATE_PRESSED && down_count == 1) ||
+	    (state == LIBINPUT_BUTTON_STATE_RELEASED && down_count == 0)) {
+		pointer_notify_tap(&device->base, time, button, state);
+
+		if (state == LIBINPUT_BUTTON_STATE_RELEASED) {
+			if (device->left_handed.change_to_enabled)
+				device->left_handed.change_to_enabled(device);
+
+			if (device->scroll.change_scroll_method)
+				device->scroll.change_scroll_method(device);
+		}
+	}
+
+}
+
+static void
 evdev_button_scroll_timeout(uint64_t time, void *data)
 {
 	struct evdev_device *device = data;
@@ -329,6 +364,36 @@
 }
 
 void
+evdev_pointer_notify_button_touchpad(struct evdev_device *device,
+			    uint64_t time,
+			    unsigned int button,
+			    enum libinput_button_state state)
+{
+	if (device->scroll.method == LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN &&
+	    button == device->scroll.button) {
+		evdev_button_scroll_button(device, time, state);
+		return;
+	}
+
+	evdev_pointer_post_button_touchpad(device, time, button, state);
+}
+
+void
+evdev_pointer_notify_tap(struct evdev_device *device,
+			    uint64_t time,
+			    unsigned int button,
+			    enum libinput_button_state state)
+{
+	if (device->scroll.method == LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN &&
+	    button == device->scroll.button) {
+		evdev_button_scroll_button(device, time, state);
+		return;
+	}
+
+	evdev_pointer_post_tap(device, time, button, state);
+}
+
+void
 evdev_device_led_update(struct evdev_device *device, enum libinput_led leds)
 {
 	static const struct {
@@ -369,6 +434,17 @@
 }
 
 void
+evdev_transform_absolute_rect(struct evdev_device *device,
+			 struct device_coord_rect *rect)
+{
+	if (!device->abs.apply_calibration)
+		return;
+
+	matrix_mult_vec(&device->abs.calibration, &rect->x, &rect->y);
+	matrix_mult_vec(&device->abs.calibration, &rect->w, &rect->h);
+}
+
+void
 evdev_transform_relative(struct evdev_device *device,
 			 struct device_coords *point)
 {
@@ -384,7 +460,10 @@
 static inline double
 scale_axis(const struct input_absinfo *absinfo, double val, double to_range)
 {
-	return (val - absinfo->minimum) * to_range / absinfo_range(absinfo);
+    if (absinfo->maximum < absinfo->minimum) {
+        return 0.0;
+    }
+    return (val - absinfo->minimum) * to_range / absinfo_range(absinfo);
 }
 
 double
@@ -1965,6 +2044,9 @@
 	return true;
 }
 
+static enum evdev_device_udev_tags
+update_device_capability(struct evdev_device *device);
+
 static struct evdev_dispatch *
 evdev_configure_device(struct evdev_device *device)
 {
@@ -1974,11 +2056,17 @@
 	struct evdev_dispatch *dispatch;
 
 	udev_tags = evdev_device_get_udev_tags(device, device->udev_device);
+    libinput_log_printf("----evdev_configure_device  tagged as supported input device---- %d \r\n", udev_tags);
 
 	if ((udev_tags & EVDEV_UDEV_TAG_INPUT) == 0 ||
 	    (udev_tags & ~EVDEV_UDEV_TAG_INPUT) == 0) {
+		udev_tags = update_device_capability(device);
+	}
+	if ((udev_tags & EVDEV_UDEV_TAG_INPUT) == 0 ||
+	    (udev_tags & ~EVDEV_UDEV_TAG_INPUT) == 0) {
 		evdev_log_info(device,
 			       "not tagged as supported input device\n");
+        libinput_log_printf("----evdev_configure_device not tagged as supported input device---- \r\n");
 		return NULL;
 	}
 
@@ -2029,8 +2117,23 @@
 			udev_tags &= ~EVDEV_UDEV_TAG_TOUCHSCREEN;
 	}
 
+    if (udev_tags & EVDEV_UDEV_TAG_JOYSTICK) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_JOYSTICK_BULID-- \r\n");
+        dispatch = evdev_joystick_create(device);
+        device->seat_caps |= EVDEV_DEVICE_JOYSTICK;
+		return dispatch;
+    }
+	if (udev_tags & EVDEV_UDEV_TAG_SWITCH && libevdev_has_event_code(evdev, EV_SW, SW_SUPER_PRIVACY)) {
+		libinput_log_printf("device is a super privacy switch device.\r\n");
+		dispatch = evdev_privacy_switch_create(device);
+		device->seat_caps |= EVDEV_DEVICE_SWITCH;
+		device->tags |= EVDEV_TAG_PRIVACY_SWITCH;
+		return dispatch;
+	}
+
 	if (evdev_device_has_model_quirk(device,
 					 QUIRK_MODEL_DELL_CANVAS_TOTEM)) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TOTEM_BULID-- \r\n");
 		dispatch = evdev_totem_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET;
 		evdev_log_info(device, "device is a totem\n");
@@ -2046,6 +2149,7 @@
 
 	/* libwacom assigns tablet _and_ tablet_pad to the pad devices */
 	if (udev_tags & EVDEV_UDEV_TAG_TABLET_PAD) {
+	libinput_log_printf("----evdev_configure_device--_LIBINPUT_TABLET_PAD_BULID-- \r\n");
 		dispatch = evdev_tablet_pad_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET_PAD;
 		evdev_log_info(device, "device is a tablet pad\n");
@@ -2054,6 +2158,7 @@
 	}
 
 	if ((udev_tags & tablet_tags) == EVDEV_UDEV_TAG_TABLET) {
+	libinput_log_printf("----evdev_configure_device--_LIBINPUT_TABLET_BULID-- \r\n");
 		dispatch = evdev_tablet_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET;
 		evdev_log_info(device, "device is a tablet\n");
@@ -2061,6 +2166,7 @@
 	}
 
 	if (udev_tags & EVDEV_UDEV_TAG_TOUCHPAD) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TOUCHPAD_BULID-- \r\n");
 		if (udev_tags & EVDEV_UDEV_TAG_TABLET)
 			evdev_tag_tablet_touchpad(device);
 		/* whether velocity should be averaged, false by default */
@@ -2147,6 +2253,10 @@
 		return NULL;
 	}
 
+	if (udev_tags & EVDEV_UDEV_TAG_MSDP) {
+		device->seat_caps |= EVDEV_DEVICE_MSDP;
+	}
+
 	if (evdev_device_has_model_quirk(device, QUIRK_MODEL_INVERT_HORIZONTAL_SCROLLING)) {
 		device->scroll.invert_horizontal_scrolling = true;
 	}
@@ -2518,6 +2628,18 @@
 }
 
 unsigned int
+evdev_device_get_id_bustype(struct evdev_device *device)
+{
+	return libevdev_get_id_bustype(device->evdev);
+}
+
+unsigned int
+evdev_device_get_id_version(struct evdev_device *device)
+{
+	return libevdev_get_id_version(device->evdev);
+}
+
+unsigned int
 evdev_device_get_id_product(struct evdev_device *device)
 {
 	return libevdev_get_id_product(device->evdev);
@@ -2535,6 +2657,33 @@
 	return udev_device_ref(device->udev_device);
 }
 
+enum evdev_device_udev_tags
+	evdev_device_get_udev_device_tags(struct evdev_device* device)
+{
+    enum evdev_device_udev_tags udev_tags;
+    udev_tags = evdev_device_get_udev_tags(device, device->udev_device);
+    return udev_tags;
+}
+
+int
+evdev_has_event_type(struct evdev_device *device, unsigned int type)
+{
+    return libevdev_has_event_type(device->evdev, type);
+}
+
+int
+evdev_get_event_value(struct evdev_device *device, unsigned int type, unsigned int code)
+{
+    return libevdev_get_event_value(device->evdev, type, code);
+}
+
+int
+evdev_kernel_set_led_value(struct evdev_device *device, unsigned int code, unsigned int state)
+{
+    enum libevdev_led_value value = (state == 0 ? LIBEVDEV_LED_OFF : LIBEVDEV_LED_ON);
+    return libevdev_kernel_set_led_value(device->evdev, code, value);
+}
+
 void
 evdev_device_set_default_calibration(struct evdev_device *device,
 				     const float calibration[6])
@@ -2702,6 +2851,9 @@
 		return !!(device->seat_caps & EVDEV_DEVICE_TABLET_PAD);
 	case LIBINPUT_DEVICE_CAP_SWITCH:
 		return !!(device->seat_caps & EVDEV_DEVICE_SWITCH);
+	case LIBINPUT_DEVICE_CAP_JOYSTICK:
+		return !!(device->seat_caps & EVDEV_DEVICE_JOYSTICK);
+
 	default:
 		return false;
 	}
@@ -2902,10 +3054,9 @@
 	if (device->scroll.direction != 0) {
 		switch (source) {
 		case LIBINPUT_POINTER_AXIS_SOURCE_FINGER:
-			pointer_notify_axis_finger(&device->base,
-						   time,
-						   device->scroll.direction,
-						   &zero);
+			gesture_notify_axis_finger(&device->base, time,
+					LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END,
+					0, &zero);
 			break;
 		case LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS:
 			pointer_notify_axis_continuous(&device->base,
@@ -3163,3 +3314,85 @@
 #endif
 	return has_left_handed;
 }
+
+static inline bool
+is_touchscreen(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_ABS) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_MT_POSITION_X) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_MT_POSITION_Y) &&
+			libevdev_has_property(evdev, INPUT_PROP_DIRECT));
+}
+
+static inline bool
+is_mouse(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_REL) &&
+			libevdev_has_event_code(evdev, EV_REL, REL_X) &&
+			libevdev_has_event_code(evdev, EV_REL, REL_Y));
+}
+
+static inline bool
+is_keyboard(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_KEY) &&
+			!libevdev_has_event_type(evdev, EV_ABS) &&
+			!libevdev_has_event_type(evdev, EV_REL));
+}
+
+static inline bool
+is_touchpad(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_ABS) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_MT_POSITION_X));
+}
+
+static inline bool
+is_switch(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_SW));
+}
+
+static inline bool
+is_touchhand(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_ABS) &&
+	        libevdev_has_event_code(evdev, EV_ABS, ABS_HAND_FEATURE));
+}
+
+is_tablet_tool(const struct libevdev *evdev)
+{
+	return (libevdev_has_event_type(evdev, EV_KEY) &&
+			(libevdev_has_event_code(evdev, EV_KEY, BTN_TOOL_PEN) ||
+			 libevdev_has_event_code(evdev, EV_KEY, BTN_STYLUS)) &&
+			libevdev_has_event_type(evdev, EV_ABS) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_X) &&
+			libevdev_has_event_code(evdev, EV_ABS, ABS_Y));
+}
+
+static enum evdev_device_udev_tags
+update_device_capability(struct evdev_device *device)
+{
+	if (is_touchhand(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_MSDP);
+	}
+	if (is_touchscreen(device->evdev)) {
+        return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_TOUCHSCREEN);
+	}
+	if (is_mouse(device->evdev)) {
+        return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_MOUSE);
+	}
+	if (is_keyboard(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_KEYBOARD);
+	}
+	if (is_tablet_tool(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_TABLET);
+	}
+	if (is_touchpad(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_TOUCHPAD);
+	}
+	if (is_switch(device->evdev)) {
+		return (EVDEV_UDEV_TAG_INPUT | EVDEV_UDEV_TAG_SWITCH);
+	}
+    return 0;
+}
diff -Naur old/src/evdev-fallback.c new/src/evdev-fallback.c
--- old/src/evdev-fallback.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-fallback.c	2024-01-01 00:00:00.000000000 +0800
@@ -229,8 +229,11 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	struct device_coords point;
+	struct device_coord_rect rect;
 	struct mt_slot *slot;
 	int seat_slot;
+	struct touch_axis axis;
+	int tool_type;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -253,8 +256,12 @@
 	slot->hysteresis_center = point;
 	evdev_transform_absolute(device, &point);
 
-	touch_notify_touch_down(base, time, slot_idx, seat_slot,
-				&point);
+	tool_type = slot->tool_type;
+	axis = slot->axis;
+	rect = slot->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touch_notify_touch_down(base, time, slot_idx, seat_slot, slot->pressure, &slot->extraData,
+				&axis, &point, tool_type, &rect);
 
 	return true;
 }
@@ -267,8 +274,11 @@
 {
 	struct libinput_device *base = &device->base;
 	struct device_coords point;
+	struct device_coord_rect rect;
 	struct mt_slot *slot;
 	int seat_slot;
+	struct touch_axis axis;
+	int tool_type;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -276,6 +286,7 @@
 	slot = &dispatch->mt.slots[slot_idx];
 	seat_slot = slot->seat_slot;
 	point = slot->point;
+    axis = slot->axis;
 
 	if (seat_slot == -1)
 		return false;
@@ -284,8 +295,12 @@
 		return false;
 
 	evdev_transform_absolute(device, &point);
-	touch_notify_touch_motion(base, time, slot_idx, seat_slot,
-				  &point);
+
+	tool_type = slot->tool_type;
+	rect = slot->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touch_notify_touch_motion(base, time, slot_idx, seat_slot, slot->pressure, &slot->extraData,
+				  &axis, &point, tool_type, &rect);
 
 	return true;
 }
@@ -300,6 +315,7 @@
 	struct libinput_seat *seat = base->seat;
 	struct mt_slot *slot;
 	int seat_slot;
+	int tool_type;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -313,7 +329,9 @@
 
 	seat->slot_map &= ~bit(seat_slot);
 
-	touch_notify_touch_up(base, time, slot_idx, seat_slot);
+	tool_type = slot->tool_type;
+
+	touch_notify_touch_up(base, time, slot_idx, seat_slot, tool_type);
 
 	return true;
 }
@@ -354,7 +372,12 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	struct device_coords point;
+	const struct device_coord_rect rect = { 0 };
+	const struct touch_axis axis = { 0 };
+	const struct extra_data data = { 0 };
 	int seat_slot;
+	int tool_type;
+	int32_t pressure = dispatch->abs.pressure;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -376,7 +399,9 @@
 	point = dispatch->abs.point;
 	evdev_transform_absolute(device, &point);
 
-	touch_notify_touch_down(base, time, -1, seat_slot, &point);
+	tool_type = -1;
+
+	touch_notify_touch_down(base, time, -1, seat_slot, pressure, &data, &axis, &point, tool_type, &rect);
 
 	return true;
 }
@@ -388,7 +413,12 @@
 {
 	struct libinput_device *base = &device->base;
 	struct device_coords point;
+	const struct device_coord_rect rect = {0};
+	const struct touch_axis axis = { 0 };
+	const struct extra_data data = { 0 };
 	int seat_slot;
+	int tool_type;
+	int32_t pressure = dispatch->abs.pressure;
 
 	point = dispatch->abs.point;
 	evdev_transform_absolute(device, &point);
@@ -398,11 +428,22 @@
 	if (seat_slot == -1)
 		return false;
 
-	touch_notify_touch_motion(base, time, -1, seat_slot, &point);
+	tool_type = -1;
+
+	touch_notify_touch_motion(base, time, -1, seat_slot, pressure, &data, &axis, &point, tool_type, &rect);
 
 	return true;
 }
 
+static void
+fallback_flush_msdp_motion(struct fallback_dispatch *dispatch,
+			 struct evdev_device *device,
+			 uint64_t time)
+{
+	struct libinput_device *base = &device->base;
+	touch_notify_msdp(base, time);
+}
+
 static bool
 fallback_flush_st_up(struct fallback_dispatch *dispatch,
 		     struct evdev_device *device,
@@ -411,6 +452,7 @@
 	struct libinput_device *base = &device->base;
 	struct libinput_seat *seat = base->seat;
 	int seat_slot;
+	int tool_type;
 
 	if (!(device->seat_caps & EVDEV_DEVICE_TOUCH))
 		return false;
@@ -423,7 +465,9 @@
 
 	seat->slot_map &= ~bit(seat_slot);
 
-	touch_notify_touch_up(base, time, -1, seat_slot);
+	tool_type = -1;
+
+	touch_notify_touch_up(base, time, -1, seat_slot, tool_type);
 
 	return true;
 }
@@ -528,6 +572,14 @@
 {
 	struct mt_slot *slot = &dispatch->mt.slots[dispatch->mt.slot];
 
+	if (e->code == 0x2a) {
+		dispatch->device->sensor_timestamp.seconds = e->value;
+		return;
+	}
+	if (e->code == 0x2b) {
+		dispatch->device->sensor_timestamp.microseconds = e->value;
+		return;
+	}
 	if (e->code == ABS_MT_SLOT) {
 		if ((size_t)e->value >= dispatch->mt.slots_len) {
 			evdev_log_bug_libinput(device,
@@ -541,6 +593,11 @@
 	}
 
 	switch (e->code) {
+	case ABS_MT_BLOB_ID:
+		slot->extraData.blob_id = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
 	case ABS_MT_TRACKING_ID:
 		if (e->value >= 0) {
 			dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
@@ -598,6 +655,42 @@
 			break;
 		}
 		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->tool_type = e->value;
+		slot->dirty = true;
+		break;
+	case ABS_MT_PRESSURE:
+        slot->pressure = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOUCH_MAJOR:
+        slot->axis.major = e->value;
+        dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+        slot->dirty = true;
+		break;
+    case ABS_MT_TOUCH_MINOR:
+        slot->axis.minor = e->value;
+        dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+        slot->dirty = true;
+        break;
+	case ABS_MT_WIDTH_MAJOR:
+		slot->tool_rect.w = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_WIDTH_MINOR:
+		slot->tool_rect.h = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOOL_X:
+		slot->tool_rect.x = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
+		slot->dirty = true;
+		break;
+	case ABS_MT_TOOL_Y:
+		slot->tool_rect.y = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MT;
 		slot->dirty = true;
 		break;
 	}
@@ -608,6 +701,11 @@
 				 struct evdev_device *device,
 				 struct input_event *e)
 {
+	if (e->code == 0x21) {
+		dispatch->device->hand_status.hand_feature = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MOTION;
+		return;
+	}
 	switch (e->code) {
 	case ABS_X:
 		evdev_device_check_abs_axis_range(device, e->code, e->value);
@@ -619,6 +717,10 @@
 		dispatch->abs.point.y = e->value;
 		dispatch->pending_event |= EVDEV_ABSOLUTE_MOTION;
 		break;
+	case ABS_PRESSURE:
+		dispatch->abs.pressure = e->value;
+		dispatch->pending_event |= EVDEV_ABSOLUTE_MOTION;
+		break;
 	}
 }
 
@@ -920,6 +1022,10 @@
 			fallback_flush_absolute_motion(dispatch,
 						       device,
 						       time);
+		} else if (device->seat_caps & EVDEV_DEVICE_MSDP) {
+			fallback_flush_msdp_motion(dispatch,
+								device,
+								time);
 		}
 	}
 
@@ -1556,6 +1662,7 @@
 
 	for (slot = 0; slot < num_slots; ++slot) {
 		slots[slot].seat_slot = -1;
+		slots[slot].tool_type = -1;
 
 		if (evdev_need_mtdev(device))
 			continue;
@@ -1718,3 +1825,11 @@
 
 	return &dispatch->base;
 }
+
+bool
+evdev_device_touch_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType)
+{
+	struct fallback_dispatch *dispatch = fallback_dispatch(device->dispatch);
+
+	return hw_is_key_down(dispatch, btnToolType);
+}
diff -Naur old/src/evdev-fallback.h new/src/evdev-fallback.h
--- old/src/evdev-fallback.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-fallback.h	2024-01-01 00:00:00.000000000 +0800
@@ -75,11 +75,16 @@
 
 struct mt_slot {
 	bool dirty;
+	struct extra_data extraData;
 	enum mt_slot_state state;
 	int32_t seat_slot;
 	struct device_coords point;
 	struct device_coords hysteresis_center;
 	enum palm_state palm_state;
+	struct device_coord_rect tool_rect;
+	int32_t pressure;
+	struct touch_axis axis;
+	int32_t tool_type;
 };
 
 struct fallback_dispatch {
@@ -97,6 +102,7 @@
 	struct {
 		struct device_coords point;
 		int32_t seat_slot;
+		int32_t pressure;
 	} abs;
 
 	struct {
@@ -191,6 +197,8 @@
 static inline enum key_type
 get_key_type(uint16_t code)
 {
+	const uint16_t KEY_ENDCALL = 0x2e8;
+	const uint16_t KEY_FUNCTION = 0x2fe;
 	switch (code) {
 	case BTN_TOOL_PEN:
 	case BTN_TOOL_RUBBER:
@@ -220,6 +228,8 @@
 		return KEY_TYPE_KEY;
 	if (code >= BTN_TRIGGER_HAPPY && code <= BTN_TRIGGER_HAPPY40)
 		return KEY_TYPE_BUTTON;
+	if (code == KEY_ENDCALL || code == KEY_FUNCTION)
+		return KEY_TYPE_KEY;
 	return KEY_TYPE_NONE;
 }
 
diff -Naur old/src/evdev.h new/src/evdev.h
--- old/src/evdev.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev.h	2024-01-01 00:00:00.000000000 +0800
@@ -61,6 +61,8 @@
 	EVDEV_DEVICE_TABLET_PAD		= bit(4),
 	EVDEV_DEVICE_GESTURE		= bit(5),
 	EVDEV_DEVICE_SWITCH		= bit(6),
+	EVDEV_DEVICE_JOYSTICK = bit(7),
+	EVDEV_DEVICE_MSDP		= bit(8),
 };
 
 enum evdev_device_tags {
@@ -74,6 +76,12 @@
 	EVDEV_TAG_EXTERNAL_KEYBOARD	= bit(7),
 	EVDEV_TAG_TABLET_MODE_SWITCH	= bit(8),
 	EVDEV_TAG_TABLET_TOUCHPAD	= bit(9),
+	EVDEV_TAG_PRIVACY_SWITCH	=bit(10),
+};
+
+struct evdev_udev_tag_match {
+    const char* name;
+    enum evdev_device_udev_tags tag;
 };
 
 enum evdev_middlebutton_state {
@@ -177,6 +185,7 @@
 	enum evdev_device_tags tags;
 	bool is_mt;
 	bool is_suspended;
+	int32_t pressureMax;
 	int dpi; /* HW resolution */
 	double trackpoint_multiplier; /* trackpoint constant multiplier */
 	bool use_velocity_averaging; /* whether averaging should be applied on velocity calculation */
@@ -271,6 +280,15 @@
 		uint32_t button_mask;
 		uint64_t first_event_time;
 	} middlebutton;
+
+	struct {
+		int32_t seconds;
+		int32_t microseconds;
+	} sensor_timestamp;
+
+	struct {
+		int32_t hand_feature;
+	} hand_status;
 };
 
 static inline struct evdev_device *
@@ -354,6 +372,8 @@
 	DISPATCH_TABLET,
 	DISPATCH_TABLET_PAD,
 	DISPATCH_TOTEM,
+	DISPATCH_JOYSTICK,
+	DISPATCH_PRIVACY_SWITCH,
 };
 
 struct evdev_dispatch {
@@ -407,6 +427,10 @@
 			 struct device_coords *point);
 
 void
+evdev_transform_absolute_rect(struct evdev_device *device,
+			 struct device_coord_rect *rect);
+
+void
 evdev_transform_relative(struct evdev_device *device,
 			 struct device_coords *point);
 
@@ -431,12 +455,21 @@
 evdev_device_init_pointer_acceleration(struct evdev_device *device,
 				       struct motion_filter *filter);
 
+struct evdev_dispatch*
+evdev_joystick_create(struct evdev_device* device);
+
+struct evdev_dispatch*
+evdev_privacy_switch_create(struct evdev_device* device);
+
 struct evdev_dispatch *
 evdev_touchpad_create(struct evdev_device *device);
 
 struct evdev_dispatch *
 evdev_mt_touchpad_create(struct evdev_device *device);
 
+bool
+evdev_device_touchpad_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType);
+
 struct evdev_dispatch *
 evdev_tablet_create(struct evdev_device *device);
 
@@ -474,6 +507,12 @@
 evdev_device_get_name(struct evdev_device *device);
 
 unsigned int
+evdev_device_get_id_bustype(struct evdev_device *device);
+
+unsigned int
+evdev_device_get_id_version(struct evdev_device *device);
+
+unsigned int
 evdev_device_get_id_product(struct evdev_device *device);
 
 unsigned int
@@ -482,6 +521,19 @@
 struct udev_device *
 evdev_device_get_udev_device(struct evdev_device *device);
 
+/**  @brief   获取设备类型 */
+enum evdev_device_udev_tags
+evdev_device_get_udev_device_tags(struct evdev_device* device);
+
+int
+evdev_has_event_type(struct evdev_device *device, unsigned int type);
+
+int
+evdev_get_event_value(struct evdev_device *device, unsigned int type, unsigned int code);
+
+int
+evdev_kernel_set_led_value(struct evdev_device *device, unsigned int code, unsigned int state);
+
 void
 evdev_device_set_default_calibration(struct evdev_device *device,
 				     const float calibration[6]);
@@ -507,6 +559,9 @@
 int
 evdev_device_get_touch_count(struct evdev_device *device);
 
+bool
+evdev_device_touch_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType);
+
 int
 evdev_device_has_switch(struct evdev_device *device,
 			enum libinput_switch sw);
@@ -561,6 +616,19 @@
 			    uint64_t time,
 			    unsigned int button,
 			    enum libinput_button_state state);
+
+void
+evdev_pointer_notify_button_touchpad(struct evdev_device *device,
+			    uint64_t time,
+			    unsigned int button,
+			    enum libinput_button_state state);
+
+void
+evdev_pointer_notify_tap(struct evdev_device *device,
+			    uint64_t time,
+			    unsigned int button,
+			    enum libinput_button_state state);
+
 void
 evdev_pointer_notify_physical_button(struct evdev_device *device,
 				     uint64_t time,
@@ -646,6 +714,9 @@
 static inline double
 evdev_convert_to_mm(const struct input_absinfo *absinfo, double v)
 {
+	if (absinfo->resolution  == 0){
+	    return 0.0;
+	}
 	double value = v - absinfo->minimum;
 	return value/absinfo->resolution;
 }
@@ -781,12 +852,15 @@
 
 	if (!is_logged(evdev_libinput_context(device), priority))
 		return;
-
+        const char *name = evdev_device_get_sysname(device);
+        if (strchr(name, '%') != NULL) {
+                return;
+        }
 	/* Anything info and above is user-visible, use the device name */
 	snprintf(buf,
 		 sizeof(buf),
 		 "%-7s - %s%s%s",
-		 evdev_device_get_sysname(device),
+		 name,
 		 (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  device->log_prefix_name : "",
 		 (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  ": " : "",
 		 format);
@@ -1028,7 +1102,8 @@
 				   "Axis %#x value %d is outside expected range [%d, %d]\n"
 				   "See %s/absolute_coordinate_ranges.html for details\n",
 				   code, value, min, max,
-				   HTTP_DOC_LINK);
+				   "");
+				//HTTP_DOC_LINK);
 	}
 }
 
diff -Naur old/src/evdev-joystick.c new/src/evdev-joystick.c
--- old/src/evdev-joystick.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-joystick.c	2024-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,590 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <string.h>
+
+#include "config.h"
+#include "libinput-version.h"
+#include "evdev-joystick.h"
+#include "libinput.h"
+#include "libinput-util.h"
+
+static inline struct
+joystick_dispatch* get_joystick_dispatch(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return NULL;
+    }
+    evdev_verify_dispatch_type(dispatch, DISPATCH_JOYSTICK);
+
+    struct joystick_dispatch* joystick_dispatch = NULL;
+    joystick_dispatch = container_of(dispatch, struct joystick_dispatch, base);
+
+    return joystick_dispatch;
+}
+
+static int
+update_seat_joystick_button_count(struct libinput_seat* seat, int32_t key, uint32_t *seat_count, enum libinput_button_state state)
+{
+    if (seat == NULL || seat_count == NULL || key < SYN_REPORT || key > KEY_MAX) {
+        return false;
+    }
+
+    switch (state) {
+        case LIBINPUT_BUTTON_STATE_PRESSED:
+        {
+            *(seat_count) = ++seat->button_count[key];
+            break;
+        }
+        case LIBINPUT_BUTTON_STATE_RELEASED:
+        {
+            if (seat->button_count[key] == 0)
+            {
+                *(seat_count) = seat->button_count[key];
+            }
+            else
+            {
+                *(seat_count) = --seat->button_count[key];
+            }
+            break;
+        }
+        default:
+        {
+            *(seat_count) = 0;
+            break;
+        }
+    }
+    return true;
+}
+
+static void
+joystick_notify_axis(struct evdev_device* device, uint64_t time)
+{
+    if (device == NULL) {
+        return;
+    }
+
+	struct joystick_dispatch *joystick_dispatch = get_joystick_dispatch(device->dispatch);
+	if (joystick_dispatch == NULL) {
+        libinput_log_printf("joystick_dispatch is NULL.\n");
+		return;
+	}
+
+    struct libinput_event_joystick_axis* joystick_axis_event = zalloc(sizeof * joystick_axis_event);
+    if (joystick_axis_event == NULL) {
+        libinput_log_printf("pJoystickEvent is NULL.\n");
+        return;
+    }
+
+    *joystick_axis_event = (struct libinput_event_joystick_axis) {
+	    .base.type = LIBINPUT_EVENT_POINTER_AXIS,
+	    .base.device = &device->base,
+        .type = EV_ABS,
+        .time = time,
+        .axis_value_mask = joystick_dispatch->axis_value_mask,
+	    .abs_throttle = joystick_dispatch->axis_abs_infos.abs_throttle,
+	    .abs_hat0x = joystick_dispatch->axis_abs_infos.abs_hat0x,
+	    .abs_hat0y = joystick_dispatch->axis_abs_infos.abs_hat0y,
+	    .abs_x = joystick_dispatch->axis_abs_infos.abs_x,
+		.abs_y = joystick_dispatch->axis_abs_infos.abs_y,
+		.abs_z = joystick_dispatch->axis_abs_infos.abs_z,
+		.abs_rx = joystick_dispatch->axis_abs_infos.abs_rx,
+		.abs_ry = joystick_dispatch->axis_abs_infos.abs_ry,
+		.abs_rz = joystick_dispatch->axis_abs_infos.abs_rz,
+    };
+
+    struct libinput_event_listener* listener = NULL;
+    list_for_each_safe(listener, &device->base.event_listeners, link) {
+        listener->notify_func(time, &joystick_axis_event->base, listener->notify_func_data);
+    }
+
+    libinput_post_handle_event(device->base.seat->libinput, &joystick_axis_event->base);
+}
+
+static void
+joystick_notify_key_event(struct evdev_device* device, struct input_event* event, uint64_t time)
+{
+    if (device == NULL || event == NULL) {
+        return;
+    }
+
+    struct libinput_event_joystick_button* button_event = {0};
+    uint32_t seat_count = 0;
+
+    int ret = update_seat_joystick_button_count(device->base.seat, event->code, &seat_count, event->value);
+    if (ret == 0) {
+        return;
+    }
+
+    button_event = zalloc(sizeof * button_event);
+    if (button_event == NULL) {
+        return;
+    }
+
+	*button_event = (struct libinput_event_joystick_button) {
+			.base.type = LIBINPUT_EVENT_JOYSTICK_BUTTON,
+			.base.device = &device->base,
+            .time = time,
+            .type = event->type,
+            .key = event->code,
+            .value = event->value,
+            .seat_key_count = seat_count,
+            .state = event->value,
+    };
+
+    struct libinput_event_listener* listener = NULL;
+    list_for_each_safe(listener, &device->base.event_listeners, link)
+    {
+        listener->notify_func(time, &button_event->base, listener->notify_func_data);
+    }
+
+    libinput_post_handle_event(device->base.seat->libinput, &button_event->base);
+}
+
+static float
+abs_value_standardize(int32_t value, int32_t minimum, int32_t maximum, float standard_min, float standard_max)
+{
+    return standard_min + ((float)value - (float)minimum) * ((float)(standard_max - standard_min)) / ((float)(maximum - minimum));
+}
+
+static float
+get_joystick_abs_standard_value(struct libinput_event_joystick_axis_abs_info *absinfo)
+{
+    const int32_t value = absinfo->value;
+    const int32_t minimum = absinfo->minimum;
+    const int32_t maximum = absinfo->maximum;
+    if (minimum >= maximum) {
+		libinput_log_printf("joystick abs: minimum(%u) >= maximum(%u).\n", minimum, maximum);
+        return 0.f;
+    } else if (value < minimum || value > maximum) {
+		libinput_log_printf("joystick abs: value(%d) not between minimum(%u) and maximum(%u).\n", value, minimum, maximum);
+		return 0.f;
+    }
+
+    const int32_t code = absinfo->code;
+    switch (code) {
+	case ABS_THROTTLE:
+	{
+		return abs_value_standardize(value, minimum, maximum, 0, 1.0);
+	}
+	case ABS_X:
+	case ABS_Y:
+	case ABS_Z:
+	case ABS_RX:
+	case ABS_RY:
+	case ABS_RZ:
+    {
+        return abs_value_standardize(value, minimum, maximum, -1.0, 1.0);
+	}
+    case ABS_HAT0X:
+    case ABS_HAT0Y:
+    {
+        return (float)value;
+    }
+    default:
+    return (float)value;
+    }
+}
+
+static void joystick_set_axis_value_mask(struct joystick_dispatch *joystick_dispatch, enum libinput_joystick_axis_source axis)
+{
+    joystick_dispatch->axis_value_mask |= (uint32_t)axis;
+}
+
+static void joystick_reset_axis_value_mask(struct joystick_dispatch *joystick_dispatch)
+{
+	joystick_dispatch->axis_value_mask = 0;
+}
+
+static bool joystick_is_axis_value_mask(struct joystick_dispatch *joystick_dispatch)
+{
+	return (joystick_dispatch->axis_value_mask != 0);
+}
+
+static void joystick_get_one_abs_info(struct joystick_dispatch *joystick_dispatch, struct evdev_device *device, struct input_event *event,
+    const uint32_t code)
+{
+    struct libinput_event_joystick_axis_abs_info *absinfo = NULL;
+    switch (code) {
+    case ABS_THROTTLE:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_throttle;
+    break;
+    case ABS_HAT0X:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_hat0x;
+    break;
+    case ABS_HAT0Y:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_hat0y;
+    break;
+    case ABS_X:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_x;
+    break;
+    case ABS_Y:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_y;
+    break;
+	case ABS_Z:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z);
+	absinfo = &joystick_dispatch->axis_abs_infos.abs_z;
+    break;
+	case ABS_RX:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX);
+	absinfo = &joystick_dispatch->axis_abs_infos.abs_rx;
+	break;
+	case ABS_RY:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY);
+	absinfo = &joystick_dispatch->axis_abs_infos.abs_ry;
+	break;
+    case ABS_RZ:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_rz;
+    break;
+    case ABS_GAS:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_gas;
+    break;
+    case ABS_BRAKE:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE);
+    absinfo = &joystick_dispatch->axis_abs_infos.abs_brake;
+    break;
+    default:
+    break;
+    }
+
+    if (absinfo == NULL) {
+        libinput_log_printf("unsupported joystick abs event: device_name:%s code:%d value:%d.\n",
+            device->devname, code, event->value);
+        return;
+    }
+
+    struct libevdev *evdev = device->evdev;
+    evdev_device_check_abs_axis_range(device, event->code, event->value);
+    const struct input_absinfo *absinfo_raw = libevdev_get_abs_info(evdev, event->code);
+    absinfo->code = event->code;
+    absinfo->value = event->value;
+    absinfo->minimum = absinfo_raw->minimum;
+    absinfo->maximum = absinfo_raw->maximum;
+    absinfo->fuzz = absinfo_raw->fuzz;
+    absinfo->flat = absinfo_raw->flat;
+    absinfo->resolution = absinfo_raw->resolution;
+    absinfo->standardValue = get_joystick_abs_standard_value(absinfo);
+}
+
+static void
+joystick_notify_absolute_event(struct joystick_dispatch* pJoystick,
+    struct evdev_device* device, struct input_event* event, uint64_t time)
+{
+    if (pJoystick == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    joystick_get_one_abs_info(pJoystick, device, event, event->code);
+}
+
+static void
+joystick_flush(struct joystick_dispatch* joystick_dispatch, struct evdev_device* device, uint64_t time)
+{
+    if (joystick_dispatch == NULL || device == NULL) {
+        return;
+    }
+
+    if (joystick_dispatch->axis_value_mask != 0) {
+        joysticks_notify_axis(&device->base, time, joystick_dispatch->axis_value_mask, 
+            &joystick_dispatch->axis_abs_infos);
+        joystick_reset_axis_value_mask(joystick_dispatch);
+    }
+}
+
+static void
+joystick_process(struct evdev_dispatch* dispatch, struct evdev_device* device,
+    struct input_event* event, uint64_t time)
+{
+    if (dispatch == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    switch (event->type) {
+    case EV_ABS: {
+        joystick_notify_absolute_event(joystick_dispatch, device, event, time);
+    }
+    break;
+    case EV_KEY: {
+        joystick_notify_key_event(device, event, time);
+    }
+    break;
+    case EV_SYN: {
+        joystick_flush(joystick_dispatch, device, time);
+    }
+    break;
+    case EV_MSC:
+    /* ignore do not process */
+    break;
+    case EV_REL:
+    case EV_SW:
+    case EV_LED:
+    case EV_SND:
+    case EV_REP:
+    case EV_FF:
+    case EV_PWR:
+    case EV_FF_STATUS:
+    case EV_MAX:
+    case EV_CNT:
+    default:
+        libinput_log_printf("unsupported joystick event type: %d, devname: %s.\n", event->type, device->devname);
+    break;
+    }
+}
+
+static void joystick_suspend(struct evdev_dispatch* dispatch, struct evdev_device* device)
+{
+    if (dispatch == NULL || device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+   joystick_flush(joystick_dispatch, device, 0);
+}
+
+static void
+joystick_destroy(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (dispatch == NULL) {
+        return;
+    }
+
+    free(joystick_dispatch);
+}
+
+static void
+joystick_device_added(struct evdev_device* device,
+    struct evdev_device* added_device)
+{
+    if (device == NULL || added_device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(device->dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    bool is_joystick = false;
+    if (libinput_device_get_device_group(&device->base) !=
+        libinput_device_get_device_group(&added_device->base)) {
+        return;
+    }
+    is_joystick = evdev_device_has_capability(added_device,
+        LIBINPUT_DEVICE_CAP_JOYSTICK);
+
+    if (is_joystick) {
+        evdev_log_debug(device,
+            "joystick: activated for %s<->%s\n",
+            device->devname,
+            added_device->devname);
+        joystick_dispatch->device = added_device;
+    }
+}
+
+static void
+joystick_device_removed(struct evdev_device* device,
+    struct evdev_device* removed_device)
+{
+    if (device == NULL || removed_device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(device->dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    if (joystick_dispatch->device == removed_device) {
+        joystick_dispatch->device = NULL;
+    }
+}
+
+static struct evdev_dispatch_interface joystick_interface = {
+    .process = joystick_process,
+    .suspend = joystick_suspend,
+    .remove = NULL,
+    .destroy = joystick_destroy,
+    .device_added = joystick_device_added,
+    .device_removed = joystick_device_removed,
+    .device_suspended = NULL,
+    .device_resumed = NULL,
+    .post_added = NULL,
+    .touch_arbitration_toggle = NULL,
+    .touch_arbitration_update_rect = NULL,
+    .get_switch_state = NULL,
+};
+
+static enum libinput_config_status
+joystick_sendevents_set_mode(struct libinput_device* device,
+    enum libinput_config_send_events_mode mode)
+{
+    if (device == NULL)     {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct joystick_dispatch* joystick_dispatch = (struct joystick_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || joystick_dispatch == NULL) {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    if (mode == joystick_dispatch->sendevents.current_mode) {
+        return LIBINPUT_CONFIG_STATUS_SUCCESS;
+    }
+
+    switch (mode) {
+    case LIBINPUT_CONFIG_SEND_EVENTS_ENABLED:
+        break;
+    case LIBINPUT_CONFIG_SEND_EVENTS_DISABLED:
+        joystick_suspend(ev_device->dispatch, ev_device);
+        break;
+    default:
+        return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+    }
+
+    joystick_dispatch->sendevents.current_mode = mode;
+
+    return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+static uint32_t
+joystick_sendevents_get_modes(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+}
+
+static enum libinput_config_send_events_mode
+joystick_sendevents_get_mode(struct libinput_device* device)
+{
+    if (device == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct joystick_dispatch* pDispatch = (struct joystick_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || pDispatch == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    return pDispatch->sendevents.current_mode;
+}
+
+static enum libinput_config_send_events_mode
+joystick_sendevents_get_default_mode(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+}
+
+#ifdef _DEBUG
+void printf_joystick_absinfo(const char *abs_name, struct libinput_event_joystick_axis_abs_info *absinfo)
+{
+    printf("%s: code: %d, value: %d, minimum: %d, maximum: %d, fuzz: %d, flat: %d, resolution: %d, standardValue: %f\n",
+        abs_name,
+        absinfo->code,
+        absinfo->value,
+        absinfo->minimum,
+        absinfo->maximum,
+        absinfo->fuzz,
+        absinfo->flat,
+        absinfo->resolution,
+        absinfo->standardValue
+        );
+}
+
+void print_libinput_event_joystick_axis(struct libinput_event_joystick_axis *p)
+{
+    printf("JOYSTICK:\n"
+        "type: %d, device: %p, type: %d, time: 0x%x\n",
+        p->base.type,
+        p->base.device,
+        p->type,
+        p->time);
+    printf_joystick_absinfo("abs_throttle", &p->abs_throttle);
+    printf_joystick_absinfo("abs_hat0x", &p->abs_hat0x);
+    printf_joystick_absinfo("abs_hat0y", &p->abs_hat0y);
+    printf_joystick_absinfo("abs_x", &p->abs_x);
+	printf_joystick_absinfo("abs_y", &p->abs_y);
+	printf_joystick_absinfo("abs_z", &p->abs_z);
+	printf_joystick_absinfo("abs_rx", &p->abs_rx);
+	printf_joystick_absinfo("abs_ry", &p->abs_ry);
+    printf_joystick_absinfo("abs_rz", &p->abs_rz);
+}
+#endif // _DEBUG
+
+/**
+ * @brief 初始化joystick_dispatch
+ * @param joystick
+ * @param device
+ * @return bool true - 成功, false - 失败
+*/
+bool
+joystick_init(struct joystick_dispatch* pJoystick, struct evdev_device* device)
+{
+    if (pJoystick == NULL || device == NULL) {
+        return false;
+    }
+
+    pJoystick->base.dispatch_type = DISPATCH_JOYSTICK;
+    pJoystick->base.interface = &joystick_interface;
+    pJoystick->device = device;
+
+    return true;
+}
+
+struct evdev_dispatch*
+evdev_joystick_create(struct evdev_device* device)
+{
+    if (device == NULL) {
+        return NULL;
+    }
+
+    struct joystick_dispatch* joystick = {0};
+    joystick = zalloc(sizeof * joystick);
+
+    if (joystick_init(joystick, device) != true) {
+        joystick_destroy(&joystick->base);
+        joystick = NULL;
+        return NULL;
+    }
+
+    device->base.config.sendevents = &joystick->sendevents.config;
+    joystick->sendevents.current_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+    joystick->sendevents.config.get_modes = joystick_sendevents_get_modes;
+    joystick->sendevents.config.set_mode = joystick_sendevents_set_mode;
+    joystick->sendevents.config.get_mode = joystick_sendevents_get_mode;
+    joystick->sendevents.config.get_default_mode = joystick_sendevents_get_default_mode;
+
+    return &joystick->base;
+}
+
diff -Naur old/src/evdev-joystick.h new/src/evdev-joystick.h
--- old/src/evdev-joystick.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-joystick.h	2024-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef LIBINPUT_EVDEV_JOYSTICK_H
+#define LIBINPUT_EVDEV_JOYSTICK_H
+
+#include "evdev.h"
+#include "libinput-private.h"
+
+struct joystick_dispatch {
+	struct evdev_dispatch base;
+	struct evdev_device* device;
+	uint32_t axis_value_mask;
+	struct joystick_axis_abs_infos axis_abs_infos;
+	struct {
+		struct libinput_device_config_send_events config;
+		enum libinput_config_send_events_mode current_mode;
+	} sendevents;
+};
+
+struct libinput_event_joystick_button {
+	struct libinput_event base;
+	uint32_t type;
+	uint64_t time;
+	uint32_t key;
+	uint32_t seat_key_count;
+	enum libinput_button_state state;
+	int value;
+};
+
+struct libinput_event_joystick_axis {
+	struct libinput_event base;
+    uint32_t type;
+	uint64_t time;
+	uint32_t axis_value_mask;
+	struct libinput_event_joystick_axis_abs_info abs_throttle;
+	struct libinput_event_joystick_axis_abs_info abs_hat0x;
+	struct libinput_event_joystick_axis_abs_info abs_hat0y;
+	struct libinput_event_joystick_axis_abs_info abs_x;
+	struct libinput_event_joystick_axis_abs_info abs_y;
+	struct libinput_event_joystick_axis_abs_info abs_z;
+	struct libinput_event_joystick_axis_abs_info abs_rx;
+	struct libinput_event_joystick_axis_abs_info abs_ry;
+	struct libinput_event_joystick_axis_abs_info abs_rz;
+	struct libinput_event_joystick_axis_abs_info abs_gas;
+	struct libinput_event_joystick_axis_abs_info abs_brake;
+};
+
+#ifdef _DEBUG
+void print_libinput_event_joystick_axis(struct libinput_event_joystick_axis* p);
+#endif // _DEBUG
+
+/**
+ * @brief 创建evdev_dispatch结构体
+ * @param device
+ * @return struct evdev_dispatch*
+*/
+struct evdev_dispatch* evdev_joystick_create(struct evdev_device* device);
+
+#endif
diff -Naur old/src/evdev-mt-touchpad-buttons.c new/src/evdev-mt-touchpad-buttons.c
--- old/src/evdev-mt-touchpad-buttons.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad-buttons.c	2024-01-01 00:00:00.000000000 +0800
@@ -635,9 +635,9 @@
 	/* button height: 10mm or 15% or the touchpad height,
 	   whichever is smaller */
 	if (height * 0.15 > 10)
-		mm.y = height - 10;
+		mm.y = height - 18;
 	else
-		mm.y = height * 0.85;
+		mm.y = height * 0.78;
 
 	mm.x = width * 0.5;
 	edges = evdev_device_mm_to_units(device, &mm);
@@ -1210,10 +1210,11 @@
 			return 0;
 	}
 
-	evdev_pointer_notify_button(tp->device, time, button, state);
+	evdev_pointer_notify_button_touchpad(tp->device, time, button, state);
 	return 1;
 }
 
+#define BTN_RIGHT_MENUE 0x118
 static int
 tp_post_clickpadbutton_buttons(struct tp_dispatch *tp, uint64_t time)
 {
@@ -1288,7 +1289,7 @@
 		} else if (area & RIGHT) {
 			button = BTN_RIGHT;
 		} else if (area & LEFT) {
-			button = BTN_LEFT;
+			button = BTN_RIGHT_MENUE;
 		} else { /* main or no area (for clickfinger) is always BTN_LEFT */
 			button = BTN_LEFT;
 			want_left_handed = false;
diff -Naur old/src/evdev-mt-touchpad.c new/src/evdev-mt-touchpad.c
--- old/src/evdev-mt-touchpad.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad.c	2024-01-01 00:00:00.000000000 +0800
@@ -330,6 +330,35 @@
 }
 
 static inline void
+tp_tool_key_set(struct tp_dispatch *tp,
+		   unsigned int code,
+		   bool is_press)
+{
+	unsigned int shift = 0;
+
+	switch (code) {
+		case BTN_TOOL_PEN:
+		case BTN_TOOL_RUBBER:
+		case BTN_TOOL_BRUSH:
+		case BTN_TOOL_PENCIL:
+		case BTN_TOOL_AIRBRUSH:
+		case BTN_TOOL_FINGER:
+		case BTN_TOOL_MOUSE:
+		case BTN_TOOL_LENS:
+			shift = code - BTN_TOOL_PEN;
+			break;
+		default:
+			return;
+	}
+
+	if (is_press) {
+		tp->tool_touches |= 0x1 << shift;
+	} else {
+		tp->tool_touches &= ~(0x1 << shift);
+	}
+}
+
+static inline void
 tp_new_touch(struct tp_dispatch *tp, struct tp_touch *t, uint64_t time)
 {
 	if (t->state == TOUCH_BEGIN ||
@@ -362,6 +391,7 @@
 	t->speed.last_speed = 0;
 	t->speed.exceeded_count = 0;
 	t->hysteresis.x_motion_history = 0;
+	t->seat_slot = -1;
 	tp->queued |= TOUCHPAD_EVENT_MOTION;
 }
 
@@ -515,6 +545,81 @@
 	return absinfo->maximum - (value - absinfo->minimum);
 }
 
+void tp_ext_post_event(struct tp_dispatch* dispatch, bool is_up, uint64_t time)
+{
+	struct tp_touch * t = tp_current_touch(dispatch);
+	int seat_slot = t->seat_slot;
+	if (is_up) {
+		if (seat_slot == -1) {
+			return;
+		}
+
+		dispatch->orginal.active_slot_count--;
+		if (dispatch->orginal.active_slot_count < 0) {
+			dispatch->orginal.active_slot_count = 0;
+		}
+
+		if (dispatch->orginal.active_slot_count == 0) {
+			dispatch->orginal.seat_slot_id = 0;
+		}
+
+		tp_tap_original_up(dispatch, t, time);
+		return;
+	}
+
+	if (seat_slot == -1) {
+		t->seat_slot = dispatch->orginal.seat_slot_id++;
+		dispatch->orginal.active_slot_count++;
+
+		tp_tap_original_down(dispatch, t, time);
+		return;
+	}
+
+	tp_tap_original_motion(dispatch, t, time);
+}
+
+void tp_ext_on_xy_update(struct tp_dispatch* dispatch)
+{
+	dispatch->orginal.xy_updated = true;
+}
+
+void tp_ext_on_mt_slot(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
+void tp_ext_before_new_touch(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
+void tp_ext_before_delete_touch(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+	};
+
+	tp_ext_post_event(dispatch, true, time);
+}
+
+void tp_ext_on_sync(struct tp_dispatch* dispatch, uint64_t time)
+{
+	if (dispatch->orginal.xy_updated) {
+		dispatch->orginal.xy_updated = false;
+		tp_ext_post_event(dispatch, false, time);
+		return;
+	};
+}
+
 static void
 tp_process_absolute(struct tp_dispatch *tp,
 		    const struct input_event *e,
@@ -524,6 +629,7 @@
 
 	switch(e->code) {
 	case ABS_MT_POSITION_X:
+		tp_ext_on_xy_update(tp);
 		evdev_device_check_abs_axis_range(tp->device,
 						  e->code,
 						  e->value);
@@ -532,6 +638,7 @@
 		tp->queued |= TOUCHPAD_EVENT_MOTION;
 		break;
 	case ABS_MT_POSITION_Y:
+		tp_ext_on_xy_update(tp);
 		evdev_device_check_abs_axis_range(tp->device,
 						  e->code,
 						  e->value);
@@ -540,14 +647,17 @@
 		tp->queued |= TOUCHPAD_EVENT_MOTION;
 		break;
 	case ABS_MT_SLOT:
+		tp_ext_on_mt_slot(tp, time);
 		tp->slot = e->value;
 		break;
 	case ABS_MT_TRACKING_ID:
 		if (e->value != -1) {
+			tp_ext_before_new_touch(tp, time);
 			tp->nactive_slots += 1;
 			tp_new_touch(tp, t, time);
 		} else {
 			assert(tp->nactive_slots >= 1);
+			tp_ext_before_delete_touch(tp, time);
 			tp->nactive_slots -= 1;
 			tp_end_sequence(tp, t, time);
 		}
@@ -559,6 +669,7 @@
 		break;
 	case ABS_MT_TOOL_TYPE:
 		t->is_tool_palm = e->value == MT_TOOL_PALM;
+		t->tool_type = e->value;
 		t->dirty = true;
 		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
 		break;
@@ -572,6 +683,26 @@
 		t->dirty = true;
 		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
 		break;
+	case ABS_MT_WIDTH_MAJOR:
+		t->tool_rect.w = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_WIDTH_MINOR:
+		t->tool_rect.h = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_TOOL_X:
+		t->tool_rect.x = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
+	case ABS_MT_TOOL_Y:
+		t->tool_rect.y = e->value;
+		t->dirty = true;
+		tp->queued |= TOUCHPAD_EVENT_OTHERAXIS;
+		break;
 	}
 }
 
@@ -783,6 +914,20 @@
 			tp_process_trackpoint_button(tp, e, time);
 			break;
 	}
+
+	switch (e->code) {
+		case BTN_TOOL_PEN:
+		case BTN_TOOL_RUBBER:
+		case BTN_TOOL_BRUSH:
+		case BTN_TOOL_PENCIL:
+		case BTN_TOOL_AIRBRUSH:
+		case BTN_TOOL_FINGER:
+		case BTN_TOOL_MOUSE:
+		case BTN_TOOL_LENS:
+			tp_tool_key_set(tp, e->code, !!e->value);
+		default:
+			break;
+	}
 }
 
 static void
@@ -1958,6 +2103,7 @@
 		tp_process_msc(tp, e, time);
 		break;
 	case EV_SYN:
+		tp_ext_on_sync(tp, time);
 		tp_handle_state(tp, time);
 #if 0
 		tp_debug_touch_state(tp, device);
@@ -2860,6 +3006,8 @@
 	t->tp = tp;
 	t->has_ended = true;
 	t->index = index;
+	t->seat_slot = -1;
+	t->tool_type = -1;
 }
 
 static inline void
@@ -3362,18 +3510,18 @@
 	if (width < 70.0)
 		return;
 
-	/* palm edges are 8% of the width on each side */
-	mm.x = min(8, width * 0.08);
+	/* palm edges are 5mm of the width on each side */
+	mm.x = 5;
 	edges = evdev_device_mm_to_units(device, &mm);
 	tp->palm.left_edge = edges.x;
 
-	mm.x = width - min(8, width * 0.08);
+	mm.x = width - 5;
 	edges = evdev_device_mm_to_units(device, &mm);
 	tp->palm.right_edge = edges.x;
 
 	if (!tp->buttons.has_topbuttons && height > 55) {
-		/* top edge is 5% of the height */
-		mm.y = height * 0.05;
+		/* top edge is 5mm of the height */
+		mm.y = 5;
 		edges = evdev_device_mm_to_units(device, &mm);
 		tp->palm.upper_edge = edges.y;
 	}
@@ -3788,6 +3936,10 @@
 	if (tp->gesture.enabled)
 		device->seat_caps |= EVDEV_DEVICE_GESTURE;
 
+	tp->orginal.seat_slot_id = 0;
+	tp->orginal.active_slot_count = 0;
+	tp->orginal.xy_updated = 0;
+
 	return true;
 }
 
@@ -3971,6 +4123,14 @@
 
 	tp = zalloc(sizeof *tp);
 
+	const struct input_absinfo* absInfo = device->is_mt ? libevdev_get_abs_info(device->evdev, ABS_MT_PRESSURE)
+		: libevdev_get_abs_info(device->evdev, ABS_PRESSURE);
+	if (absInfo == NULL) {
+		device->pressureMax = 0.0;
+	} else {
+		device->pressureMax = absInfo->maximum;
+	}
+
 	if (!tp_init(tp, device)) {
 		tp_interface_destroy(&tp->base);
 		return NULL;
@@ -3988,3 +4148,27 @@
 
 	return &tp->base;
 }
+
+bool
+evdev_device_touchpad_btn_tool_type_down(struct evdev_device *device, int32_t btnToolType)
+{
+	struct tp_dispatch *tp = tp_dispatch(device->dispatch);
+
+	unsigned int shift = 0;
+	switch (btnToolType) {
+	case BTN_TOOL_PEN:
+	case BTN_TOOL_RUBBER:
+	case BTN_TOOL_BRUSH:
+	case BTN_TOOL_PENCIL:
+	case BTN_TOOL_AIRBRUSH:
+	case BTN_TOOL_FINGER:
+	case BTN_TOOL_MOUSE:
+	case BTN_TOOL_LENS:
+		shift = btnToolType - BTN_TOOL_PEN;
+		break;
+	default:
+		return false;
+	}
+
+	return (tp->tool_touches >> shift) & 0x1;
+}
diff -Naur old/src/evdev-mt-touchpad-gestures.c new/src/evdev-mt-touchpad-gestures.c
--- old/src/evdev-mt-touchpad-gestures.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad-gestures.c	2024-01-01 00:00:00.000000000 +0800
@@ -124,6 +124,37 @@
 }
 
 static void
+tp_get_raw_touches(struct tp_dispatch *tp, struct sloted_coords_info *raw_touches)
+{
+	struct tp_touch *t;
+	unsigned int i;
+	raw_touches->active_count = 0;
+
+	if (tp->num_slots > MAX_SOLTED_COORDS_NUM) {
+		evdev_log_bug_libinput(tp->device,
+				       "in %s, num_slots: %d, more than %d\n",
+				       __func__, tp->num_slots, MAX_SOLTED_COORDS_NUM);
+	}
+	const unsigned int num_slots = (tp->num_slots > MAX_SOLTED_COORDS_NUM) ? MAX_SOLTED_COORDS_NUM : tp->num_slots;
+
+	for (i = 0; i < num_slots; i++) {
+		t = &tp->touches[i];
+
+		if (!tp_touch_active_for_gesture(tp, t))
+			continue;
+
+		if (t->dirty) {
+			struct device_coords d;
+			d = tp_get_delta(t);
+			raw_touches->coords[i].x = d.x;
+			raw_touches->coords[i].y = d.y;
+		}
+		raw_touches->coords[i].is_active = true;
+		raw_touches->active_count++;
+	}
+}
+
+static void
 tp_gesture_init_scroll(struct tp_dispatch *tp)
 {
 	struct phys_coords zero = {0.0, 0.0};
@@ -169,6 +200,9 @@
 		break;
 	case GESTURE_STATE_SCROLL:
 		tp_gesture_init_scroll(tp);
+		gesture_notify_axis_finger(&tp->device->base, time,
+					LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN,
+					0, &zero);
 		break;
 	case GESTURE_STATE_PINCH:
 		gesture_notify_pinch(&tp->device->base, time,
@@ -180,7 +214,7 @@
 		gesture_notify_swipe(&tp->device->base, time,
 				     LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 				     tp->gesture.finger_count,
-				     &zero, &zero);
+				     &zero, &zero, NULL);
 		break;
 	case GESTURE_STATE_POINTER_MOTION:
 		break;
@@ -233,7 +267,7 @@
 		struct device_float_coords unaccel;
 
 		unaccel = tp_scale_to_xaxis(tp, raw);
-		pointer_notify_motion(&tp->device->base,
+		touchpad_pointer_notify_motion(&tp->device->base,
 				      time,
 				      &delta,
 				      &unaccel);
@@ -1190,14 +1224,150 @@
 			  &delta);
 }
 
+static double
+calculate_cosine_similarity(struct tp_dispatch *tp, struct device_coords *delta1, struct device_coords *delta2)
+{
+
+	double dx1 = delta1->x;
+	double dy1 = delta1->y;
+	double dx2 = delta2->x;
+	double dy2 = delta2->y;
+
+	double dist1 = sqrt(dx1 * dx1 + dy1 * dy1);
+	double dist2 = sqrt(dx2 * dx2 + dy2 * dy2);
+
+	if (dist1 < 1 && dist2 < 1) {
+		return 0.0;
+	}
+	double ret = (dx1 * dx2 + dy1 * dy2) / (dist1 * dist2);
+
+	return ret;
+}
+
+static double
+calculate_finger_speed(struct tp_dispatch *tp, struct device_coords *curr_coord, struct device_coords *pre_coord)
+{
+	int delta_x = curr_coord->x - pre_coord->x;
+	int delta_y = curr_coord->y - pre_coord->y;
+
+	return sqrt(delta_x * delta_x + delta_y * delta_y);
+}
+
+struct gesture_device_coords {
+	struct device_coords coords[5];
+	int coords_len;
+};
+
+#define FINGER_COUNT_MAX 5
+static struct gesture_device_coords *
+get_gesture_device_coords(void)
+{
+	static struct gesture_device_coords gesture_coords = {
+		{{0, 0},
+		{0, 0},
+		{0, 0},
+		{0, 0},
+		{0, 0},},
+		FINGER_COUNT_MAX
+	};
+
+	return &gesture_coords;
+}
+
+static void 
+updata_gesture_device_coords(struct device_coords *coords, int coords_len)
+{
+	struct gesture_device_coords * gesture_coords = get_gesture_device_coords();
+	memcpy(gesture_coords->coords, coords, coords_len * sizeof(struct device_coords));
+	gesture_coords->coords_len = coords_len;
+}
+
+static void 
+reset_gesture_device_coords(void)
+{
+	struct gesture_device_coords * gesture_coords = get_gesture_device_coords();
+	memset(gesture_coords->coords, 0, FINGER_COUNT_MAX * sizeof(struct device_coords));
+	gesture_coords->coords_len = FINGER_COUNT_MAX;
+}
+
+#define FOUR_FINGER_SIMILAR_CNT 6
+#define THREE_FINGER_SIMILAR_CNT 3
+static bool
+calculate_swipe_cosine_similarity(struct tp_dispatch *tp, struct device_coords *coords, int coordsLen)
+{
+	// 3 or 4 finger
+	double similaritys[FOUR_FINGER_SIMILAR_CNT] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
+	if (coordsLen == 3 || coordsLen == 4) {
+		uint idx = 0;
+		for (int i = 0; i < coordsLen; i++) {
+			for (int j = i + 1; j < coordsLen; j++) {
+				similaritys[idx] = calculate_cosine_similarity(tp, &coords[i], &coords[j]);
+				idx++;
+			}
+		}
+	} else {
+		return 0.0;
+	}
+
+	int similarity_count = 0;
+	double sum = 0.0;
+	double ave = 0.0;
+	double variance = 0.0;
+
+	similarity_count = (coordsLen == 4) ? FOUR_FINGER_SIMILAR_CNT : THREE_FINGER_SIMILAR_CNT;
+	for (int i = 0; i < similarity_count; i++) {
+		sum += similaritys[i];
+	}
+	ave = sum / similarity_count;
+
+	// Calculate  variance
+	for (int i = 0; i < similarity_count; i++) {
+		variance += pow(similaritys[i] - ave, 2) / similarity_count;
+	}
+
+	// variance <= 0.001 are the same direction
+	return variance < 0.001 ? true : false;
+}
+
+static void
+tp_gesture_handle_state_swipe_private(struct tp_dispatch *tp, uint64_t time)
+{
+	struct device_float_coords raw;
+	struct normalized_coords delta, unaccel;
+
+	raw = tp_get_average_touches_delta(tp);
+	delta = tp_filter_motion(tp, &raw, time);
+
+	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
+		unaccel = tp_normalize_delta(tp, raw);
+		tp_gesture_start(tp, time);
+
+		struct device_coords coords[5];
+		for (uint32_t i = 0; i < tp->nfingers_down; i++) {
+			coords[i] = tp->touches[i].point;
+		}
+
+		if (calculate_swipe_cosine_similarity(tp, coords, tp->nfingers_down) == false) {
+			evdev_log_error(tp->device, "libinput gesture is unknown.");
+		}
+
+		gesture_notify_swipe_private(&tp->device->base, time,
+				     LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+				     tp->gesture.finger_count,
+				     &delta, &unaccel, coords, tp->nfingers_down);
+	}
+}
+
 static void
 tp_gesture_handle_state_swipe(struct tp_dispatch *tp, uint64_t time)
 {
 	struct device_float_coords raw;
+	struct sloted_coords_info raw_touches = {};
 	struct normalized_coords delta, unaccel;
 
 	raw = tp_get_average_touches_delta(tp);
 	delta = tp_filter_motion(tp, &raw, time);
+	tp_get_raw_touches(tp, &raw_touches);
 
 	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
 		unaccel = tp_filter_motion_unaccelerated(tp, &raw, time);
@@ -1205,7 +1375,7 @@
 		gesture_notify_swipe(&tp->device->base, time,
 				     LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
 				     tp->gesture.finger_count,
-				     &delta, &unaccel);
+				     &delta, &unaccel, &raw_touches);
 	}
 }
 
@@ -1269,7 +1439,7 @@
 		tp_gesture_handle_state_scroll(tp, time);
 
 	if (tp->gesture.state == GESTURE_STATE_SWIPE)
-		tp_gesture_handle_state_swipe(tp, time);
+		tp_gesture_handle_state_swipe_private(tp, time);
 
 	if (tp->gesture.state == GESTURE_STATE_PINCH)
 		tp_gesture_handle_state_pinch(tp, time);
diff -Naur old/src/evdev-mt-touchpad.h new/src/evdev-mt-touchpad.h
--- old/src/evdev-mt-touchpad.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad.h	2024-01-01 00:00:00.000000000 +0800
@@ -132,6 +132,7 @@
 	TAP_STATE_2FGTAP_DRAGGING_2,
 	TAP_STATE_3FGTAP_DRAGGING_2,
 	TAP_STATE_DEAD, /**< finger count exceeded */
+	TAP_STATE_HOLDING,
 };
 
 enum tp_tap_touch_state {
@@ -192,10 +193,14 @@
 	int pressure;
 	bool is_tool_palm; /* MT_TOOL_PALM */
 	int major, minor;
+    struct device_coord_rect tool_rect;
 
 	bool was_down; /* if distance == 0, false for pure hovering
 			  touches */
 
+	int seat_slot;
+	int tool_type;
+
 	struct {
 		/* A quirk mostly used on Synaptics touchpads. In a
 		   transition to/from fake touches > num_slots, the current
@@ -310,6 +315,17 @@
 	 */
 	unsigned int fake_touches;
 
+	/* bit 0: BTN_TOOL_PEN
+	 * bit 1: BTN_TOOL_RUBBER
+	 * bit 2: BTN_TOOL_BRUSH
+	 * bit 3: BTN_TOOL_PENCIL
+	 * bit 4: BTN_TOOL_AIRBRUSH
+	 * bit 5: BTN_TOOL_FINGER
+	 * bit 6: BTN_TOOL_MOUSE
+	 * bit 7: BTN_TOOL_LENS
+	 */
+	unsigned int tool_touches;
+
 	struct {
 		bool detection_disabled;
 		struct ratelimit warning;
@@ -535,6 +551,12 @@
 		struct evdev_device *tablet_device;
 		bool tablet_left_handed_state;
 	} left_handed;
+
+	struct {
+		int seat_slot_id;
+		int active_slot_count;
+		int xy_updated;
+	} orginal;
 };
 
 static inline struct tp_dispatch*
@@ -767,4 +789,19 @@
 struct tp_touch*
 tp_thumb_get_touch(struct tp_dispatch *tp);
 
+void
+tp_tap_original_down(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
+void
+tp_tap_original_up(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
+void
+tp_tap_original_motion(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time);
+
 #endif
diff -Naur old/src/evdev-mt-touchpad-tap.c new/src/evdev-mt-touchpad-tap.c
--- old/src/evdev-mt-touchpad-tap.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad-tap.c	2024-01-01 00:00:00.000000000 +0800
@@ -88,6 +88,7 @@
 	CASE_RETURN_STRING(TAP_STATE_2FGTAP_DRAGGING_2);
 	CASE_RETURN_STRING(TAP_STATE_3FGTAP_DRAGGING_2);
 	CASE_RETURN_STRING(TAP_STATE_DEAD);
+	CASE_RETURN_STRING(TAP_STATE_HOLDING);
 	}
 	return NULL;
 }
@@ -125,6 +126,10 @@
 	      int nfingers,
 	      enum libinput_button_state state)
 {
+	if (tp->tap.state == TAP_STATE_IDLE) {
+		return;
+	}
+
 	int32_t button;
 	int32_t button_map[2][3] = {
 		{ BTN_LEFT, BTN_RIGHT, BTN_MIDDLE },
@@ -138,12 +143,16 @@
 
 	button = button_map[tp->tap.map][nfingers - 1];
 
+	if (tp->device->key_count[button] == 0 &&
+		state == LIBINPUT_BUTTON_STATE_RELEASED)
+		return;
+
 	if (state == LIBINPUT_BUTTON_STATE_PRESSED)
 		tp->tap.buttons_pressed |= bit(nfingers);
 	else
 		tp->tap.buttons_pressed &= ~bit(nfingers);
 
-	evdev_pointer_notify_button(tp->device,
+	evdev_pointer_notify_tap(tp->device,
 				    time,
 				    button,
 				    state);
@@ -264,6 +273,10 @@
 		tp->tap.nfingers_down--;
 		t->tap.state = TAP_TOUCH_STATE_DEAD;
 		tp_tap_clear_timer(tp);
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_PRESSED);
 		break;
 	case TAP_EVENT_PALM:
 		tp->tap.state = TAP_STATE_IDLE;
@@ -290,8 +303,48 @@
 		tp->tap.state = TAP_STATE_IDLE;
 		break;
 	case TAP_EVENT_MOTION:
+		tp->tap.state = TAP_STATE_HOLDING;
+		break;
+	case TAP_EVENT_TIMEOUT:
+		break;
+	case TAP_EVENT_BUTTON:
+		tp->tap.state = TAP_STATE_DEAD;
+		break;
+	case TAP_EVENT_THUMB:
+		tp->tap.state = TAP_STATE_IDLE;
+		t->tap.is_thumb = true;
+		tp->tap.nfingers_down--;
+		t->tap.state = TAP_TOUCH_STATE_DEAD;
+		break;
+	case TAP_EVENT_PALM:
+		tp->tap.state = TAP_STATE_IDLE;
+		break;
+	case TAP_EVENT_PALM_UP:
+		break;
+	}
+	if ((tp->tap.state != TAP_STATE_HOLDING) && (tp->tap.state != TAP_STATE_HOLD)) {
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_RELEASED);
+	}
+}
+
+static void
+tp_tap_holding_handle_event(struct tp_dispatch *tp,
+			    struct tp_touch *t,
+			    enum tap_event event, uint64_t time)
+{
+
+	switch (event) {
+	case TAP_EVENT_TOUCH:
 		tp_tap_move_to_dead(tp, t);
 		break;
+	case TAP_EVENT_RELEASE:
+		tp->tap.state = TAP_STATE_IDLE;
+		break;
+	case TAP_EVENT_MOTION:
+		break;
 	case TAP_EVENT_TIMEOUT:
 		break;
 	case TAP_EVENT_BUTTON:
@@ -309,6 +362,12 @@
 	case TAP_EVENT_PALM_UP:
 		break;
 	}
+	if (tp->tap.state != TAP_STATE_HOLDING) {
+		tp_tap_notify(tp,
+			      tp->tap.saved_press_time,
+			      1,
+			      LIBINPUT_BUTTON_STATE_RELEASED);
+    }
 }
 
 static void
@@ -1143,6 +1202,9 @@
 	case TAP_STATE_DEAD:
 		tp_tap_dead_handle_event(tp, t, event, time);
 		break;
+	case TAP_STATE_HOLDING:
+		tp_tap_holding_handle_event(tp, t, event, time);
+		break;
 	}
 
 	if (tp->tap.state == TAP_STATE_IDLE || tp->tap.state == TAP_STATE_DEAD)
@@ -1419,23 +1481,7 @@
 static enum libinput_config_tap_state
 tp_tap_default(struct evdev_device *evdev)
 {
-	/**
-	 * If we don't have a left button we must have tapping enabled by
-	 * default.
-	 */
-	if (!libevdev_has_event_code(evdev->evdev, EV_KEY, BTN_LEFT))
-		return LIBINPUT_CONFIG_TAP_ENABLED;
-
-	/**
-	 * Tapping is disabled by default for two reasons:
-	 * * if you don't know that tapping is a thing (or enabled by
-	 *   default), you get spurious mouse events that make the desktop
-	 *   feel buggy.
-	 * * if you do know what tapping is and you want it, you
-	 *   usually know where to enable it, or at least you can search for
-	 *   it.
-	 */
-	return LIBINPUT_CONFIG_TAP_DISABLED;
+	return LIBINPUT_CONFIG_TAP_ENABLED;
 }
 
 static enum libinput_config_tap_state
@@ -1499,7 +1545,7 @@
 static inline enum libinput_config_drag_state
 tp_drag_default(struct evdev_device *device)
 {
-	return LIBINPUT_CONFIG_DRAG_ENABLED;
+	return LIBINPUT_CONFIG_DRAG_DISABLED;
 }
 
 static enum libinput_config_drag_state
@@ -1661,3 +1707,63 @@
 		return false;
 	}
 }
+
+void
+tp_tap_original_down(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	struct evdev_device *device = tp->device;
+	int slot_idx = tp->slot;
+	int seat_slot = t->seat_slot;
+	int32_t pressure = t->pressure;
+	int tool_type = t->tool_type;
+	struct device_coords point;
+	struct device_coord_rect rect;
+	point = t->point;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	rect = t->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touchpad_notify_touch_down(base, time, slot_idx, seat_slot, pressure, tool_type, axis, &point, &rect);
+}
+
+void
+tp_tap_original_up(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	int slot_idx = tp->slot;
+	int seat_slot = t->seat_slot;
+	t->seat_slot = -1;
+	int tool_type = t->tool_type;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	touchpad_notify_touch_up(base, time, slot_idx, seat_slot, tool_type, axis);
+}
+
+void
+tp_tap_original_motion(struct tp_dispatch *tp,
+		    struct tp_touch *t,
+		    uint64_t time)
+{
+	struct libinput_device *base = &tp->device->base;
+	struct evdev_device *device = tp->device;
+	int seat_slot = t->seat_slot;
+	int slot_idx = tp->slot;
+	int32_t pressure = t->pressure;
+	int tool_type = t->tool_type;
+	struct device_coords point;
+    struct device_coord_rect rect;
+	point = t->point;
+	struct touch_axis axis;
+	axis.major = t->major;
+	axis.minor = t->minor;
+	rect = t->tool_rect;
+	evdev_transform_absolute_rect(device, &rect);
+	touchpad_notify_touch_motion(base, time, slot_idx, seat_slot, pressure, tool_type, axis, &point, &rect);
+}
\ No newline at end of file
diff -Naur old/src/evdev-privacy-switch.c new/src/evdev-privacy-switch.c
--- old/src/evdev-privacy-switch.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-privacy-switch.c	2024-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <string.h>
+
+#include "config.h"
+#include "libinput-version.h"
+#include "evdev-privacy-switch.h"
+#include "libinput.h"
+#include "libinput-util.h"
+
+struct privacy_switch_dispatch {
+	struct evdev_dispatch base;
+	struct evdev_device* device;
+	uint64_t time;
+	uint32_t mask;
+	struct privacy_switch ev_switch;
+	struct {
+		struct libinput_device_config_send_events config;
+		enum libinput_config_send_events_mode current_mode;
+	} sendevents;
+};
+
+static inline struct
+privacy_switch_dispatch* get_privacy_switch_dispatch(struct evdev_dispatch* dispatch)
+{
+    evdev_verify_dispatch_type(dispatch, DISPATCH_PRIVACY_SWITCH);
+
+    struct privacy_switch_dispatch* pSwitchDispatch = NULL;
+    pSwitchDispatch = container_of(dispatch, struct privacy_switch_dispatch, base);
+
+    return pSwitchDispatch;
+}
+
+static void
+privacy_switch_post_event(struct privacy_switch_dispatch* pSwitchDispatch,
+    struct evdev_device* device, struct input_event* event, uint64_t time)
+{
+    if (pSwitchDispatch == NULL || device == NULL || event == NULL) {
+        return;
+    }
+    pSwitchDispatch->mask = 1;
+    pSwitchDispatch->ev_switch.time = time;
+    pSwitchDispatch->ev_switch.sw = LIBINPUT_SWITCH_PRIVACY;
+
+
+    if (event->value == 1) {
+        pSwitchDispatch->ev_switch.state = LIBINPUT_SWITCH_STATE_ON;
+    } else {
+        pSwitchDispatch->ev_switch.state = LIBINPUT_SWITCH_STATE_OFF;
+    }
+}
+
+static inline void privacy_switch_reset_mask(struct privacy_switch_dispatch* pSwitchDispatch)
+{
+	pSwitchDispatch->mask = 0;
+}
+
+static void
+privacy_switch_flush(struct privacy_switch_dispatch* pSwitchDispatch, struct evdev_device* device, uint64_t time)
+{
+    if (pSwitchDispatch == NULL || device == NULL) {
+        return;
+    }
+
+    if (pSwitchDispatch->mask == 1) {
+        privacy_switch_notify_event(&device->base, time, &pSwitchDispatch->ev_switch);
+        privacy_switch_reset_mask(pSwitchDispatch);
+    }
+}
+
+static void
+privacy_switch_process(struct evdev_dispatch* dispatch, struct evdev_device* device,
+    struct input_event* event, uint64_t time)
+{
+    if (dispatch == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    struct privacy_switch_dispatch* pSwitchDispatch = get_privacy_switch_dispatch(dispatch);
+    if (pSwitchDispatch == NULL) {
+        return;
+    }
+
+    switch (event->type) {
+    case EV_SW: {
+        privacy_switch_post_event(pSwitchDispatch, device, event, time);
+    }
+    break;
+    case EV_SYN: {
+        privacy_switch_flush(pSwitchDispatch, device, time);
+    }
+    break;
+    default:
+        libinput_log_printf("unsupported privacy_switch event type: %d, devname: %s.\n", event->type, device->devname);
+    break;
+    }
+}
+
+static void
+privacy_switch_destroy(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return;
+    }
+    struct privacy_switch_dispatch* pSwitchDispatch = get_privacy_switch_dispatch(dispatch);
+    if (pSwitchDispatch == NULL) {
+        return;
+    }
+
+    free(pSwitchDispatch);
+}
+
+static void
+privacy_switch_device_added(struct evdev_device* device,
+    struct evdev_device* added_device)
+{
+    if (device == NULL || added_device == NULL || device->dispatch == NULL) {
+        return;
+    }
+    struct privacy_switch_dispatch* privacy_switch_dispatch = get_privacy_switch_dispatch(device->dispatch);
+    if (privacy_switch_dispatch == NULL) {
+        return;
+    }
+    if (libinput_device_get_device_group(&device->base) !=
+        libinput_device_get_device_group(&added_device->base)) {
+        return;
+    }
+    bool is_privacy_switch = false;
+    is_privacy_switch = evdev_device_has_capability(added_device,
+        LIBINPUT_DEVICE_CAP_SWITCH);
+
+    if (is_privacy_switch) {
+        evdev_log_debug(device,
+            "privacy_switch: activated for %s<->%s\n",
+            device->devname,
+            added_device->devname);
+        privacy_switch_dispatch->device = added_device;
+    }
+}
+
+static void
+privacy_switch_device_removed(struct evdev_device* device, struct evdev_device* removed_device)
+{
+    if (device == NULL || removed_device == NULL) {
+        return;
+    }
+    struct privacy_switch_dispatch* pSwitchDispatch = get_privacy_switch_dispatch(device->dispatch);
+    if (pSwitchDispatch == NULL) {
+        return;
+    }
+
+    if (pSwitchDispatch->device == removed_device) {
+        pSwitchDispatch->device = NULL;
+    }
+}
+
+static void privacy_switch_suspend(struct evdev_dispatch* dispatch, struct evdev_device* device)
+{
+    if (dispatch == NULL || device == NULL) {
+        return;
+    }
+    struct privacy_switch_dispatch* pSwitchDispatch = get_privacy_switch_dispatch(dispatch);
+    if (pSwitchDispatch == NULL) {
+        return;
+    }
+    privacy_switch_flush(pSwitchDispatch, device, 0);
+}
+
+static struct evdev_dispatch_interface privacy_switch_interface = {
+    .process = privacy_switch_process,
+    .suspend = privacy_switch_suspend,
+    .remove = NULL,
+    .destroy = privacy_switch_destroy,
+    .device_added = privacy_switch_device_added,
+    .device_removed = privacy_switch_device_removed,
+    .device_suspended = NULL,
+    .device_resumed = NULL,
+    .post_added = NULL,
+    .touch_arbitration_toggle = NULL,
+    .touch_arbitration_update_rect = NULL,
+    .get_switch_state = NULL,
+};
+
+static enum libinput_config_status
+privacy_switch_sendevents_set_mode(struct libinput_device* device,
+    enum libinput_config_send_events_mode mode)
+{
+    if (device == NULL)     {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct privacy_switch_dispatch* pSwitchDispatch = (struct privacy_switch_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || pSwitchDispatch == NULL) {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    if (mode == pSwitchDispatch->sendevents.current_mode) {
+        return LIBINPUT_CONFIG_STATUS_SUCCESS;
+    }
+
+    switch (mode) {
+    case LIBINPUT_CONFIG_SEND_EVENTS_ENABLED:
+        break;
+    case LIBINPUT_CONFIG_SEND_EVENTS_DISABLED:
+        privacy_switch_suspend(ev_device->dispatch, ev_device);
+        break;
+    default:
+        return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+    }
+
+    pSwitchDispatch->sendevents.current_mode = mode;
+
+    return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+static uint32_t
+privacy_switch_sendevents_get_modes(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+}
+
+static enum libinput_config_send_events_mode
+privacy_switch_sendevents_get_mode(struct libinput_device* device)
+{
+    if (device == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct privacy_switch_dispatch* pDispatch = (struct privacy_switch_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || pDispatch == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    return pDispatch->sendevents.current_mode;
+}
+
+static enum libinput_config_send_events_mode
+privacy_switch_sendevents_get_default_mode(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+}
+
+static bool
+privacy_switch_init(struct privacy_switch_dispatch* pSwitch, struct evdev_device* device)
+{
+    if (pSwitch == NULL || device == NULL) {
+        return false;
+    }
+
+    pSwitch->base.dispatch_type = DISPATCH_PRIVACY_SWITCH;
+    pSwitch->base.interface = &privacy_switch_interface;
+    pSwitch->device = device;
+
+    return true;
+}
+
+struct evdev_dispatch*
+evdev_privacy_switch_create(struct evdev_device* device)
+{
+    if (device == NULL) {
+        return NULL;
+    }
+
+    struct privacy_switch_dispatch* privacySwitch = NULL;
+    privacySwitch = zalloc(sizeof * privacySwitch);
+
+    if (!privacy_switch_init(privacySwitch, device)) {
+        privacy_switch_destroy(&privacySwitch->base);
+        privacySwitch = NULL;
+        return NULL;
+    }
+
+    device->base.config.sendevents = &privacySwitch->sendevents.config;
+    privacySwitch->sendevents.current_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+    privacySwitch->sendevents.config.get_modes = privacy_switch_sendevents_get_modes;
+    privacySwitch->sendevents.config.set_mode = privacy_switch_sendevents_set_mode;
+    privacySwitch->sendevents.config.get_mode = privacy_switch_sendevents_get_mode;
+    privacySwitch->sendevents.config.get_default_mode = privacy_switch_sendevents_get_default_mode;
+
+    return &privacySwitch->base;
+}
+
diff -Naur old/src/evdev-privacy-switch.h new/src/evdev-privacy-switch.h
--- old/src/evdev-privacy-switch.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-privacy-switch.h	2024-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef LIBINPUT_EVDEV_PRIVACY_SWITCH_H
+#define LIBINPUT_EVDEV_PRIVACY_SWITCH_H
+
+#include "evdev.h"
+#include "libinput-private.h"
+
+struct privacy_switch {
+	uint64_t time;
+	enum libinput_switch sw;
+	enum libinput_switch_state state;
+};
+
+struct evdev_dispatch* evdev_privacy_switch_create(struct evdev_device* device);
+
+#endif
diff -Naur old/src/evdev-tablet.c new/src/evdev-tablet.c
--- old/src/evdev-tablet.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-tablet.c	2024-01-01 00:00:00.000000000 +0800
@@ -220,6 +220,7 @@
 	case ABS_TILT_Y:
 	case ABS_DISTANCE:
 	case ABS_WHEEL:
+	case ABS_MT_TOOL_TYPE:
 		axis = evcode_to_axis(e->code);
 		if (axis == LIBINPUT_TABLET_TOOL_AXIS_NONE) {
 			evdev_log_bug_libinput(device,
@@ -231,7 +232,6 @@
 		tablet->prev_value[axis] = tablet->current_value[axis];
 		if (tablet_filter_axis_fuzz(tablet, device, e, axis))
 			break;
-
 		tablet->current_value[axis] = e->value;
 		set_bit(tablet->changed_axes, axis);
 		tablet_set_status(tablet, TABLET_AXES_UPDATED);
@@ -1184,6 +1184,7 @@
 			.serial = serial,
 			.tool_id = tool_id,
 			.refcount = 1,
+			.pressure.mt_tool_type = tablet->current_value[LIBINPUT_TABLET_TOOL_AXIS_TYPE],
 		};
 
 		tool_set_pressure_thresholds(tablet, tool);
@@ -2563,6 +2564,34 @@
 	return true;
 }
 
+static void
+tablet_reset_abs_resolution(struct evdev_device *device)
+{
+    if (!device->abs.is_fake_resolution) {
+        return;
+    }
+    struct libevdev *evdev = device->evdev;
+    const struct input_absinfo *absy;
+    const struct input_absinfo *absx;
+    size_t widthmm = 271;
+    size_t heightmm = 170;
+    size_t xres = 0;
+    size_t yres = 0;
+
+    absx = libevdev_get_abs_info(evdev, ABS_X);
+    absy = libevdev_get_abs_info(evdev, ABS_Y);
+    xres = (absx->maximum - absx->minimum) / widthmm;
+    yres = (absy->maximum - absy->minimum) / heightmm;
+    if (xres == 0 || yres == 0) {
+        return;
+    }
+    libevdev_set_abs_resolution(evdev, ABS_X, xres);
+    libevdev_set_abs_resolution(evdev, ABS_Y, yres);
+    device->abs.is_fake_resolution = false;
+    libinput_log_printf("\t\tdevice:%s no resolution or size hints, assuming a size of %dx%d mm\n",
+        device->devname, widthmm, heightmm);
+}
+
 static int
 tablet_init(struct tablet_dispatch *tablet,
 	    struct evdev_device *device)
@@ -2577,6 +2606,7 @@
 	tablet->status = TABLET_NONE;
 	tablet->current_tool.type = LIBINPUT_TOOL_NONE;
 	list_init(&tablet->tool_list);
+    tablet_reset_abs_resolution(device);
 
 	if (tablet_reject_device(device))
 		return -1;
diff -Naur old/src/evdev-tablet.h new/src/evdev-tablet.h
--- old/src/evdev-tablet.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-tablet.h	2024-01-01 00:00:00.000000000 +0800
@@ -152,6 +152,9 @@
 	case ABS_WHEEL:
 		axis = LIBINPUT_TABLET_TOOL_AXIS_SLIDER;
 		break;
+	case ABS_MT_TOOL_TYPE:
+		axis = LIBINPUT_TABLET_TOOL_AXIS_TYPE;
+		break;
 	default:
 		axis = LIBINPUT_TABLET_TOOL_AXIS_NONE;
 		break;
@@ -210,6 +213,9 @@
 	case LIBINPUT_TABLET_TOOL_AXIS_SIZE_MAJOR:
 		evcode = ABS_MT_TOUCH_MAJOR;
 		break;
+	case LIBINPUT_TABLET_TOOL_AXIS_TYPE:
+		evcode = ABS_MT_TOOL_TYPE;
+		break;
 	case LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR:
 		evcode = ABS_MT_TOUCH_MINOR;
 		break;
diff -Naur old/src/libinput.c new/src/libinput.c
--- old/src/libinput.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/libinput.c	2024-01-01 00:00:00.000000000 +0800
@@ -36,9 +36,12 @@
 
 #include "libinput.h"
 #include "libinput-private.h"
+#include "evdev-mt-touchpad.h"
 #include "evdev.h"
 #include "timer.h"
 #include "quirks.h"
+#include "evdev-joystick.h"
+#include "evdev-privacy-switch.h"
 
 #define require_event_type(li_, type_, retval_, ...)	\
 	if (type_ == LIBINPUT_EVENT_NONE) abort(); \
@@ -84,9 +87,16 @@
 	CASE_RETURN_STRING(LIBINPUT_EVENT_DEVICE_ADDED);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_DEVICE_REMOVED);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_KEYBOARD_KEY);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_TAP);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_MOTION);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_BUTTON);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_JOYSTICK_AXIS);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_JOYSTICK_BUTTON);	
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_AXIS);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_SCROLL_WHEEL);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_SCROLL_FINGER);
@@ -96,6 +106,9 @@
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_MOTION);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_CANCEL);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_FRAME);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_DOWN);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_UP);
+        CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCHPAD_MOTION);	
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_AXIS);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_TIP);
@@ -113,6 +126,7 @@
 	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_HOLD_BEGIN);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_HOLD_END);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_SWITCH_TOGGLE);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_MSDP);
 	case LIBINPUT_EVENT_NONE:
 		abort();
 	}
@@ -193,6 +207,11 @@
 	int32_t slot;
 	int32_t seat_slot;
 	struct device_coords point;
+	struct device_coord_rect tool_rect;
+	int32_t pressure;
+	struct touch_axis axis;
+	int32_t tool_type;
+	int32_t blob_id;
 };
 
 struct libinput_event_gesture {
@@ -202,8 +221,10 @@
 	int cancelled;
 	struct normalized_coords delta;
 	struct normalized_coords delta_unaccel;
+	struct sloted_coords_info solt_touches;
 	double scale;
 	double angle;
+	struct device_coords coords[5];
 };
 
 struct libinput_event_tablet_tool {
@@ -217,6 +238,7 @@
 	struct libinput_tablet_tool *tool;
 	enum libinput_tablet_tool_proximity_state proximity_state;
 	enum libinput_tablet_tool_tip_state tip_state;
+	int32_t mt_tool_type;
 };
 
 struct libinput_event_tablet_pad {
@@ -362,6 +384,7 @@
 	return event->device;
 }
 
+
 LIBINPUT_EXPORT struct libinput_event_pointer *
 libinput_event_get_pointer_event(struct libinput_event *event)
 {
@@ -374,7 +397,12 @@
 			   LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
 			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER,
 			   LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
-			   LIBINPUT_EVENT_POINTER_AXIS);
+			   LIBINPUT_EVENT_POINTER_AXIS,
+			   LIBINPUT_EVENT_POINTER_TAP,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD,
+			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN,
+			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END);
 
 	return (struct libinput_event_pointer *) event;
 }
@@ -404,6 +432,18 @@
 	return (struct libinput_event_touch *) event;
 }
 
+LIBINPUT_EXPORT struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+	return (struct libinput_event_touch *) event;
+}
+
 LIBINPUT_EXPORT struct libinput_event_gesture *
 libinput_event_get_gesture_event(struct libinput_event *event)
 {
@@ -417,7 +457,10 @@
 			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_HOLD_BEGIN,
-			   LIBINPUT_EVENT_GESTURE_HOLD_END);
+			   LIBINPUT_EVENT_GESTURE_HOLD_END,
+			   LIBINPUT_EVENT_POINTER_TAP,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return (struct libinput_event_gesture *) event;
 }
@@ -473,6 +516,19 @@
 	return (struct libinput_event_switch *) event;
 }
 
+LIBINPUT_EXPORT int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&(event->base)),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
+               LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+	return event->mt_tool_type;
+}
+
 LIBINPUT_EXPORT uint32_t
 libinput_event_keyboard_get_time(struct libinput_event_keyboard *event)
 {
@@ -558,18 +614,37 @@
 			   LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
 			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER,
 			   LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
-			   LIBINPUT_EVENT_POINTER_AXIS);
+			   LIBINPUT_EVENT_POINTER_AXIS,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->time;
 }
 
+LIBINPUT_EXPORT uint64_t
+libinput_event_get_sensortime(struct libinput_event *event)
+{
+	struct evdev_device *device = evdev_device(event->device);
+	int32_t seconds = device->sensor_timestamp.seconds;
+	int32_t microseconds = device->sensor_timestamp.microseconds;
+	return ((uint64_t)seconds * 1000 * 1000) + microseconds;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_get_hand_feature(struct libinput_event *event)
+{
+	struct evdev_device *device = evdev_device(event->device);
+	int32_t value = device->hand_status.hand_feature;
+	return value;
+}
+
 LIBINPUT_EXPORT double
 libinput_event_pointer_get_dx(struct libinput_event_pointer *event)
 {
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_MOTION);
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->delta.x;
 }
@@ -580,7 +655,8 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_MOTION);
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->delta.y;
 }
@@ -592,7 +668,8 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_MOTION);
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->delta_raw.x;
 }
@@ -604,7 +681,8 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_MOTION);
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD);
 
 	return event->delta_raw.y;
 }
@@ -671,7 +749,9 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_BUTTON);
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_TAP,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return event->button;
 }
@@ -682,7 +762,9 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_BUTTON);
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_TAP,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return event->state;
 }
@@ -694,11 +776,28 @@
 	require_event_type(libinput_event_get_context(&event->base),
 			   event->base.type,
 			   0,
-			   LIBINPUT_EVENT_POINTER_BUTTON);
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return event->seat_button_count;
 }
 
+LIBINPUT_EXPORT uint32_t
+libinput_event_pointer_get_finger_count(
+	struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
+
+	struct evdev_device *device = evdev_device(event->base.device);
+	struct evdev_dispatch *dispatch = device->dispatch;
+	struct tp_dispatch *tp = (struct tp_dispatch *)(dispatch);
+
+	return tp->nfingers_down;
+}
 LIBINPUT_EXPORT int
 libinput_event_pointer_has_axis(struct libinput_event_pointer *event,
 				enum libinput_pointer_axis axis)
@@ -930,6 +1029,20 @@
 }
 
 LIBINPUT_EXPORT double
+libinput_event_touch_get_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->point.y);
+}
+
+LIBINPUT_EXPORT double
 libinput_event_touch_get_y_transformed(struct libinput_event_touch *event,
 				       uint32_t height)
 {
@@ -945,7 +1058,7 @@
 }
 
 LIBINPUT_EXPORT double
-libinput_event_touch_get_y(struct libinput_event_touch *event)
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event)
 {
 	struct evdev_device *device = evdev_device(event->base.device);
 
@@ -955,9 +1068,358 @@
 			   LIBINPUT_EVENT_TOUCH_DOWN,
 			   LIBINPUT_EVENT_TOUCH_MOTION);
 
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_x(device, event->tool_rect.x, width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.y);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_y(device, event->tool_rect.y, height);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.w);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_x(device, event->tool_rect.w, width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.h);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_y(device, event->tool_rect.h, height);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->slot;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->seat_slot;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->point.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
 	return evdev_convert_to_mm(device->abs.absinfo_y, event->point.y);
 }
 
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.y);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_x, event->tool_rect.w);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event)
+{
+    struct evdev_device *device = evdev_device(event->base.device);
+
+    require_event_type(libinput_event_get_context(&event->base),
+               event->base.type,
+               0,
+               LIBINPUT_EVENT_TOUCHPAD_DOWN,
+               LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    return evdev_convert_to_mm(device->abs.absinfo_y, event->tool_rect.h);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		return 0.0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		return 0.0;
+	}
+	double range = evDevice->pressureMax;
+	if (range == 0.0) {
+		return 0.0;
+	}
+	double value = event->pressure / range;
+	return max(0.0, value);
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		libinput_log_printf("device is nullptr\n");
+		return 0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		libinput_log_printf("evdev_device is nullptr\n");
+		return 0;
+	}
+	const struct input_absinfo* absInfo = libevdev_get_abs_info(evDevice->evdev, ABS_MT_TOUCH_MAJOR);
+	if (absInfo == NULL) {
+		libinput_log_printf("ABS_MT_TOUCH_MAJOR absInfo is nullptr\n");
+		return 0;
+	}
+	if (event->axis.major > absInfo->maximum || event->axis.major < 0) {
+		libinput_log_printf(" major = %d > absInfo->maximum\n", event->axis.major);
+		return 0;
+	}
+    return event->axis.major;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+    struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		libinput_log_printf("device is nullptr\n");
+		return 0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		libinput_log_printf("evdev_device is nullptr\n");
+		return 0;
+	}
+	const struct input_absinfo* absInfo = libevdev_get_abs_info(evDevice->evdev, ABS_MT_TOUCH_MINOR);
+	if (absInfo == NULL) {
+		libinput_log_printf("ABS_MT_TOUCH_MAJOR absInfo is nullptr\n");
+		return 0;
+	}
+	if (event->axis.minor > absInfo->maximum || event->axis.minor < 0) {
+		libinput_log_printf(" major = %d > absInfo->maximum\n", event->axis.minor);
+		return 0;
+	}
+    return event->axis.minor;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return event->tool_type;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType)
+{
+	if (device == NULL) {
+		return -1;
+	}
+	return evdev_device_touchpad_btn_tool_type_down((struct evdev_device *)device, btnToolType);
+}
+
 LIBINPUT_EXPORT uint32_t
 libinput_event_gesture_get_time(struct libinput_event_gesture *event)
 {
@@ -1118,6 +1580,44 @@
 }
 
 LIBINPUT_EXPORT int
+libinput_event_gesture_get_device_coords_x(struct libinput_event_gesture *event, uint32_t idx)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->coords[idx].x;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_gesture_get_device_coords_y(struct libinput_event_gesture *event, uint32_t idx)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->coords[idx].y;
+}
+
+LIBINPUT_EXPORT struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(
+	struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE);
+
+	return &event->solt_touches;
+}
+
+LIBINPUT_EXPORT int
 libinput_event_tablet_tool_x_has_changed(
 				struct libinput_event_tablet_tool *event)
 {
@@ -1134,6 +1634,24 @@
 }
 
 LIBINPUT_EXPORT int
+libinput_has_event_led_type(struct libinput_device *device)
+{
+    return evdev_has_event_type((struct evdev_device *)device, EV_LED);
+}
+
+LIBINPUT_EXPORT int
+libinput_get_funckey_state(struct libinput_device *device,  unsigned int code)
+{
+    return evdev_get_event_value((struct evdev_device *)device, EV_LED, code);
+}
+
+LIBINPUT_EXPORT int
+libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state)
+{
+    return evdev_kernel_set_led_value((struct evdev_device *)device, code, state);
+}
+
+LIBINPUT_EXPORT int
 libinput_event_tablet_tool_y_has_changed(
 				struct libinput_event_tablet_tool *event)
 {
@@ -1892,11 +2410,8 @@
 	/* If we fail, we'll fail next time too */
 	libinput->quirks_initialized = true;
 
-	data_path = getenv("LIBINPUT_QUIRKS_DIR");
-	if (!data_path) {
-		data_path = LIBINPUT_QUIRKS_DIR;
-		override_file = LIBINPUT_QUIRKS_OVERRIDE_FILE;
-	}
+		data_path = (char *)LIBINPUT_QUIRKS_DIR;
+		override_file = (char *)LIBINPUT_QUIRKS_OVERRIDE_FILE;
 
 	quirks = quirks_init_subsystem(data_path,
 				       override_file,
@@ -2396,6 +2911,9 @@
 	case LIBINPUT_DEVICE_CAP_SWITCH:
 		capability = "CAP_SWITCH";
 		break;
+	case LIBINPUT_DEVICE_CAP_JOYSTICK:
+        capability = "CAP_JOYSTICK";
+        break;
 	}
 
 	log_bug_libinput(device->seat->libinput,
@@ -2459,6 +2977,30 @@
 }
 
 void
+touchpad_pointer_notify_motion(struct libinput_device *device,
+		      uint64_t time,
+		      const struct normalized_coords *delta,
+		      const struct device_float_coords *raw)
+{
+	struct libinput_event_pointer *motion_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	motion_event = zalloc(sizeof *motion_event);
+
+	*motion_event = (struct libinput_event_pointer) {
+		.time = time,
+		.delta = *delta,
+		.delta_raw = *raw,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD,
+			  &motion_event->base);
+}
+
+void
 pointer_notify_motion_absolute(struct libinput_device *device,
 			       uint64_t time,
 			       const struct device_coords *point)
@@ -2511,6 +3053,94 @@
 }
 
 void
+pointer_notify_button_touchpad(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state)
+{
+	struct libinput_event_pointer *button_event;
+	int32_t seat_button_count;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	button_event = zalloc(sizeof *button_event);
+
+	seat_button_count = update_seat_button_count(device->seat,
+						     button,
+						     state);
+
+	*button_event = (struct libinput_event_pointer) {
+		.time = time,
+		.button = button,
+		.state = state,
+		.seat_button_count = seat_button_count,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD,
+			  &button_event->base);
+}
+
+void
+pointer_notify_tap(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state)
+{
+	struct libinput_event_pointer *button_event;
+	int32_t seat_button_count;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	button_event = zalloc(sizeof *button_event);
+
+	seat_button_count = update_seat_button_count(device->seat,
+						     button,
+						     state);
+
+	*button_event = (struct libinput_event_pointer) {
+		.time = time,
+		.button = button,
+		.state = state,
+		.seat_button_count = seat_button_count,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_TAP,
+			  &button_event->base);
+}
+
+void
+gesture_notify_axis_finger(struct libinput_device *device,
+			  uint64_t time,
+			  enum libinput_event_type type,
+			  uint32_t axes,
+			  const struct normalized_coords *delta)
+{
+	struct libinput_event_pointer *axis_event;
+	const struct discrete_coords zero_discrete = {0};
+	const struct wheel_v120 zero_v120 = {0};
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	axis_event = zalloc(sizeof *axis_event);
+
+	*axis_event = (struct libinput_event_pointer) {
+		.time = time,
+		.delta = *delta,
+		.source = LIBINPUT_POINTER_AXIS_SOURCE_FINGER,
+		.axes = axes,
+		.discrete = zero_discrete,
+		.v120 = zero_v120,
+	};
+
+	post_device_event(device, time, type, &axis_event->base);
+}
+
+void
 pointer_notify_axis_finger(struct libinput_device *device,
 			  uint64_t time,
 			  uint32_t axes,
@@ -2639,11 +3269,33 @@
 }
 
 void
+touch_notify_msdp(struct libinput_device *device,
+			uint64_t time)
+{
+	struct libinput_event_touch *touch_event;
+
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_MSDP,
+			  &touch_event->base);
+}
+
+void
 touch_notify_touch_down(struct libinput_device *device,
 			uint64_t time,
 			int32_t slot,
 			int32_t seat_slot,
-			const struct device_coords *point)
+			int32_t pressure,
+			const struct extra_data *extraData,
+            const struct touch_axis *axis,
+			const struct device_coords *point,
+			int32_t tool_type,
+			const struct device_coord_rect *tool_rect)
 {
 	struct libinput_event_touch *touch_event;
 
@@ -2657,6 +3309,11 @@
 		.slot = slot,
 		.seat_slot = seat_slot,
 		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.blob_id = extraData->blob_id,
+		.axis = *axis,
+		.tool_type = tool_type,
 	};
 
 	post_device_event(device, time,
@@ -2669,7 +3326,12 @@
 			  uint64_t time,
 			  int32_t slot,
 			  int32_t seat_slot,
-			  const struct device_coords *point)
+			  int32_t pressure,
+			  const struct extra_data *extraData,
+              const struct touch_axis *axis,
+			  const struct device_coords *point,
+			  int32_t tool_type,
+			  const struct device_coord_rect *tool_rect)
 {
 	struct libinput_event_touch *touch_event;
 
@@ -2683,6 +3345,11 @@
 		.slot = slot,
 		.seat_slot = seat_slot,
 		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.axis = *axis,
+		.tool_type = tool_type,
+		.blob_id = extraData->blob_id,
 	};
 
 	post_device_event(device, time,
@@ -2694,7 +3361,8 @@
 touch_notify_touch_up(struct libinput_device *device,
 		      uint64_t time,
 		      int32_t slot,
-		      int32_t seat_slot)
+		      int32_t seat_slot,
+		      int32_t tool_type)
 {
 	struct libinput_event_touch *touch_event;
 
@@ -2707,6 +3375,7 @@
 		.time = time,
 		.slot = slot,
 		.seat_slot = seat_slot,
+		.tool_type = tool_type,
 	};
 
 	post_device_event(device, time,
@@ -2759,6 +3428,90 @@
 }
 
 void
+touchpad_notify_touch_down(struct libinput_device *device,
+			uint64_t time,
+			int32_t slot,
+			int32_t seat_slot,
+			int32_t pressure,
+			int32_t tool_type,
+			struct touch_axis axis,
+			const struct device_coords *point,
+			const struct device_coord_rect *tool_rect)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.point = *point,
+		.tool_rect = *tool_rect,
+		.pressure = pressure,
+		.axis = axis,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			  &touch_event->base);
+}
+
+void
+touchpad_notify_touch_motion(struct libinput_device *device,
+			  uint64_t time,
+			  int32_t slot,
+			  int32_t seat_slot,
+			  int32_t pressure,
+			  int32_t tool_type,
+			  struct touch_axis axis,
+			  const struct device_coords *point,
+			  const struct device_coord_rect *tool_rect)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.point = *point,
+		.tool_rect = *tool_rect,
+		.axis = axis,
+		.pressure = pressure,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_MOTION,
+			  &touch_event->base);
+}
+
+void
+touchpad_notify_touch_up(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t slot,
+		      int32_t seat_slot,
+		      int32_t tool_type,
+			  struct touch_axis axis)
+{
+	struct libinput_event_touch *touch_event;
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.axis = axis,
+		.tool_type = tool_type,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCHPAD_UP,
+			  &touch_event->base);
+}
+
+void
 tablet_notify_axis(struct libinput_device *device,
 		   uint64_t time,
 		   struct libinput_tablet_tool *tool,
@@ -2776,6 +3529,7 @@
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.tip_state = tip_state,
 		.axes = *axes,
+		.mt_tool_type = tool->pressure.mt_tool_type,
 	};
 
 	memcpy(axis_event->changed_axes,
@@ -2806,6 +3560,7 @@
 		.tip_state = LIBINPUT_TABLET_TOOL_TIP_UP,
 		.proximity_state = proximity_state,
 		.axes = *axes,
+		.mt_tool_type = tool->pressure.mt_tool_type,
 	};
 	memcpy(proximity_event->changed_axes,
 	       changed_axes,
@@ -2835,6 +3590,7 @@
 		.tip_state = tip_state,
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.axes = *axes,
+		.mt_tool_type = tool->pressure.mt_tool_type,
 	};
 	memcpy(tip_event->changed_axes,
 	       changed_axes,
@@ -2873,6 +3629,7 @@
 		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
 		.tip_state = tip_state,
 		.axes = *axes,
+		.mt_tool_type = tool->pressure.mt_tool_type,
 	};
 
 	post_device_event(device,
@@ -2999,6 +3756,7 @@
 	       bool cancelled,
 	       const struct normalized_coords *delta,
 	       const struct normalized_coords *unaccel,
+	       const struct sloted_coords_info *solt_touches,
 	       double scale,
 	       double angle)
 {
@@ -3019,6 +3777,48 @@
 		.angle = angle,
 	};
 
+	if (solt_touches != NULL) {
+		gesture_event->solt_touches = *solt_touches;
+	} else {
+        memset(&gesture_event->solt_touches, 0, sizeof(struct sloted_coords_info));
+    }
+
+	post_device_event(device, time, type,
+			  &gesture_event->base);
+}
+
+static void
+gesture_notify_private(struct libinput_device *device,
+	       uint64_t time,
+	       enum libinput_event_type type,
+	       int finger_count,
+	       int cancelled,
+	       const struct normalized_coords *delta,
+	       const struct normalized_coords *unaccel,
+	       double scale,
+	       double angle,
+		   struct device_coords *coords,
+		   int coordsLen)
+{
+	struct libinput_event_gesture *gesture_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_GESTURE))
+		return;
+
+	gesture_event = zalloc(sizeof *gesture_event);
+
+	*gesture_event = (struct libinput_event_gesture) {
+		.time = time,
+		.finger_count = finger_count,
+		.cancelled = cancelled,
+		.delta = *delta,
+		.delta_unaccel = *unaccel,
+		.scale = scale,
+		.angle = angle,
+	};
+
+	memcpy(gesture_event->coords, coords, coordsLen * sizeof(struct device_coords));
+
 	post_device_event(device, time, type,
 			  &gesture_event->base);
 }
@@ -3029,13 +3829,28 @@
 		     enum libinput_event_type type,
 		     int finger_count,
 		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel)
+		     const struct normalized_coords *unaccel,
+		     const struct sloted_coords_info *solt_touches)
 {
-	gesture_notify(device, time, type, finger_count, 0, delta, unaccel,
+	gesture_notify(device, time, type, finger_count, 0, delta, unaccel, solt_touches,
 		       0.0, 0.0);
 }
 
 void
+gesture_notify_swipe_private(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_event_type type,
+		     int finger_count,
+		     const struct normalized_coords *delta,
+		     const struct normalized_coords *unaccel,
+		     struct device_coords *coords,
+		     int coordsLen)
+{
+	gesture_notify_private(device, time, type, finger_count, 0, delta, unaccel,
+		       0.0, 0.0, coords, coordsLen);
+}
+
+void
 gesture_notify_swipe_end(struct libinput_device *device,
 			 uint64_t time,
 			 int finger_count,
@@ -3044,7 +3859,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_SWIPE_END,
-		       finger_count, cancelled, &zero, &zero, 0.0, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, 0.0, 0.0);
 }
 
 void
@@ -3058,7 +3873,7 @@
 		     double angle)
 {
 	gesture_notify(device, time, type, finger_count, 0,
-		       delta, unaccel, scale, angle);
+		       delta, unaccel, NULL, scale, angle);
 }
 
 void
@@ -3071,7 +3886,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_PINCH_END,
-		       finger_count, cancelled, &zero, &zero, scale, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, scale, 0.0);
 }
 
 void
@@ -3082,7 +3897,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_HOLD_BEGIN,
-		       finger_count, 0, &zero, &zero, 0.0, 0.0);
+		       finger_count, 0, &zero, &zero, NULL, 0.0, 0.0);
 }
 
 void
@@ -3094,7 +3909,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_HOLD_END,
-		       finger_count, cancelled, &zero, &zero, 0, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, 0, 0.0);
 }
 
 void
@@ -3127,6 +3942,63 @@
 #endif
 }
 
+void
+joysticks_notify_axis(struct libinput_device *device,
+		    uint64_t time,
+		    uint32_t axes,
+			const struct joystick_axis_abs_infos *axis_abs)
+{
+	struct libinput_event_joystick_axis* joystick_axis_event;
+
+	joystick_axis_event = zalloc(sizeof * joystick_axis_event);
+
+	*joystick_axis_event = (struct libinput_event_joystick_axis){
+		.type = EV_ABS,
+		.time = time,
+		.axis_value_mask = axes,
+		.abs_throttle = axis_abs->abs_throttle,
+		.abs_hat0x = axis_abs->abs_hat0x,
+		.abs_hat0y = axis_abs->abs_hat0y,
+		.abs_x = axis_abs->abs_x,
+		.abs_y = axis_abs->abs_y,
+		.abs_z = axis_abs->abs_z,
+		.abs_rx = axis_abs->abs_rx,
+		.abs_ry = axis_abs->abs_ry,
+		.abs_rz = axis_abs->abs_rz,
+		.abs_gas = axis_abs->abs_gas,
+		.abs_brake = axis_abs->abs_brake,
+	};
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_x.code, axis_abs->abs_x.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_y.code, axis_abs->abs_y.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_z.code, axis_abs->abs_z.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_rz.code, axis_abs->abs_rz.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_gas.code, axis_abs->abs_gas.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_brake.code, axis_abs->abs_brake.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_hat0x.code, axis_abs->abs_hat0x.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_hat0y.code, axis_abs->abs_hat0y.value);
+    libinput_log_printf("code:%d value:%d \r\n", axis_abs->abs_throttle.code, axis_abs->abs_throttle.value);
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_JOYSTICK_AXIS,
+			  &joystick_axis_event->base);
+}
+
+void privacy_switch_notify_event(struct libinput_device *device, uint64_t time, struct privacy_switch* ev_switch)
+{
+	struct libinput_event_switch *switch_event;
+
+	switch_event = zalloc(sizeof *switch_event);
+
+	*switch_event = (struct libinput_event_switch) {
+		.time = ev_switch->time,
+		.sw = ev_switch->sw,
+		.state = ev_switch->state,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_SWITCH_TOGGLE,
+			  &switch_event->base);
+}
+
 static void
 libinput_post_event(struct libinput *libinput,
 		    struct libinput_event *event)
@@ -3180,6 +4052,96 @@
 	libinput->events_in = (libinput->events_in + 1) % libinput->events_len;
 }
 
+
+LIBINPUT_EXPORT void
+libinput_post_handle_event(struct libinput* libinput, struct libinput_event* event)
+{
+	libinput_post_event(libinput, event);
+}
+
+LIBINPUT_EXPORT struct libinput_event_joystick_button*
+libinput_event_get_joystick_button_event(struct libinput_event* event)
+{
+    require_event_type(libinput_event_get_context(event),
+        event->type,
+        NULL,
+        LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return (struct libinput_event_joystick_button*)event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_joystick_axis*
+libinput_event_get_joystick_axis_event(struct libinput_event* event)
+{
+	require_event_type(libinput_event_get_context(event),
+        event->type,
+        NULL,
+        LIBINPUT_EVENT_JOYSTICK_AXIS);
+
+    return (struct libinput_event_joystick_axis*)event;
+}
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis)
+{
+	if (event == NULL) {
+		return 0;
+	}
+
+	return (event->axis_value_mask & (uint32_t)axis);
+}
+
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event)
+{
+	if (event == NULL) {
+		return 0;
+	}
+
+	return event->time;
+}
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis)
+{
+	switch (axis) {
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X:
+	return &event->abs_x;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y:
+	return &event->abs_y;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z:
+	return &event->abs_z;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX:
+	return &event->abs_rx;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY:
+	return &event->abs_ry;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ:
+	return &event->abs_rz;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE:
+	return &event->abs_throttle;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X:
+	return &event->abs_hat0x;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y:
+	return &event->abs_hat0y;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS:
+	return &event->abs_gas;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE:
+	return &event->abs_brake;
+	default:
+	break;
+	}
+
+	return NULL;
+}
+
 LIBINPUT_EXPORT struct libinput_event *
 libinput_get_event(struct libinput *libinput)
 {
@@ -3263,12 +4225,169 @@
 	return evdev_device_get_sysname((struct evdev_device *) device);
 }
 
+LIBINPUT_EXPORT const char*
+libinput_device_get_phys(struct libinput_device* device)
+{
+	struct libevdev* evdev = ((struct evdev_device*)device)->evdev;
+	if (evdev == NULL) {
+		return NULL;
+	}
+	return libevdev_get_phys(evdev);
+}
+
+LIBINPUT_EXPORT const char*
+libinput_device_get_uniq(struct libinput_device* device)
+{
+	struct libevdev* evdev = ((struct evdev_device*)device)->evdev;
+	if (evdev == NULL) {
+		return NULL;
+	}
+	return libevdev_get_uniq(evdev);
+}
+
 LIBINPUT_EXPORT const char *
 libinput_device_get_name(struct libinput_device *device)
 {
 	return evdev_device_get_name((struct evdev_device *) device);
 }
 
+LIBINPUT_EXPORT enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device)
+{
+	if(device == NULL)
+	{
+		return EVDEV_UDEV_TAG_INPUT;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	enum evdev_device_udev_tags udev_tags;
+	udev_tags = evdev_device_get_udev_device_tags(evdevDevice);
+    return udev_tags;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode)
+{
+	if(device == NULL)
+	{
+		return EVDEV_UDEV_TAG_INPUT;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_KEY)) {
+		return 0;
+	}
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_KEY, keyCode)) {
+		return 1;
+	}
+	return 0;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->minimum;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->maximum;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->fuzz;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->flat;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code)
+{
+	if(device == NULL)
+	{
+		return -1;
+	}
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	if (!libevdev_has_event_type(evdevDevice->evdev, EV_ABS)) {
+		return -1;
+	}
+	const struct input_absinfo *absinfo;
+	if (libevdev_has_event_code(evdevDevice->evdev, EV_ABS, code)) {
+		absinfo = libevdev_get_abs_info(evdevDevice->evdev, code);
+		return absinfo->resolution;
+	}
+	return -1;
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device)
+{
+	return evdev_device_get_id_bustype((struct evdev_device *) device);
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_get_id_version(struct libinput_device* device)
+{
+	return evdev_device_get_id_version((struct evdev_device *) device);
+}
+
 LIBINPUT_EXPORT unsigned int
 libinput_device_get_id_product(struct libinput_device *device)
 {
@@ -3356,6 +4475,15 @@
 }
 
 LIBINPUT_EXPORT int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType)
+{
+	if (device == NULL) {
+		return -1;
+	}
+	return evdev_device_touch_btn_tool_type_down((struct evdev_device *)device, btnToolType);
+}
+
+LIBINPUT_EXPORT int
 libinput_device_switch_has_switch(struct libinput_device *device,
 				  enum libinput_switch sw)
 {
@@ -3537,7 +4665,8 @@
 			   LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
 			   LIBINPUT_EVENT_POINTER_SCROLL_FINGER,
 			   LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
-			   LIBINPUT_EVENT_POINTER_AXIS);
+			   LIBINPUT_EVENT_POINTER_AXIS,
+			   LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD);
 
 	return &event->base;
 }
@@ -3558,6 +4687,19 @@
 }
 
 LIBINPUT_EXPORT struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_TOUCHPAD_DOWN,
+			   LIBINPUT_EVENT_TOUCHPAD_UP,
+			   LIBINPUT_EVENT_TOUCHPAD_MOTION);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
 libinput_event_gesture_get_base_event(struct libinput_event_gesture *event)
 {
 	require_event_type(libinput_event_get_context(&event->base),
@@ -4764,3 +5906,177 @@
 	}
 }
 #endif
+
+LIBINPUT_EXPORT struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event)
+{
+	if (!event)
+		return 0;
+
+	require_event_type(libinput_event_get_context(event),
+		event->type,
+		NULL,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+	return (struct libinput_event_joystick_button*)event;
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_joystick_button_time(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+        event->base.type,
+        0,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return event->time;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return event->key;
+}
+
+LIBINPUT_EXPORT enum libinput_button_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event)
+{
+	if (!event)
+		return 0;
+
+	require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+	return event->state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+		LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return event->seat_key_count;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+        LIBINPUT_EVENT_JOYSTICK_BUTTON);
+
+    return event->value;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_pressure(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_TOUCH_DOWN,
+		LIBINPUT_EVENT_TOUCH_UP,
+		LIBINPUT_EVENT_TOUCH_MOTION,
+		LIBINPUT_EVENT_TOUCH_CANCEL,
+		LIBINPUT_EVENT_TOUCH_FRAME);
+
+	struct libinput_device* device = libinput_event_get_device(&event->base);
+	if (device == NULL) {
+		return 0.0;
+	}
+	struct evdev_device* evDevice = evdev_device(device);
+	if (evDevice == NULL) {
+		return 0.0;
+	}
+
+	const struct input_absinfo* absInfo = evDevice->is_mt ? libevdev_get_abs_info(evDevice->evdev, ABS_MT_PRESSURE)
+		: libevdev_get_abs_info(evDevice->evdev, ABS_PRESSURE);
+	if (!absInfo) {
+		return 0.0;
+	}
+	double range = absInfo->maximum;
+	double value = event->pressure / range;
+	return max(0.0, value);
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_blob_id(struct libinput_event_touch* event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_TOUCH_DOWN,
+		LIBINPUT_EVENT_TOUCH_UP,
+		LIBINPUT_EVENT_TOUCH_MOTION,
+		LIBINPUT_EVENT_TOUCH_CANCEL,
+		LIBINPUT_EVENT_TOUCH_FRAME);
+
+	return event->blob_id;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return event->tool_type;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+                event->base.type,
+                0,
+                LIBINPUT_EVENT_TOUCH_DOWN,
+                LIBINPUT_EVENT_TOUCH_UP,
+                LIBINPUT_EVENT_TOUCH_MOTION,
+                LIBINPUT_EVENT_TOUCH_CANCEL,
+				LIBINPUT_EVENT_TOUCH_FRAME);
+
+    return event->axis.major;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event)
+{
+    require_event_type(libinput_event_get_context(&event->base),
+                event->base.type,
+                0,
+                LIBINPUT_EVENT_TOUCH_DOWN,
+                LIBINPUT_EVENT_TOUCH_UP,
+                LIBINPUT_EVENT_TOUCH_MOTION,
+                LIBINPUT_EVENT_TOUCH_CANCEL,
+				LIBINPUT_EVENT_TOUCH_FRAME);
+
+    return event->axis.minor;
+}
+
diff -Naur old/src/libinput.h new/src/libinput.h
--- old/src/libinput.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/libinput.h	2024-01-01 00:00:00.000000000 +0800
@@ -196,6 +196,23 @@
 	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
 	LIBINPUT_DEVICE_CAP_GESTURE = 5,
 	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+	LIBINPUT_DEVICE_CAP_JOYSTICK = 7,
+};
+
+enum evdev_device_udev_tags {
+    EVDEV_UDEV_TAG_INPUT = 1 << 0,
+    EVDEV_UDEV_TAG_KEYBOARD = 1 << 1,
+    EVDEV_UDEV_TAG_MOUSE = 1 << 2,
+    EVDEV_UDEV_TAG_TOUCHPAD = 1 << 3,
+    EVDEV_UDEV_TAG_TOUCHSCREEN = 1 << 4,
+    EVDEV_UDEV_TAG_TABLET = 1 << 5,
+    EVDEV_UDEV_TAG_JOYSTICK = 1 << 6,
+    EVDEV_UDEV_TAG_ACCELEROMETER = 1 << 7,
+    EVDEV_UDEV_TAG_TABLET_PAD = 1 << 8,
+    EVDEV_UDEV_TAG_POINTINGSTICK = 1 << 9,
+    EVDEV_UDEV_TAG_TRACKBALL = 1 << 10,
+    EVDEV_UDEV_TAG_SWITCH = 1 << 11,
+	EVDEV_UDEV_TAG_MSDP = 1 << 12,
 };
 
 /**
@@ -321,6 +338,49 @@
 };
 
 /**
+ * @ingroup event_joystick
+ *
+ * The source for a @ref LIBINPUT_EVENT_POINTER_AXIS event. See
+ * libinput_event_get_joystick_axis_event() for details.
+ *
+ * @since 1.16.4
+ */
+enum libinput_joystick_axis_source {
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_UNKNOWN = 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X = 1 << 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y = 1 << 1,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z = 1 << 2,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX = 1 << 3,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY = 1 << 4,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ = 1 << 5,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE = 1 << 6,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RUDDER = 1 << 7,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_WHEEL = 1 << 8,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS = 1 << 9,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE = 1 << 10,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X = 1 << 11,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y = 1 << 12,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1X = 1 << 13,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1Y = 1 << 14,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2X = 1 << 15,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2Y = 1 << 16,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3X = 1 << 17,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3Y = 1 << 18,
+};
+
+#define MAX_SOLTED_COORDS_NUM 10
+struct sloted_coords {
+	int32_t is_active;
+	float x;
+	float y;
+};
+
+struct sloted_coords_info {
+	struct sloted_coords coords[MAX_SOLTED_COORDS_NUM];
+	unsigned int active_count;
+};
+
+/**
  * @ingroup device
  *
  * Available tool types for a device with the @ref
@@ -393,6 +453,17 @@
 	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
 };
 
+struct libinput_event_joystick_axis_abs_info {
+	int32_t code;
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+	float	standardValue;
+};
+
 /**
  * @defgroup tablet_pad_modes Tablet pad modes
  *
@@ -702,6 +773,7 @@
 	 * in tablet mode.
 	 */
 	LIBINPUT_SWITCH_TABLET_MODE,
+	LIBINPUT_SWITCH_PRIVACY,
 };
 
 /**
@@ -822,6 +894,16 @@
 	 */
 	LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS,
 
+	LIBINPUT_EVENT_POINTER_TAP,
+	LIBINPUT_EVENT_POINTER_MOTION_TOUCHPAD,
+	LIBINPUT_EVENT_POINTER_BUTTON_TOUCHPAD,
+
+	LIBINPUT_EVENT_POINTER_SCROLL_FINGER_BEGIN,
+	LIBINPUT_EVENT_POINTER_SCROLL_FINGER_END,
+
+	LIBINPUT_EVENT_JOYSTICK_BUTTON = 450,
+	LIBINPUT_EVENT_JOYSTICK_AXIS,
+
 	LIBINPUT_EVENT_TOUCH_DOWN = 500,
 	LIBINPUT_EVENT_TOUCH_UP,
 	LIBINPUT_EVENT_TOUCH_MOTION,
@@ -832,6 +914,10 @@
 	 */
 	LIBINPUT_EVENT_TOUCH_FRAME,
 
+	LIBINPUT_EVENT_TOUCHPAD_DOWN = 550,
+	LIBINPUT_EVENT_TOUCHPAD_UP,
+	LIBINPUT_EVENT_TOUCHPAD_MOTION,
+
 	/**
 	 * One or more axes have changed state on a device with the @ref
 	 * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. This event is only sent
@@ -984,6 +1070,8 @@
 	 * @since 1.7
 	 */
 	LIBINPUT_EVENT_SWITCH_TOGGLE = 900,
+
+	LIBINPUT_EVENT_MSDP = 1000,
 };
 
 /**
@@ -1084,6 +1172,19 @@
 /**
  * @ingroup event
  *
+ * Return the touchpad event that is this input event. If the event type does
+ * not match the touchpad event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_touchpad_get_base_event().
+ *
+ * @return A touch event, or NULL for other events
+ */
+struct libinput_event_touch *
+libinput_event_get_touchpad_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
  * Return the gesture event that is this input event. If the event type does
  * not match the gesture event types, this function returns NULL.
  *
@@ -1486,6 +1587,21 @@
 /**
  * @ingroup event_pointer
  *
+ * For the button of a @ref LIBINPUT_EVENT_POINTER_BUTTON event, return the
+ * total number of fingers on touchpad.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_BUTTON. For other events, this function
+ * returns 0.
+ *
+ * @return The finger counts for touchpad button event
+ */
+uint32_t
+libinput_event_pointer_get_finger_count(
+	struct libinput_event_pointer *event);
+/**
+ * @ingroup event_pointer
+ *
  * Check if the event has a valid value for the given axis.
  *
  * If this function returns non-zero for an axis and
@@ -1870,6 +1986,120 @@
 				       uint32_t height);
 
 /**
+ * @brief 获取触摸屏的工具类型区域属性
+ */
+int32_t
+libinput_event_touch_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_x_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touch_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute x coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return The current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, in mm from the upper left corner of the device. To get the
+ * corresponding output screen coordinates, use
+ * libinput_event_touch_get_tool_y_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touch_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the absolute y coordinate of the center point of the current tool
+ * area, converted to screen coordinates.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return The current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_tool_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area. To get the corresponding output
+ * screen width, use
+ * libinput_event_touch_get_tool_width_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current width
+ */
+double
+libinput_event_touch_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the width of the current tool area, converted to screen width.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return Convert current width to screen width
+ */
+double
+libinput_event_touch_get_tool_width_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area. To get the corresponding output
+ * screen height, use
+ * libinput_event_touch_get_tool_height_transformed().
+ *
+ * @param event The libinput touch event
+ * @return The current height
+ */
+double
+libinput_event_touch_get_tool_height(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Returns the height of the current tool area, converted to screen height.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return Convert current height to screen height
+ */
+double
+libinput_event_touch_get_tool_height_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
  * @ingroup event_touch
  *
  * @return The generic libinput_event of this event
@@ -1878,6 +2108,228 @@
 libinput_event_touch_get_base_event(struct libinput_event_touch *event);
 
 /**
+ * @defgroup event_touch Touchpad events
+ *
+ * Events from absolute touchpad devices.
+ */
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_touchpad_get_time(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See the libinput documentation
+ * for more details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_touchpad_get_time_usec(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the slot of this touchpad event. See the kernel's multitouch
+ * protocol B documentation for more information.
+ *
+ * If the touchpad event has no assigned slot, for example if it is from a
+ * single touchpad device, this function returns -1.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The slot of this touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the seat slot of the touchpad event. A seat slot is a non-negative seat
+ * wide unique identifier of an active touchpad point.
+ *
+ * Events from single touchpad devices will be represented as one individual
+ * touchpad point per device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_UP or @ref LIBINPUT_EVENT_TOUCHPAD_MOTION,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref LIBINPUT_EVENT_TOUCHPAD_UP or
+ * @ref LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @return The seat slot of the touchpad event
+ */
+int32_t
+libinput_event_touchpad_get_seat_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute x coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touchpad_get_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute y coordinate of the touchpad event, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCHPAD_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION.
+ *
+ * @param event The libinput touchpad event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touchpad_get_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the pressure of the touch pad
+ *
+ * @param event The libinput touch event
+ * @return Touchpad pressure value
+ *
+ */
+double
+libinput_event_touchpad_get_pressure(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The long axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touchpoint region of the touchpad
+ *
+ * @param event The libinput touch event
+ * @return The short axis value of the touchpoint area of the touchpad
+ */
+int32_t
+libinput_event_touchpad_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板的工具类型区域属性
+ */
+int32_t
+libinput_event_touchpad_get_tool_type(struct libinput_event_touch *event);
+
+/**
+ * @brief 获取触摸板工具类型按钮是否按下
+ */
+int32_t
+libinput_device_touchpad_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
+ * @ingroup event_touch
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_touchpad_get_base_event(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the X coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The X coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the Y coordinate of the center of the contact tool contour, in mm from
+ * the top left corner of the device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The Y coordinate of the center of the contact tool contour
+ */
+double
+libinput_event_touchpad_get_tool_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the width of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The width of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_width(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the height of the current tool area.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCHPAD_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCHPAD_MOTION, this function returns 0.
+ *
+ * @param event The libinput touchpad event
+ * @return The height of the current tool area
+ */
+double
+libinput_event_touchpad_get_tool_height(struct libinput_event_touch *event);
+
+/**
  * @defgroup event_gesture Gesture events
  *
  * Gesture events are generated when a gesture is recognized on a touchpad.
@@ -2090,6 +2542,49 @@
 libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);
 
 /**
+ * 获取gesture中手指的坐标信息, idx表示手指的索引
+ */
+int
+libinput_event_gesture_get_device_coords_x(struct libinput_event_gesture *event, uint32_t idx);
+int
+libinput_event_gesture_get_device_coords_y(struct libinput_event_gesture *event, uint32_t idx);
+/**
+ * 获取带slot的touches信息, 仅支持LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE
+ */
+struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(struct libinput_event_gesture *event);
+
+/**
+ * @brief Obtain the device values the EV_LED event type
+ *
+ * @param device  A current input device
+ * @return int Obtained is Supported
+ */
+int libinput_has_event_led_type(struct libinput_device *device);
+
+/**
+ * @brief Obtain the function key enablement status of a keyboard device
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @return int Obtained state
+ */
+int libinput_get_funckey_state(struct libinput_device *device, unsigned int code);
+
+/**
+ * @brief Turn an LED on or off. Convenience function, if you need to modify multiple
+ * LEDs simultaneously, use libinput_set_led_state() instead.
+ *
+ * @param device  A current input device
+ * @param code The EV_LED event code to modify, one of LED_NUML, LED_CAPSL,
+ * given code (see linux/input-event-codes.h).
+ * @param state value Specifies whether to turn the LED on or off
+ * @return int 0 on success, or a negative errno on failure
+ */
+int libinput_set_led_state(struct libinput_device *device, unsigned int code, unsigned int state);
+
+/**
  * @defgroup event_tablet Tablet events
  *
  * Events that come from tools on tablet devices. For events from the pad,
@@ -2817,6 +3312,19 @@
 /**
  * @ingroup event_tablet
  *
+ * Get the stylus event type reported from evdev_tablet
+ *
+ * @param event The libinput tablet tool event
+ * @return Tool type for stylus events
+ *
+ * @since 1.2
+ */
+int32_t
+libinput_event_tablet_tool_get_tool_type(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
  * Return the high-level tool type for a tool object.
  *
  * The high level tool describes general interaction expected with the tool.
@@ -3663,6 +4171,56 @@
 int
 libinput_dispatch(struct libinput *libinput);
 
+/****************************************************************************
+* @brief : brief
+* @author : fms
+* @date : 2021/3/8 20:55
+* @version : ver 1.0
+* @inparam :libinput  event
+* @outparam :
+*****************************************************************************/
+void
+libinput_post_handle_event(struct libinput* libinput,
+	struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick button event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_button_event(struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick axis event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam :
+* @outparam :
+*****************************************************************************/
+struct libinput_event_joystick_axis*
+    libinput_event_get_joystick_axis_event(struct libinput_event* event);
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event);
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+int32_t libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
 /**
  * @ingroup base
  *
@@ -4133,6 +4691,42 @@
 const char *
 libinput_device_get_name(struct libinput_device *device);
 
+/**  @brief   获取设备类型*/
+enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device);
+
+/**  @brief   设备按键能力查询*/
+int32_t
+libinput_device_has_key(struct libinput_device* device, int32_t keyCode);
+
+/**  @brief   获取设备特定轴的最小值*/
+int32_t
+libinput_device_get_axis_min(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的最大值*/
+int32_t
+libinput_device_get_axis_max(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的fuzz值*/
+int32_t
+libinput_device_get_axis_fuzz(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的flat值*/
+int32_t
+libinput_device_get_axis_flat(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备特定轴的resolution值*/
+int32_t
+libinput_device_get_axis_resolution(struct libinput_device* device, int32_t code);
+
+/**  @brief   获取设备的bustype值*/
+unsigned int
+libinput_device_get_id_bustype(struct libinput_device* device);
+
+/**  @brief   获取设备的version值*/
+unsigned int
+libinput_device_get_id_version(struct libinput_device* device);
+
 /**
  * @ingroup device
  *
@@ -4343,6 +4937,12 @@
 libinput_device_touch_get_touch_count(struct libinput_device *device);
 
 /**
+ * @brief 获取触摸屏工具类型按钮是否按下
+ */
+int
+libinput_device_touch_btn_tool_type_down(struct libinput_device *device, int32_t btnToolType);
+
+/**
  * @ingroup device
  *
  * Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
@@ -5722,6 +6322,9 @@
 enum libinput_config_click_method
 libinput_device_config_click_get_default_method(struct libinput_device *device);
 
+uint64_t
+libinput_event_get_sensortime(struct libinput_event *event);
+
 /**
  * @ingroup config
  */
@@ -6398,7 +7001,108 @@
 unsigned int
 libinput_device_config_rotation_get_default_angle(struct libinput_device *device);
 
+/**
+ * @ingroup event
+ *
+ * Get the struct libinput_event_joystick_button from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput_event_joystick_button for this event.
+ */
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the time from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The time for this event.
+ */
+uint64_t libinput_event_joystick_button_time(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the key value from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The key value for this event.
+ */
+uint32_t libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the seat key count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The seat key count for this event.
+ */
+uint32_t libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the value count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The value for this event.
+ */
+int libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the pressure of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Pressure value of touch screen
+ *
+ * @since 1.4
+ */
+double
+libinput_event_touch_get_pressure(struct libinput_event_touch* event);
+
+int32_t
+libinput_event_get_hand_feature(struct libinput_event *event);
+
+int32_t
+libinput_event_touch_get_blob_id(struct libinput_event_touch* event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the long axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Long axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_long_axis(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Gets the short axis of the touch point region of the touch screen
+ *
+ * @param event The libinput touch event
+ * @return Short axis value of touch point region
+ */
+int32_t
+libinput_event_get_touch_contact_short_axis(struct libinput_event_touch *event);
+
+const char*
+libinput_device_get_phys(struct libinput_device* device);
+
+const char*
+libinput_device_get_uniq(struct libinput_device* device);
+
+enum libinput_button_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event);
 #ifdef __cplusplus
 }
 #endif
 #endif /* LIBINPUT_H */
+
diff -Naur old/src/libinput-private.h new/src/libinput-private.h
--- old/src/libinput-private.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/libinput-private.h	2024-01-01 00:00:00.000000000 +0800
@@ -43,12 +43,24 @@
 #include "libinput-version.h"
 
 struct libinput_source;
+struct privacy_switch;
+
+/* The extra data of mt_slot struction */
+struct extra_data {
+	int32_t blob_id;
+};
 
 /* A coordinate pair in device coordinates */
 struct device_coords {
 	int x, y;
 };
 
+/* Size of touch point region (major and minor axes of ellipse) */
+struct touch_axis {
+    int32_t major;
+    int32_t minor;
+};
+
 /*
  * A coordinate pair in device coordinates, capable of holding non discrete
  * values, this is necessary e.g. when device coordinates get averaged.
@@ -424,7 +436,8 @@
 	LIBINPUT_TABLET_TOOL_AXIS_SLIDER = 8,
 	LIBINPUT_TABLET_TOOL_AXIS_REL_WHEEL = 9,
 	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MAJOR = 10,
-	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR = 11,
+	LIBINPUT_TABLET_TOOL_AXIS_TYPE = 11,
+	LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR = 12,
 };
 
 #define LIBINPUT_TABLET_TOOL_AXIS_MAX LIBINPUT_TABLET_TOOL_AXIS_SIZE_MINOR
@@ -463,7 +476,7 @@
 		struct threshold threshold; /* in device coordinates */
 		int offset; /* in device coordinates */
 		bool has_offset;
-
+		int32_t mt_tool_type;
 		enum pressure_heuristic_state heuristic_state;
 	} pressure;
 };
@@ -498,6 +511,20 @@
 	void *notify_func_data;
 };
 
+struct joystick_axis_abs_infos {
+	struct libinput_event_joystick_axis_abs_info abs_throttle;
+	struct libinput_event_joystick_axis_abs_info abs_hat0x;
+	struct libinput_event_joystick_axis_abs_info abs_hat0y;
+	struct libinput_event_joystick_axis_abs_info abs_x;
+	struct libinput_event_joystick_axis_abs_info abs_y;
+	struct libinput_event_joystick_axis_abs_info abs_z;
+	struct libinput_event_joystick_axis_abs_info abs_rx;
+	struct libinput_event_joystick_axis_abs_info abs_ry;
+	struct libinput_event_joystick_axis_abs_info abs_rz;
+	struct libinput_event_joystick_axis_abs_info abs_gas;
+	struct libinput_event_joystick_axis_abs_info abs_brake;
+};
+
 typedef void (*libinput_source_dispatch_t)(void *data);
 
 #define log_debug(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_DEBUG, __VA_ARGS__)
@@ -628,6 +655,12 @@
 		      const struct device_float_coords *raw);
 
 void
+touchpad_pointer_notify_motion(struct libinput_device *device,
+		      uint64_t time,
+		      const struct normalized_coords *delta,
+		      const struct device_float_coords *raw);
+
+void
 pointer_notify_motion_absolute(struct libinput_device *device,
 			       uint64_t time,
 			       const struct device_coords *point);
@@ -639,6 +672,18 @@
 		      enum libinput_button_state state);
 
 void
+pointer_notify_button_touchpad(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state);
+
+void
+pointer_notify_tap(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state);
+
+void
 pointer_notify_axis_finger(struct libinput_device *device,
 			   uint64_t time,
 			   uint32_t axes,
@@ -664,24 +709,39 @@
 			  const struct wheel_v120 *v120);
 
 void
+touch_notify_msdp(struct libinput_device *device,
+			  uint64_t time);
+
+void
 touch_notify_touch_down(struct libinput_device *device,
 			uint64_t time,
 			int32_t slot,
 			int32_t seat_slot,
-			const struct device_coords *point);
+			int32_t pressure,
+			const struct extra_data *extraData,
+            const struct touch_axis *axis,
+			const struct device_coords *point,
+			int32_t tool_type,
+			const struct device_coord_rect *tool_rect);
 
 void
 touch_notify_touch_motion(struct libinput_device *device,
 			  uint64_t time,
 			  int32_t slot,
 			  int32_t seat_slot,
-			  const struct device_coords *point);
+			  int32_t pressure,
+			  const struct extra_data *extraData,
+              const struct touch_axis *axis,
+			  const struct device_coords *point,
+			  int32_t tool_type,
+			  const struct device_coord_rect *tool_rect);
 
 void
 touch_notify_touch_up(struct libinput_device *device,
 		      uint64_t time,
 		      int32_t slot,
-		      int32_t seat_slot);
+		      int32_t seat_slot,
+		      int32_t tool_type);
 
 void
 touch_notify_touch_cancel(struct libinput_device *device,
@@ -694,12 +754,53 @@
 		   uint64_t time);
 
 void
+touchpad_notify_touch_down(struct libinput_device *device,
+			uint64_t time,
+			int32_t slot,
+			int32_t seat_slot,
+			int32_t pressure,
+			int32_t tool_type,
+			struct touch_axis axis,
+			const struct device_coords *point,
+			const struct device_coord_rect *tool_rect);
+
+void
+touchpad_notify_touch_motion(struct libinput_device *device,
+			  uint64_t time,
+			  int32_t slot,
+			  int32_t seat_slot,
+			  int32_t pressure,
+			  int32_t tool_type,
+			  struct touch_axis axis,
+			  const struct device_coords *point,
+			  const struct device_coord_rect *tool_rect);
+
+void
+touchpad_notify_touch_up(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t slot,
+		      int32_t seat_slot,
+		      int32_t tool_type,
+			  struct touch_axis axis);
+
+void
 gesture_notify_swipe(struct libinput_device *device,
 		     uint64_t time,
 		     enum libinput_event_type type,
 		     int finger_count,
 		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel);
+		     const struct normalized_coords *unaccel,
+		     const struct sloted_coords_info *raw_touches);
+
+void
+gesture_notify_swipe_private(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_event_type type,
+		     int finger_count,
+		     const struct normalized_coords *delta,
+		     const struct normalized_coords *unaccel,
+			 struct device_coords *coords,
+			 int coordsLen);
 
 void
 gesture_notify_swipe_end(struct libinput_device *device,
@@ -725,6 +826,13 @@
 			 bool cancelled);
 
 void
+gesture_notify_axis_finger(struct libinput_device *device,
+			  uint64_t time,
+			  enum libinput_event_type type,
+			  uint32_t axes,
+			  const struct normalized_coords *delta);
+
+void
 gesture_notify_hold(struct libinput_device *device,
 		    uint64_t time,
 		    int finger_count);
@@ -799,6 +907,17 @@
 		     enum libinput_switch sw,
 		     enum libinput_switch_state state);
 
+void
+joysticks_notify_axis(struct libinput_device *device,
+			uint64_t time,
+			uint32_t axes,
+			const struct joystick_axis_abs_infos *axis_abs);
+
+void
+privacy_switch_notify_event(struct libinput_device *device,
+			uint64_t time,
+			struct privacy_switch* ev_switch);
+
 static inline uint64_t
 libinput_now(struct libinput *libinput)
 {
diff -Naur old/src/libinput-util.c new/src/libinput-util.c
--- old/src/libinput-util.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/libinput-util.c	2024-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,102 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2013-2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * This list data structure is verbatim copy from wayland-util.h from the
+ * Wayland project; except that wl_ prefix has been removed.
+ */
+
+#include "libinput-util.h"
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+
+static FILE* p_log_fp = NULL;
+
+FILE *libinput_get_log_fp()
+{
+    if (p_log_fp == NULL) {
+        const char *pLogDir = getenv("LIBINPUT_LOG_DIR");
+        if (pLogDir == NULL) {
+            pLogDir = (char *)_LIBINPUT_LOG_DIR;
+        }
+
+        const int r = mkdir(pLogDir, 0755);
+        if (r < 0 && errno != EEXIST) {
+            const int saved_errno = errno;
+            printf("could not create %s, errno: %d\n", pLogDir, saved_errno);
+            return NULL;
+        }
+
+        const char *p_log_path = getenv("LIBINPUT_LOG_PATH");
+        if (p_log_path == NULL) {
+            p_log_path = (char *)_LIBINPUT_LOG_PATH;
+        }
+        p_log_fp = fopen(p_log_path, "w+");
+    }
+
+    return p_log_fp;
+}
+
+void libinput_log_printf(const char* fmt, ...)
+{
+    p_log_fp = libinput_get_log_fp();
+#ifdef HAVE_LIBINPUT_LOG_CONSOLE_ENABLE
+    char buf[1024] = {0};
+
+    va_list args;
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    buf[1024 - 1] = '\0';
+
+    printf("%s\n", buf);
+
+    if (p_log_fp != NULL) {
+        fputs(buf, p_log_fp);
+        fflush(p_log_fp);
+    }
+#else
+    if (p_log_fp != NULL) {
+        va_list args;
+        va_start(args, fmt);
+        vfprintf(p_log_fp, fmt, args);
+        va_end(args);
+        fflush(p_log_fp);
+    }
+#endif
+}
+
+uint64_t getMicrotime()
+{
+    struct timeval currentTime;
+    gettimeofday(&currentTime, NULL);
+    return currentTime.tv_sec * 1000000 + currentTime.tv_usec;
+}
+
+uint64_t getTranTime(struct input_event *event)
+{
+    return event->input_event_sec * 1000000 + event->input_event_usec;
+}
+#endif
diff -Naur old/src/libinput-util.h new/src/libinput-util.h
--- old/src/libinput-util.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/libinput-util.h	2024-01-01 00:00:00.000000000 +0800
@@ -27,9 +27,9 @@
 
 #include "config.h"
 
-#ifdef NDEBUG
-#warning "libinput relies on assert(). #defining NDEBUG is not recommended"
-#endif
+// #ifdef NDEBUG
+// #warning "libinput relies on assert(). #defining NDEBUG is not recommended"
+// #endif
 
 #include "libinput.h"
 
@@ -56,6 +56,15 @@
 #define DEFAULT_MOUSE_DPI 1000
 #define DEFAULT_TRACKPOINT_SENSITIVITY 128
 
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+void libinput_log_printf(const char* fmt, ...);
+uint64_t getMicrotime();
+uint64_t getTranTime(struct input_event *event);
+#else
+#define libinput_log_printf(fmt, ...)
+#endif
+
 #define trace(...) \
 	do { \
 	printf("%s() - \033[0;31m", __func__); \
diff -Naur old/src/udev-seat.c new/src/udev-seat.c
--- old/src/udev-seat.c	2024-01-01 00:00:00.000000000 +0800
+++ new/src/udev-seat.c	2024-01-01 00:00:00.000000000 +0800
@@ -190,6 +190,7 @@
 
 		/* Skip unconfigured device. udev will send an event
 		 * when device is fully configured  */
+/*
 		if (!udev_device_get_is_initialized(device)) {
 			log_debug(&input->base,
 				  "%-7s - skip unconfigured input device '%s'\n",
@@ -198,6 +199,13 @@
 			udev_device_unref(device);
 			continue;
 		}
+*/
+		if (!udev_device_get_is_initialized(device)) {
+			log_info(&input->base,
+				  "%-7s - unconfigured input device '%s'\n",
+				  sysname,
+				  udev_device_get_devnode(device));
+		}
 
 		if (device_added(device, input, NULL) < 0) {
 			udev_device_unref(device);
diff -Naur old/src/util-strings.h new/src/util-strings.h
--- old/src/util-strings.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/util-strings.h	2024-07-11 10:45:06.197570145 +0800
@@ -308,7 +308,7 @@
 	if (!strv)
 		return result;
 
-	double *numv = zalloc(sizeof(double) * nelem);
+	double *numv = (double *)zalloc(sizeof(double) * nelem);
 	for (size_t idx = 0; idx < nelem; idx++) {
 		double val;
 		if (!safe_atod(strv[idx], &val))
@@ -355,7 +355,7 @@
 	if (!pairs || npairs == 0)
 		goto error;
 
-	result = zalloc(npairs * sizeof *result);
+	result = (struct key_value_double *)zalloc(npairs * sizeof *result);
 
 	for (size_t idx = 0; idx < npairs; idx++) {
 		char *pair = pairs[idx];
@@ -468,7 +468,7 @@
 		return strdup(str);
 
 	size_t slen = min(strlen(str), 512);
-	char *sanitized = zalloc(2 * slen + 1);
+	char *sanitized = (char *)zalloc(2 * slen + 1);
 	const char *src = str;
 	char *dst = sanitized;
 
diff -Naur old/src/util-time.h new/src/util-time.h
--- old/src/util-time.h	2024-01-01 00:00:00.000000000 +0800
+++ new/src/util-time.h	2024-01-01 00:00:00.000000000 +0800
@@ -109,7 +109,8 @@
 static inline struct human_time
 to_human_time(uint64_t us)
 {
-	struct human_time t;
+	uint64_t l = 0;
+	struct human_time t = {0, NULL};
 	struct c {
 		const char *unit;
 		unsigned int change_from_previous;
@@ -120,7 +121,7 @@
 		{"s", 1000, 120},
 		{"min", 60, 120},
 		{"h", 60, 48},
-		{"d", 24, ~0},
+		{"d", 24, ~l},
 	};
 	uint64_t value = us;
 
@@ -132,6 +133,6 @@
 			return t;
 		}
 	}
-
-	assert(!"We should never get here");
+return t;
+	//assert(1);
 }
diff -Naur old/tools/libinput-debug-events.c new/tools/libinput-debug-events.c
--- old/tools/libinput-debug-events.c	2024-01-01 00:00:00.000000000 +0800
+++ new/tools/libinput-debug-events.c	2024-01-01 00:00:00.000000000 +0800
@@ -110,6 +110,15 @@
 	case LIBINPUT_EVENT_TOUCH_FRAME:
 		type = "TOUCH_FRAME";
 		break;
+	case LIBINPUT_EVENT_TOUCHPAD_DOWN:
+		type = "TOUCHPAD_DOWN";
+		break;
+	case LIBINPUT_EVENT_TOUCHPAD_MOTION:
+		type = "TOUCHPAD_MOTION";
+		break;
+	case LIBINPUT_EVENT_TOUCHPAD_UP:
+		type = "TOUCHPAD_UP";
+		break;
 	case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
 		type = "GESTURE_SWIPE_BEGIN";
 		break;
@@ -161,6 +170,8 @@
 	case LIBINPUT_EVENT_SWITCH_TOGGLE:
 		type = "SWITCH_TOGGLE";
 		break;
+	default:
+		break;
 	}
 
 	prefix = (last_device != dev) ? '-' : ' ';
@@ -297,6 +308,10 @@
 					   LIBINPUT_DEVICE_CAP_SWITCH))
 		printq("S");
 
+    if (libinput_device_has_capability(dev,
+        LIBINPUT_DEVICE_CAP_JOYSTICK))
+        printq("JOYSTICK");
+
 	if (libinput_device_get_size(dev, &w, &h) == 0)
 		printq("  size %.0fx%.0fmm", w, h);
 
@@ -547,6 +562,15 @@
 }
 
 static void
+print_touchpad_event_without_coords(struct libinput_event *ev)
+{
+	struct libinput_event_touch *t = libinput_event_get_touchpad_event(ev);
+
+	print_event_time(libinput_event_touchpad_get_time(t));
+	printq("\n");
+}
+
+static void
 print_proximity_event(struct libinput_event *ev)
 {
 	struct libinput_event_tablet_tool *t = libinput_event_get_tablet_tool_event(ev);
@@ -673,6 +697,21 @@
 }
 
 static void
+print_touchpad_event_with_coords(struct libinput_event *ev)
+{
+	struct libinput_event_touch *t = libinput_event_get_touchpad_event(ev);
+	double xmm = libinput_event_touchpad_get_x(t);
+	double ymm = libinput_event_touchpad_get_y(t);
+
+	print_event_time(libinput_event_touchpad_get_time(t));
+
+	printq("%d (%d) %5.2f/%5.2fmm\n",
+	       libinput_event_touchpad_get_slot(t),
+	       libinput_event_touchpad_get_seat_slot(t),
+	       xmm, ymm);
+}
+
+static void
 print_gesture_event_without_coords(struct libinput_event *ev)
 {
 	struct libinput_event_gesture *t = libinput_event_get_gesture_event(ev);
@@ -895,6 +934,15 @@
 		case LIBINPUT_EVENT_TOUCH_FRAME:
 			print_touch_event(ev);
 			break;
+		case LIBINPUT_EVENT_TOUCHPAD_DOWN:
+			print_touchpad_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCHPAD_MOTION:
+			print_touchpad_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCHPAD_UP:
+			print_touchpad_event_without_coords(ev);
+			break;
 		case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
 			print_gesture_event_without_coords(ev);
 			break;
@@ -946,6 +994,8 @@
 		case LIBINPUT_EVENT_SWITCH_TOGGLE:
 			print_switch_event(ev);
 			break;
+		default:
+			break;
 		}
 
 		libinput_event_destroy(ev);
diff -Naur old/tools/libinput-record.c new/tools/libinput-record.c
--- old/tools/libinput-record.c	2024-01-01 00:00:00.000000000 +0800
+++ new/tools/libinput-record.c	2024-01-01 00:00:00.000000000 +0800
@@ -53,6 +53,7 @@
 #include "util-time.h"
 #include "util-input-event.h"
 #include "util-macros.h"
+#include "hm_missing.h"
 
 static const int FILE_VERSION_NUMBER = 1;
 
diff -Naur old/udev/libinput-device-group.c new/udev/libinput-device-group.c
--- old/udev/libinput-device-group.c	2024-01-01 00:00:00.000000000 +0800
+++ new/udev/libinput-device-group.c	2024-01-01 00:00:00.000000000 +0800
@@ -137,7 +137,7 @@
 				*product_id = pid;
 				best_dist = dist;
 
-				free(*phys_attr);
+				free((char*)*phys_attr);
 				*phys_attr = safe_strdup(phys);
 			}
 		}
